/*! For license information please see app.js.LICENSE.txt */
!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var I=F[U]={i:U,l:!1,exports:{}};return Q[U].call(I.exports,I,I.exports,B),I.l=!0,I.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var I in Q)B.d(U,I,function(F){return Q[F]}.bind(null,I));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s="./js/index.js")}({"../node_modules/@babel/runtime/helpers/interopRequireDefault.js":function(module,exports){eval('function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzP2ViNzAiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxzQkFBVCxDQUFnQ0MsR0FBaEMsRUFBcUM7QUFDbkMsU0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVgsR0FBd0JELEdBQXhCLEdBQThCO0FBQ25DLGVBQVdBO0FBRHdCLEdBQXJDO0FBR0Q7O0FBRURFLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosc0JBQWpCIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@babel/runtime/helpers/interopRequireDefault.js\n')},"../node_modules/gsap/CSSPlugin.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return CSSPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSSPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getBBox", function() { return _getBBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_createElement", function() { return _createElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPrefix", function() { return _checkPropPrefix; });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "../node_modules/gsap/gsap-core.js");\n/*!\n * CSSPlugin 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar _win,\n    _doc,\n    _docElement,\n    _pluginInitted,\n    _tempDiv,\n    _tempDivStyler,\n    _recentSetterPlugin,\n    _windowExists = function _windowExists() {\n  return typeof window !== "undefined";\n},\n    _transformProps = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _atan2 = Math.atan2,\n    _bigNum = 1e8,\n    _capsExp = /([A-Z])/g,\n    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,\n    _complexExp = /[\\s,\\(]\\S/,\n    _propertyAliases = {\n  autoAlpha: "opacity,visibility",\n  scale: "scaleX,scaleY",\n  alpha: "opacity"\n},\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n},\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n},\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n},\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n},\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n  return target.style[property] = value;\n},\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\n  return target.style.setProperty(property, value);\n},\n    _setterTransform = function _setterTransform(target, property, value) {\n  return target._gsap[property] = value;\n},\n    _setterScale = function _setterScale(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n},\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n},\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n},\n    _transformProp = "transform",\n    _transformOriginProp = _transformProp + "Origin",\n    _supports3D,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.\n\n  return e.style ? e : _doc.createElement(type); //some environments won\'t allow access to the element\'s style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won\'t allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.\n},\n    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n  var e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n\n  while (i-- && !(_prefixes[i] + property in s)) {}\n\n  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;\n},\n    _initCore = function _initCore() {\n  if (_windowExists() && window.document) {\n    _win = window;\n    _doc = _win.document;\n    _docElement = _doc.documentElement;\n    _tempDiv = _createElement("div") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement("div");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + "Origin";\n    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n\n    _supports3D = !!_checkPropPrefix("perspective");\n    _pluginInitted = 1;\n  }\n},\n    _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n  //works around issues in some browsers (like Firefox) that don\'t correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it\'s definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don\'t need it).\n  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),\n      oldParent = this.parentNode,\n      oldSibling = this.nextSibling,\n      oldCSS = this.style.cssText,\n      bbox;\n\n  _docElement.appendChild(svg);\n\n  svg.appendChild(this);\n  this.style.display = "block";\n\n  if (swapIfPossible) {\n    try {\n      bbox = this.getBBox();\n      this._gsapBBox = this.getBBox; //store the original\n\n      this.getBBox = _getBBoxHack;\n    } catch (e) {}\n  } else if (this._gsapBBox) {\n    bbox = this._gsapBBox();\n  }\n\n  if (oldParent) {\n    if (oldSibling) {\n      oldParent.insertBefore(this, oldSibling);\n    } else {\n      oldParent.appendChild(this);\n    }\n  }\n\n  _docElement.removeChild(svg);\n\n  this.style.cssText = oldCSS;\n  return bbox;\n},\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n  var i = attributesArray.length;\n\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n},\n    _getBBox = function _getBBox(target) {\n  var bounds;\n\n  try {\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that\'s not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n  } catch (error) {\n    bounds = _getBBoxHack.call(target, true);\n  }\n\n  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it\'s at x:0, y:0), thus we need to manually grab the position in that case.\n\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,\n    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n},\n    _isSVG = function _isSVG(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n},\n    //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n  if (property) {\n    var style = target.style;\n\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n\n    if (style.removeProperty) {\n      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {\n        //Microsoft and some Webkit browsers don\'t conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it\'s correct (otherwise it\'d be "ms-transform" instead of "-ms-transform" for IE9, for example)\n        property = "-" + property;\n      }\n\n      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());\n    } else {\n      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"\n      style.removeAttribute(property);\n    }\n  }\n},\n    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n},\n    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0,\n      curUnit = (value + "").trim().substr((curValue + "").length) || "px",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n  style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === "svg",\n      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),\n      amount = 100,\n      toPixels = unit === "px",\n      toPercent = unit === "%",\n      px,\n      parent,\n      cache,\n      isSVG;\n\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n\n  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));\n  isSVG = target.getCTM && _isSVG(target);\n\n  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {\n    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];\n    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPercent ? curValue / px * amount : curValue / 100 * px);\n  }\n\n  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);\n  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n\n  if (!parent || parent === _doc || !parent.appendChild) {\n    parent = _doc.body;\n  }\n\n  cache = parent._gsap;\n\n  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time) {\n    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(curValue / cache.width * amount);\n  } else {\n    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));\n    parent === target && (style.position = "static"); // like for borderRadius, if it\'s a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it\'d go up the chain until it finds its offsetParent (bad). position: static protects against that.\n\n    parent.appendChild(_tempDiv);\n    px = _tempDiv[measureProperty];\n    parent.removeChild(_tempDiv);\n    style.position = "absolute";\n\n    if (horizontal && toPercent) {\n      cache = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(parent);\n      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time;\n      cache.width = parent[measureProperty];\n    }\n  }\n\n  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n},\n    _get = function _get(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n\n  if (property in _propertyAliases && property !== "transform") {\n    property = _propertyAliases[property];\n\n    if (~property.indexOf(",")) {\n      property = property.split(",")[0];\n    }\n  }\n\n  if (_transformProps[property] && property !== "transform") {\n    value = _parseTransform(target, uncache);\n    value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";\n  } else {\n    value = target.style[property];\n\n    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getProperty"])(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don\'t report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n    }\n  }\n\n  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;\n},\n    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n  if (!start || start === "none") {\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it\'s set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n    var p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === "borderColor") {\n      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n    }\n  }\n\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_renderComplexString"]),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      relative,\n      endValues;\n  pt.b = start;\n  pt.e = end;\n  start += ""; //ensure values are strings\n\n  end += "";\n\n  if (end === "auto") {\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    target.style[prop] = start;\n  }\n\n  a = [start, end];\n\n  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorStringFilter"])(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n\n\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];\n  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];\n\n  if (endValues.length) {\n    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {\n        color = 1;\n      }\n\n      if (endValue !== (startValue = startValues[matchIndex++] || "")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + "").length);\n        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n\n        if (relative) {\n          endValue = endValue.substr(2);\n        }\n\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + "").length);\n        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].lastIndex - endUnit.length;\n\n        if (!endUnit) {\n          //if something like "perspective:300" is passed in and we must add a unit to the end\n          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[prop] || startUnit;\n\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n\n        if (startUnit !== endUnit) {\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n        } //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n\n\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : ",",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: relative ? relative * endNum : endNum - startNum,\n          m: color && color < 4 || prop === "zIndex" ? Math.round : 0\n        };\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n  } else {\n    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_relExp"].test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.\n\n  return pt;\n},\n    _keywordToPercent = {\n  top: "0%",\n  bottom: "100%",\n  left: "0%",\n  right: "100%",\n  center: "50%"\n},\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n  var split = value.split(" "),\n      x = split[0],\n      y = split[1] || "50%";\n\n  if (x === "top" || x === "bottom" || y === "left" || y === "right") {\n    //the user provided them in the wrong order, so flip them\n    value = x;\n    x = y;\n    y = value;\n  }\n\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(" ");\n},\n    _renderClearProps = function _renderClearProps(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n\n    if (props === "all" || props === true) {\n      style.cssText = "";\n      clearTransforms = 1;\n    } else {\n      props = props.split(",");\n      i = props.length;\n\n      while (--i > -1) {\n        prop = props[i];\n\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;\n        }\n\n        _removeProperty(target, prop);\n      }\n    }\n\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n\n      if (cache) {\n        cache.svg && target.removeAttribute("transform");\n\n        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there\'s another tween that\'s already set to render transforms on this element, it could display the wrong values.\n\n\n        cache.uncache = 1;\n      }\n    }\n  }\n},\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== "isFromStart") {\n      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n\n      plugin._props.push(property);\n\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute("class", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== "cssText" && p !== "length") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute("class"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\\\s|^)" + endValue.substr(2) + "(?![\\\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");\n  \t}\n  \ttarget.setAttribute("class", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute("class", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== "0") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that\'s pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can\'t override properties we\'ve directly set on the target\'s style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\n    _rotationalProperties = {},\n    _isNullTransform = function _isNullTransform(value) {\n  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;\n},\n    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numExp"]).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"]);\n},\n    _getMatrix = function _getMatrix(target, force2D) {\n  var cache = target._gsap || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(target),\n      style = target.style,\n      matrix = _getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n\n  if (cache.svg && target.getAttribute("transform")) {\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.\n\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    //note: if offsetParent is null, that means the element isn\'t in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    //browsers don\'t report transforms accurately unless the element is in the DOM and has a display value that\'s not "none". Firefox and Microsoft browsers have a partial bug where they\'ll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it\'s translate(0, 8px).\n    temp = style.display;\n    style.display = "block";\n    parent = target.parentNode;\n\n    if (!parent || !target.offsetParent) {\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn\'t adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n      addedToDOM = 1; //flag\n\n      nextSibling = target.nextSibling;\n\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n\n    }\n\n    matrix = _getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, "display");\n\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n},\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap,\n      matrix = matrixArray || _getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(" "),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    //if it\'s zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y;\n  }\n\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we\'re baking the origin into the matrix() value).\n\n  if (pluginToAddPropTweensTo) {\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);\n  }\n\n  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);\n},\n    _parseTransform = function _parseTransform(target, uncache) {\n  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["GSCache"](target);\n\n  if ("x" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n\n  var style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = "px",\n      deg = "deg",\n      origin = _getComputedProperty(target, _transformOriginProp) || "0",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n  matrix = _getMatrix(target, cache.svg);\n\n  if (cache.svg) {\n    t1 = !cache.uncache && !uncache && target.getAttribute("data-svg-origin");\n\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0]; //a11\n\n    b = matrix[1]; //a21\n\n    c = matrix[2]; //a31\n\n    d = matrix[3]; //a41\n\n    x = a12 = matrix[4];\n    y = a22 = matrix[5]; //2D matrix\n\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn\'t exist).\n\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      } //3D matrix\n\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG; //rotationX\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      } //rotationY\n\n\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      } //rotationZ\n\n\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n\n      scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a * a + b * b + c * c));\n      scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n\n    if (cache.svg) {\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can\'t just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n      t1 = target.getAttribute("transform");\n      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute("transform", t1);\n    }\n  }\n\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n\n  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n  cache.z = z + px;\n  cache.scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleX);\n  cache.scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleY);\n  cache.rotation = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotation) + deg;\n  cache.rotationX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationX) + deg;\n  cache.rotationY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n\n  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].force3D;\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n},\n    _firstTwoOnly = function _firstTwoOnly(value) {\n  return (value = value.split(" "))[0] + " " + value[1];\n},\n    //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n  var unit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(start);\n  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;\n},\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n  cache.z = "0px";\n  cache.rotationY = cache.rotationX = "0deg";\n  cache.force3D = 0;\n\n  _renderCSSTransforms(ratio, cache);\n},\n    _zeroDeg = "0deg",\n    _zeroPx = "0px",\n    _endParenthesis = ") ",\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n  var _ref = cache || this,\n      xPercent = _ref.xPercent,\n      yPercent = _ref.yPercent,\n      x = _ref.x,\n      y = _ref.y,\n      z = _ref.z,\n      rotation = _ref.rotation,\n      rotationY = _ref.rotationY,\n      rotationX = _ref.rotationX,\n      skewX = _ref.skewX,\n      skewY = _ref.skewY,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      transformPerspective = _ref.transformPerspective,\n      force3D = _ref.force3D,\n      target = _ref.target,\n      zOrigin = _ref.zOrigin,\n      transforms = "",\n      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n\n\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n\n  if (transformPerspective !== _zeroPx) {\n    transforms += "perspective(" + transformPerspective + _endParenthesis;\n  }\n\n  if (xPercent || yPercent) {\n    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";\n  }\n\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;\n  }\n\n  if (rotation !== _zeroDeg) {\n    transforms += "rotate(" + rotation + _endParenthesis;\n  }\n\n  if (rotationY !== _zeroDeg) {\n    transforms += "rotateY(" + rotationY + _endParenthesis;\n  }\n\n  if (rotationX !== _zeroDeg) {\n    transforms += "rotateX(" + rotationX + _endParenthesis;\n  }\n\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;\n  }\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;\n  }\n\n  target.style[_transformProp] = transforms || "translate(0, 0)";\n},\n    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n  var _ref2 = cache || this,\n      xPercent = _ref2.xPercent,\n      yPercent = _ref2.yPercent,\n      x = _ref2.x,\n      y = _ref2.y,\n      rotation = _ref2.rotation,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      target = _ref2.target,\n      xOrigin = _ref2.xOrigin,\n      yOrigin = _ref2.yOrigin,\n      xOffset = _ref2.xOffset,\n      yOffset = _ref2.yOffset,\n      forceCSS = _ref2.forceCSS,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n\n  if (skewY) {\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n\n    a11 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a11);\n    a21 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a21);\n    a12 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a12);\n    a22 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n\n  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {\n    tx = _convertToUnit(target, "x", x, "px");\n    ty = _convertToUnit(target, "y", y, "px");\n  }\n\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n\n  if (xPercent || yPercent) {\n    //The SVG spec doesn\'t support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.\n    temp = target.getBBox();\n    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xPercent / 100 * temp.width);\n    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yPercent / 100 * temp.height);\n  }\n\n  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";\n  target.setAttribute("transform", temp);\n  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won\'t render the  transform attribute changes!)\n},\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {\n  var cap = 360,\n      isString = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isString"])(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),\n      change = relative ? endNum * relative : endNum - startNum,\n      finalValue = startNum + change + "deg",\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split("_")[1];\n\n    if (direction === "short") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === "cw" && change < 0) {\n      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n    } else if (direction === "ccw" && change > 0) {\n      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = "deg";\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _assign = function _assign(target, source) {\n  // Internet Explorer doesn\'t have Object.assign(), so we recreate it here.\n  for (var p in source) {\n    target[p] = source[p];\n  }\n\n  return target;\n},\n    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"\n  var startCache = _assign({}, target._gsap),\n      exclude = "perspective,force3D,transformOrigin,svgOrigin",\n      style = target.style,\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n\n  if (startCache.svg) {\n    startValue = target.getAttribute("transform");\n    target.setAttribute("transform", "");\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n\n    _removeProperty(target, _transformProp);\n\n    target.setAttribute("transform", startValue);\n  } else {\n    startValue = getComputedStyle(target)[_transformProp];\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    style[_transformProp] = startValue;\n  }\n\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n      startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);\n      endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n\n      plugin._props.push(p);\n    }\n  }\n\n  _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won\'t report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n\n\nObject(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("padding,margin,Width,Radius", function (name, index) {\n  var t = "Top",\n      r = "Right",\n      b = "Bottom",\n      l = "Left",\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\n    return index < 2 ? name + side : "border" + side + name;\n  });\n\n  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {\n    var a, vars;\n\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(function (prop) {\n        return _get(plugin, prop, property);\n      });\n      vars = a.join(" ");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n\n    a = (endValue + "").split(" ");\n    vars = {};\n    props.forEach(function (prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\n\nvar CSSPlugin = {\n  name: "css",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init(target, vars, tween, index, targets) {\n    var props = this._props,\n        style = target.style,\n        startAt = tween.vars.startAt,\n        startValue,\n        endValue,\n        endNum,\n        startNum,\n        type,\n        specialProp,\n        p,\n        startUnit,\n        endUnit,\n        relative,\n        isTransformRelated,\n        transformPropTween,\n        cache,\n        smooth,\n        hasPriority;\n    _pluginInitted || _initCore();\n\n    for (p in vars) {\n      if (p === "autoRound") {\n        continue;\n      }\n\n      endValue = vars[p];\n\n      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_plugins"][p] && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_checkPlugin"])(p, vars, tween, index, target, targets)) {\n        // plugins\n        continue;\n      }\n\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n\n      if (type === "function") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n\n      if (type === "string" && ~endValue.indexOf("random(")) {\n        endValue = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_replaceRandom"])(endValue);\n      }\n\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === "--") {\n        //CSS variable\n        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();\n        endValue += "";\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorExp"].lastIndex = 0;\n\n        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorExp"].test(startValue)) {\n          // colors don\'t have units\n          startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);\n          endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);\n        }\n\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);\n      } else if (type !== "undefined") {\n        if (startAt && p in startAt) {\n          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it\'d use the computed value (always in px)\n          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won\'t work.\n\n          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can\'t work with relative values\n        } else {\n          startValue = _get(target, p);\n        }\n\n        startNum = parseFloat(startValue);\n        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n\n        if (p in _propertyAliases) {\n          if (p === "autoAlpha") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {\n              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n\n            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);\n          }\n\n          if (p !== "scale" && p !== "transform") {\n            p = _propertyAliases[p];\n            ~p.indexOf(",") && (p = p.split(",")[0]);\n          }\n        }\n\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n\n        if (isTransformRelated) {\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn\'t parse the transform, thus cache.renderTransform won\'t be set yet so force the parsing of the transform here.\n\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n\n          if (p === "scale") {\n            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);\n            props.push("scaleY", p);\n            p += "X";\n          } else if (p === "transformOrigin") {\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.\n\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!\n\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);\n\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n\n            continue;\n          } else if (p === "svgOrigin") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);\n\n            continue;\n          } else if (p === "smoothOrigin") {\n            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);\n\n            continue;\n          } else if (p === "force3D") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === "transform") {\n            _addRawTransformPTs(this, endValue, target);\n\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + "").substr((startNum + "").length);\n          endNum || (endNum = 0); // protect against NaN\n\n          endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n\n          if (startUnit !== endUnit) {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it\'s not a style - it could be a property added directly to an element in which case we\'ll try to animate that.\n            this.add(target, p, target[p], endValue, index, targets);\n          } else {\n            Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_missingPlugin"])(p, endValue);\n\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, endValue);\n        }\n\n        props.push(p);\n      }\n    }\n\n    hasPriority && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_sortPropTweensByPriority"])(this);\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren\'t as simple as target.style.property = value because they\'ve got to be applied to a proxy object and then merged into a transform string in a renderer.\n    var p = _propertyAliases[property];\n    p && p.indexOf(",") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isUndefined"])(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getSetter"])(target, property);\n  },\n  core: {\n    _removeProperty: _removeProperty,\n    _getMatrix: _getMatrix\n  }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].utils.checkPrefix = _checkPropPrefix;\n\n(function (positionAndScale, rotation, others, aliases) {\n  var all = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(positionAndScale + "," + rotation + "," + others, function (name) {\n    _transformProps[name] = 1;\n  });\n\n  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(rotation, function (name) {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "deg";\n    _rotationalProperties[name] = 1;\n  });\n\n  _propertyAliases[all[13]] = positionAndScale + "," + rotation;\n\n  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(aliases, function (name) {\n    var split = name.split(":");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");\n\nObject(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "px";\n});\n\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(CSSPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzPzIzZmMiXSwibmFtZXMiOlsiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9wbHVnaW5Jbml0dGVkIiwiX3RlbXBEaXYiLCJfdGVtcERpdlN0eWxlciIsIl9yZWNlbnRTZXR0ZXJQbHVnaW4iLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX3RyYW5zZm9ybVByb3BzIiwiX1JBRDJERUciLCJNYXRoIiwiUEkiLCJfREVHMlJBRCIsIl9hdGFuMiIsImF0YW4yIiwiX2JpZ051bSIsIl9jYXBzRXhwIiwiX2hvcml6b250YWxFeHAiLCJfY29tcGxleEV4cCIsIl9wcm9wZXJ0eUFsaWFzZXMiLCJhdXRvQWxwaGEiLCJzY2FsZSIsImFscGhhIiwiX3JlbmRlckNTU1Byb3AiLCJyYXRpbyIsImRhdGEiLCJzZXQiLCJ0IiwicCIsInJvdW5kIiwicyIsImMiLCJ1IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsIl9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyIsImIiLCJfcmVuZGVyUm91bmRlZENTU1Byb3AiLCJ2YWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQiLCJfc2V0dGVyQ1NTU3R5bGUiLCJ0YXJnZXQiLCJwcm9wZXJ0eSIsInN0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfZ3NhcCIsIl9zZXR0ZXJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIl9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIiLCJjYWNoZSIsInJlbmRlclRyYW5zZm9ybSIsIl9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9zdXBwb3J0czNEIiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJjcmVhdGVFbGVtZW50TlMiLCJyZXBsYWNlIiwiY3JlYXRlRWxlbWVudCIsIl9nZXRDb21wdXRlZFByb3BlcnR5Iiwic2tpcFByZWZpeEZhbGxiYWNrIiwiY3MiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRvTG93ZXJDYXNlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsInNwbGl0IiwiZWxlbWVudCIsInByZWZlclByZWZpeCIsImkiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY3NzVGV4dCIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwic3ZnIiwib3duZXJTVkdFbGVtZW50IiwiZ2V0QXR0cmlidXRlIiwib2xkUGFyZW50IiwicGFyZW50Tm9kZSIsIm9sZFNpYmxpbmciLCJuZXh0U2libGluZyIsIm9sZENTUyIsImJib3giLCJhcHBlbmRDaGlsZCIsImRpc3BsYXkiLCJnZXRCQm94IiwiX2dzYXBCQm94IiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJfZ2V0QXR0cmlidXRlRmFsbGJhY2tzIiwiYXR0cmlidXRlc0FycmF5IiwibGVuZ3RoIiwiaGFzQXR0cmlidXRlIiwiX2dldEJCb3giLCJib3VuZHMiLCJlcnJvciIsImNhbGwiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwiX2lzU1ZHIiwiZ2V0Q1RNIiwiX3JlbW92ZVByb3BlcnR5IiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfYWRkTm9uVHdlZW5pbmdQVCIsInBsdWdpbiIsImJlZ2lubmluZyIsImVuZCIsIm9ubHlTZXRBdEVuZCIsInB0IiwiUHJvcFR3ZWVuIiwiX3B0IiwiX3Byb3BzIiwicHVzaCIsIl9ub25Db252ZXJ0aWJsZVVuaXRzIiwiZGVnIiwicmFkIiwidHVybiIsIl9jb252ZXJ0VG9Vbml0IiwidW5pdCIsImN1clZhbHVlIiwicGFyc2VGbG9hdCIsImN1clVuaXQiLCJ0cmltIiwiaG9yaXpvbnRhbCIsInRlc3QiLCJpc1Jvb3RTVkciLCJ0YWdOYW1lIiwibWVhc3VyZVByb3BlcnR5IiwiYW1vdW50IiwidG9QaXhlbHMiLCJ0b1BlcmNlbnQiLCJweCIsInBhcmVudCIsImlzU1ZHIiwiaW5kZXhPZiIsIl9yb3VuZCIsImJvZHkiLCJ0aW1lIiwiX3RpY2tlciIsInBvc2l0aW9uIiwiX2dldENhY2hlIiwiX2dldCIsInVuY2FjaGUiLCJfcGFyc2VUcmFuc2Zvcm0iLCJfZmlyc3RUd29Pbmx5Iiwiek9yaWdpbiIsIl9zcGVjaWFsUHJvcHMiLCJfZ2V0UHJvcGVydHkiLCJfdHdlZW5Db21wbGV4Q1NTU3RyaW5nIiwicHJvcCIsInN0YXJ0IiwiX3JlbmRlckNvbXBsZXhTdHJpbmciLCJpbmRleCIsIm1hdGNoSW5kZXgiLCJhIiwicmVzdWx0Iiwic3RhcnRWYWx1ZXMiLCJzdGFydE51bSIsImNvbG9yIiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiZW5kTnVtIiwiY2h1bmsiLCJlbmRVbml0Iiwic3RhcnRVbml0IiwicmVsYXRpdmUiLCJlbmRWYWx1ZXMiLCJfY29sb3JTdHJpbmdGaWx0ZXIiLCJtYXRjaCIsIl9udW1XaXRoVW5pdEV4cCIsImV4ZWMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXgiLCJfY29uZmlnIiwidW5pdHMiLCJfbmV4dCIsIm0iLCJyIiwiX3JlbEV4cCIsIl9rZXl3b3JkVG9QZXJjZW50IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiY2VudGVyIiwiX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMiLCJqb2luIiwiX3JlbmRlckNsZWFyUHJvcHMiLCJ0d2VlbiIsIl90aW1lIiwiX2R1ciIsInByb3BzIiwiY2xlYXJUcmFuc2Zvcm1zIiwiY2xlYXJQcm9wcyIsInByIiwiX2lkZW50aXR5MkRNYXRyaXgiLCJfcm90YXRpb25hbFByb3BlcnRpZXMiLCJfaXNOdWxsVHJhbnNmb3JtIiwiX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSIsIm1hdHJpeFN0cmluZyIsIl9udW1FeHAiLCJtYXAiLCJfZ2V0TWF0cml4IiwiZm9yY2UyRCIsIm1hdHJpeCIsInRlbXAiLCJhZGRlZFRvRE9NIiwidHJhbnNmb3JtIiwiYmFzZVZhbCIsImNvbnNvbGlkYXRlIiwiZCIsImYiLCJvZmZzZXRQYXJlbnQiLCJfYXBwbHlTVkdPcmlnaW4iLCJvcmlnaW4iLCJvcmlnaW5Jc0Fic29sdXRlIiwic21vb3RoIiwibWF0cml4QXJyYXkiLCJwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbyIsInhPcmlnaW5PbGQiLCJ4T3JpZ2luIiwieU9yaWdpbk9sZCIsInlPcmlnaW4iLCJ4T2Zmc2V0T2xkIiwieE9mZnNldCIsInlPZmZzZXRPbGQiLCJ5T2Zmc2V0IiwidHgiLCJ0eSIsIm9yaWdpblNwbGl0IiwiZGV0ZXJtaW5hbnQiLCJzZXRBdHRyaWJ1dGUiLCJHU0NhY2hlIiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJza2V3WCIsInNrZXdZIiwicGVyc3BlY3RpdmUiLCJhbmdsZSIsImNvcyIsInNpbiIsImExMiIsImEyMiIsInQxIiwidDIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsInNxcnQiLCJhYnMiLCJmb3JjZUNTUyIsInhQZXJjZW50Iiwib2Zmc2V0V2lkdGgiLCJ5UGVyY2VudCIsIm9mZnNldEhlaWdodCIsInRyYW5zZm9ybVBlcnNwZWN0aXZlIiwiZm9yY2UzRCIsIl9yZW5kZXJTVkdUcmFuc2Zvcm1zIiwiX3JlbmRlckNTU1RyYW5zZm9ybXMiLCJfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zIiwiX2FkZFB4VHJhbnNsYXRlIiwiZ2V0VW5pdCIsIl96ZXJvRGVnIiwiX3plcm9QeCIsIl9lbmRQYXJlbnRoZXNpcyIsIl9yZWYiLCJ0cmFuc2Zvcm1zIiwidXNlM0QiLCJfcmVmMiIsImExMSIsImEyMSIsInRhbiIsIl9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuIiwiY2FwIiwiaXNTdHJpbmciLCJfaXNTdHJpbmciLCJjaGFuZ2UiLCJmaW5hbFZhbHVlIiwiZGlyZWN0aW9uIiwiX2Fzc2lnbiIsInNvdXJjZSIsIl9hZGRSYXdUcmFuc2Zvcm1QVHMiLCJzdGFydENhY2hlIiwiZXhjbHVkZSIsImVuZENhY2hlIiwiX2ZvckVhY2hOYW1lIiwibmFtZSIsImwiLCJzaWRlIiwidmFycyIsImFyZ3VtZW50cyIsImZvckVhY2giLCJpbml0IiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0Iiwibm9kZVR5cGUiLCJ0YXJnZXRzIiwic3RhcnRBdCIsInNwZWNpYWxQcm9wIiwiaXNUcmFuc2Zvcm1SZWxhdGVkIiwidHJhbnNmb3JtUHJvcFR3ZWVuIiwiaGFzUHJpb3JpdHkiLCJfcGx1Z2lucyIsIl9jaGVja1BsdWdpbiIsIl9yZXBsYWNlUmFuZG9tIiwiX2NvbG9yRXhwIiwiYWRkIiwicGFyc2VUcmFuc2Zvcm0iLCJzbW9vdGhPcmlnaW4iLCJkZXAiLCJhdXRvUm91bmQiLCJfbWlzc2luZ1BsdWdpbiIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJnZXQiLCJhbGlhc2VzIiwiZ2V0U2V0dGVyIiwiX2lzVW5kZWZpbmVkIiwiX2dldFNldHRlciIsImNvcmUiLCJnc2FwIiwidXRpbHMiLCJjaGVja1ByZWZpeCIsInBvc2l0aW9uQW5kU2NhbGUiLCJvdGhlcnMiLCJhbGwiLCJyZWdpc3RlclBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7O0FBR0EsSUFBSUEsSUFBSjtBQUFBLElBQ0lDLElBREo7QUFBQSxJQUVJQyxXQUZKO0FBQUEsSUFHSUMsY0FISjtBQUFBLElBSUlDLFFBSko7QUFBQSxJQUtJQyxjQUxKO0FBQUEsSUFNSUMsbUJBTko7QUFBQSxJQU9JQyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxHQUF5QjtBQUMzQyxTQUFPLE9BQU9DLE1BQVAsS0FBa0IsV0FBekI7QUFDRCxDQVREO0FBQUEsSUFVSUMsZUFBZSxHQUFHLEVBVnRCO0FBQUEsSUFXSUMsUUFBUSxHQUFHLE1BQU1DLElBQUksQ0FBQ0MsRUFYMUI7QUFBQSxJQVlJQyxRQUFRLEdBQUdGLElBQUksQ0FBQ0MsRUFBTCxHQUFVLEdBWnpCO0FBQUEsSUFhSUUsTUFBTSxHQUFHSCxJQUFJLENBQUNJLEtBYmxCO0FBQUEsSUFjSUMsT0FBTyxHQUFHLEdBZGQ7QUFBQSxJQWVJQyxRQUFRLEdBQUcsVUFmZjtBQUFBLElBZ0JJQyxjQUFjLEdBQUcsd0NBaEJyQjtBQUFBLElBaUJJQyxXQUFXLEdBQUcsV0FqQmxCO0FBQUEsSUFrQklDLGdCQUFnQixHQUFHO0FBQ3JCQyxXQUFTLEVBQUUsb0JBRFU7QUFFckJDLE9BQUssRUFBRSxlQUZjO0FBR3JCQyxPQUFLLEVBQUU7QUFIYyxDQWxCdkI7QUFBQSxJQXVCSUMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0JDLEtBQXhCLEVBQStCQyxJQUEvQixFQUFxQztBQUN4RCxTQUFPQSxJQUFJLENBQUNDLEdBQUwsQ0FBU0QsSUFBSSxDQUFDRSxDQUFkLEVBQWlCRixJQUFJLENBQUNHLENBQXRCLEVBQXlCbEIsSUFBSSxDQUFDbUIsS0FBTCxDQUFXLENBQUNKLElBQUksQ0FBQ0ssQ0FBTCxHQUFTTCxJQUFJLENBQUNNLENBQUwsR0FBU1AsS0FBbkIsSUFBNEIsS0FBdkMsSUFBZ0QsS0FBaEQsR0FBd0RDLElBQUksQ0FBQ08sQ0FBdEYsRUFBeUZQLElBQXpGLENBQVA7QUFDRCxDQXpCRDtBQUFBLElBMEJJUSxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QlQsS0FBNUIsRUFBbUNDLElBQW5DLEVBQXlDO0FBQ2hFLFNBQU9BLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUNFLENBQWQsRUFBaUJGLElBQUksQ0FBQ0csQ0FBdEIsRUFBeUJKLEtBQUssS0FBSyxDQUFWLEdBQWNDLElBQUksQ0FBQ1MsQ0FBbkIsR0FBdUJ4QixJQUFJLENBQUNtQixLQUFMLENBQVcsQ0FBQ0osSUFBSSxDQUFDSyxDQUFMLEdBQVNMLElBQUksQ0FBQ00sQ0FBTCxHQUFTUCxLQUFuQixJQUE0QixLQUF2QyxJQUFnRCxLQUFoRCxHQUF3REMsSUFBSSxDQUFDTyxDQUE3RyxFQUFnSFAsSUFBaEgsQ0FBUDtBQUNELENBNUJEO0FBQUEsSUE2QklVLDJCQUEyQixHQUFHLFNBQVNBLDJCQUFULENBQXFDWCxLQUFyQyxFQUE0Q0MsSUFBNUMsRUFBa0Q7QUFDbEYsU0FBT0EsSUFBSSxDQUFDQyxHQUFMLENBQVNELElBQUksQ0FBQ0UsQ0FBZCxFQUFpQkYsSUFBSSxDQUFDRyxDQUF0QixFQUF5QkosS0FBSyxHQUFHZCxJQUFJLENBQUNtQixLQUFMLENBQVcsQ0FBQ0osSUFBSSxDQUFDSyxDQUFMLEdBQVNMLElBQUksQ0FBQ00sQ0FBTCxHQUFTUCxLQUFuQixJQUE0QixLQUF2QyxJQUFnRCxLQUFoRCxHQUF3REMsSUFBSSxDQUFDTyxDQUFoRSxHQUFvRVAsSUFBSSxDQUFDVyxDQUF2RyxFQUEwR1gsSUFBMUcsQ0FBUDtBQUNELENBL0JEO0FBQUEsSUFnQ0k7QUFDSlkscUJBQXFCLEdBQUcsU0FBU0EscUJBQVQsQ0FBK0JiLEtBQS9CLEVBQXNDQyxJQUF0QyxFQUE0QztBQUNsRSxNQUFJYSxLQUFLLEdBQUdiLElBQUksQ0FBQ0ssQ0FBTCxHQUFTTCxJQUFJLENBQUNNLENBQUwsR0FBU1AsS0FBOUI7QUFDQUMsTUFBSSxDQUFDQyxHQUFMLENBQVNELElBQUksQ0FBQ0UsQ0FBZCxFQUFpQkYsSUFBSSxDQUFDRyxDQUF0QixFQUF5QixDQUFDLEVBQUVVLEtBQUssSUFBSUEsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUFDLEVBQWIsR0FBa0IsRUFBdEIsQ0FBUCxDQUFELEdBQXFDYixJQUFJLENBQUNPLENBQW5FLEVBQXNFUCxJQUF0RTtBQUNELENBcENEO0FBQUEsSUFxQ0ljLHVCQUF1QixHQUFHLFNBQVNBLHVCQUFULENBQWlDZixLQUFqQyxFQUF3Q0MsSUFBeEMsRUFBOEM7QUFDMUUsU0FBT0EsSUFBSSxDQUFDQyxHQUFMLENBQVNELElBQUksQ0FBQ0UsQ0FBZCxFQUFpQkYsSUFBSSxDQUFDRyxDQUF0QixFQUF5QkosS0FBSyxHQUFHQyxJQUFJLENBQUNTLENBQVIsR0FBWVQsSUFBSSxDQUFDVyxDQUEvQyxFQUFrRFgsSUFBbEQsQ0FBUDtBQUNELENBdkNEO0FBQUEsSUF3Q0llLGdDQUFnQyxHQUFHLFNBQVNBLGdDQUFULENBQTBDaEIsS0FBMUMsRUFBaURDLElBQWpELEVBQXVEO0FBQzVGLFNBQU9BLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUNFLENBQWQsRUFBaUJGLElBQUksQ0FBQ0csQ0FBdEIsRUFBeUJKLEtBQUssS0FBSyxDQUFWLEdBQWNDLElBQUksQ0FBQ1csQ0FBbkIsR0FBdUJYLElBQUksQ0FBQ1MsQ0FBckQsRUFBd0RULElBQXhELENBQVA7QUFDRCxDQTFDRDtBQUFBLElBMkNJZ0IsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDQyxRQUFqQyxFQUEyQ0wsS0FBM0MsRUFBa0Q7QUFDdEUsU0FBT0ksTUFBTSxDQUFDRSxLQUFQLENBQWFELFFBQWIsSUFBeUJMLEtBQWhDO0FBQ0QsQ0E3Q0Q7QUFBQSxJQThDSU8sY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0JILE1BQXhCLEVBQWdDQyxRQUFoQyxFQUEwQ0wsS0FBMUMsRUFBaUQ7QUFDcEUsU0FBT0ksTUFBTSxDQUFDRSxLQUFQLENBQWFFLFdBQWIsQ0FBeUJILFFBQXpCLEVBQW1DTCxLQUFuQyxDQUFQO0FBQ0QsQ0FoREQ7QUFBQSxJQWlESVMsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEJMLE1BQTFCLEVBQWtDQyxRQUFsQyxFQUE0Q0wsS0FBNUMsRUFBbUQ7QUFDeEUsU0FBT0ksTUFBTSxDQUFDTSxLQUFQLENBQWFMLFFBQWIsSUFBeUJMLEtBQWhDO0FBQ0QsQ0FuREQ7QUFBQSxJQW9ESVcsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JQLE1BQXRCLEVBQThCQyxRQUE5QixFQUF3Q0wsS0FBeEMsRUFBK0M7QUFDaEUsU0FBT0ksTUFBTSxDQUFDTSxLQUFQLENBQWFFLE1BQWIsR0FBc0JSLE1BQU0sQ0FBQ00sS0FBUCxDQUFhRyxNQUFiLEdBQXNCYixLQUFuRDtBQUNELENBdEREO0FBQUEsSUF1REljLHNCQUFzQixHQUFHLFNBQVNBLHNCQUFULENBQWdDVixNQUFoQyxFQUF3Q0MsUUFBeEMsRUFBa0RMLEtBQWxELEVBQXlEYixJQUF6RCxFQUErREQsS0FBL0QsRUFBc0U7QUFDakcsTUFBSTZCLEtBQUssR0FBR1gsTUFBTSxDQUFDTSxLQUFuQjtBQUNBSyxPQUFLLENBQUNILE1BQU4sR0FBZUcsS0FBSyxDQUFDRixNQUFOLEdBQWViLEtBQTlCO0FBQ0FlLE9BQUssQ0FBQ0MsZUFBTixDQUFzQjlCLEtBQXRCLEVBQTZCNkIsS0FBN0I7QUFDRCxDQTNERDtBQUFBLElBNERJRSwwQkFBMEIsR0FBRyxTQUFTQSwwQkFBVCxDQUFvQ2IsTUFBcEMsRUFBNENDLFFBQTVDLEVBQXNETCxLQUF0RCxFQUE2RGIsSUFBN0QsRUFBbUVELEtBQW5FLEVBQTBFO0FBQ3pHLE1BQUk2QixLQUFLLEdBQUdYLE1BQU0sQ0FBQ00sS0FBbkI7QUFDQUssT0FBSyxDQUFDVixRQUFELENBQUwsR0FBa0JMLEtBQWxCO0FBQ0FlLE9BQUssQ0FBQ0MsZUFBTixDQUFzQjlCLEtBQXRCLEVBQTZCNkIsS0FBN0I7QUFDRCxDQWhFRDtBQUFBLElBaUVJRyxjQUFjLEdBQUcsV0FqRXJCO0FBQUEsSUFrRUlDLG9CQUFvQixHQUFHRCxjQUFjLEdBQUcsUUFsRTVDO0FBQUEsSUFtRUlFLFdBbkVKO0FBQUEsSUFvRUlDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCQyxJQUF4QixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDckQsTUFBSTNCLENBQUMsR0FBR2xDLElBQUksQ0FBQzhELGVBQUwsR0FBdUI5RCxJQUFJLENBQUM4RCxlQUFMLENBQXFCLENBQUNELEVBQUUsSUFBSSw4QkFBUCxFQUF1Q0UsT0FBdkMsQ0FBK0MsUUFBL0MsRUFBeUQsTUFBekQsQ0FBckIsRUFBdUZILElBQXZGLENBQXZCLEdBQXNINUQsSUFBSSxDQUFDZ0UsYUFBTCxDQUFtQkosSUFBbkIsQ0FBOUgsQ0FEcUQsQ0FDbUc7O0FBRXhKLFNBQU8xQixDQUFDLENBQUNVLEtBQUYsR0FBVVYsQ0FBVixHQUFjbEMsSUFBSSxDQUFDZ0UsYUFBTCxDQUFtQkosSUFBbkIsQ0FBckIsQ0FIcUQsQ0FHTjtBQUNoRCxDQXhFRDtBQUFBLElBeUVJSyxvQkFBb0IsR0FBRyxTQUFTQSxvQkFBVCxDQUE4QnZCLE1BQTlCLEVBQXNDQyxRQUF0QyxFQUFnRHVCLGtCQUFoRCxFQUFvRTtBQUM3RixNQUFJQyxFQUFFLEdBQUdDLGdCQUFnQixDQUFDMUIsTUFBRCxDQUF6QjtBQUNBLFNBQU95QixFQUFFLENBQUN4QixRQUFELENBQUYsSUFBZ0J3QixFQUFFLENBQUNFLGdCQUFILENBQW9CMUIsUUFBUSxDQUFDb0IsT0FBVCxDQUFpQi9DLFFBQWpCLEVBQTJCLEtBQTNCLEVBQWtDc0QsV0FBbEMsRUFBcEIsQ0FBaEIsSUFBd0ZILEVBQUUsQ0FBQ0UsZ0JBQUgsQ0FBb0IxQixRQUFwQixDQUF4RixJQUF5SCxDQUFDdUIsa0JBQUQsSUFBdUJELG9CQUFvQixDQUFDdkIsTUFBRCxFQUFTNkIsZ0JBQWdCLENBQUM1QixRQUFELENBQWhCLElBQThCQSxRQUF2QyxFQUFpRCxDQUFqRCxDQUFwSyxJQUEyTixFQUFsTyxDQUY2RixDQUV5STtBQUN2TyxDQTVFRDtBQUFBLElBNkVJNkIsU0FBUyxHQUFHLHFCQUFxQkMsS0FBckIsQ0FBMkIsR0FBM0IsQ0E3RWhCO0FBQUEsSUE4RUlGLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCNUIsUUFBMUIsRUFBb0MrQixPQUFwQyxFQUE2Q0MsWUFBN0MsRUFBMkQ7QUFDaEYsTUFBSXpDLENBQUMsR0FBR3dDLE9BQU8sSUFBSXZFLFFBQW5CO0FBQUEsTUFDSTJCLENBQUMsR0FBR0ksQ0FBQyxDQUFDVSxLQURWO0FBQUEsTUFFSWdDLENBQUMsR0FBRyxDQUZSOztBQUlBLE1BQUlqQyxRQUFRLElBQUliLENBQVosSUFBaUIsQ0FBQzZDLFlBQXRCLEVBQW9DO0FBQ2xDLFdBQU9oQyxRQUFQO0FBQ0Q7O0FBRURBLFVBQVEsR0FBR0EsUUFBUSxDQUFDa0MsTUFBVCxDQUFnQixDQUFoQixFQUFtQkMsV0FBbkIsS0FBbUNuQyxRQUFRLENBQUNvQyxNQUFULENBQWdCLENBQWhCLENBQTlDOztBQUVBLFNBQU9ILENBQUMsTUFBTSxFQUFFSixTQUFTLENBQUNJLENBQUQsQ0FBVCxHQUFlakMsUUFBZixJQUEyQmIsQ0FBN0IsQ0FBZCxFQUErQyxDQUFFOztBQUVqRCxTQUFPOEMsQ0FBQyxHQUFHLENBQUosR0FBUSxJQUFSLEdBQWUsQ0FBQ0EsQ0FBQyxLQUFLLENBQU4sR0FBVSxJQUFWLEdBQWlCQSxDQUFDLElBQUksQ0FBTCxHQUFTSixTQUFTLENBQUNJLENBQUQsQ0FBbEIsR0FBd0IsRUFBMUMsSUFBZ0RqQyxRQUF0RTtBQUNELENBNUZEO0FBQUEsSUE2RklxQyxTQUFTLEdBQUcsU0FBU0EsU0FBVCxHQUFxQjtBQUNuQyxNQUFJMUUsYUFBYSxNQUFNQyxNQUFNLENBQUMwRSxRQUE5QixFQUF3QztBQUN0Q2xGLFFBQUksR0FBR1EsTUFBUDtBQUNBUCxRQUFJLEdBQUdELElBQUksQ0FBQ2tGLFFBQVo7QUFDQWhGLGVBQVcsR0FBR0QsSUFBSSxDQUFDa0YsZUFBbkI7QUFDQS9FLFlBQVEsR0FBR3dELGNBQWMsQ0FBQyxLQUFELENBQWQsSUFBeUI7QUFDbENmLFdBQUssRUFBRTtBQUQyQixLQUFwQztBQUdBeEMsa0JBQWMsR0FBR3VELGNBQWMsQ0FBQyxLQUFELENBQS9CO0FBQ0FILGtCQUFjLEdBQUdlLGdCQUFnQixDQUFDZixjQUFELENBQWpDO0FBQ0FDLHdCQUFvQixHQUFHRCxjQUFjLEdBQUcsUUFBeEM7QUFDQXJELFlBQVEsQ0FBQ3lDLEtBQVQsQ0FBZXVDLE9BQWYsR0FBeUIsMERBQXpCLENBVnNDLENBVStDOztBQUVyRnpCLGVBQVcsR0FBRyxDQUFDLENBQUNhLGdCQUFnQixDQUFDLGFBQUQsQ0FBaEM7QUFDQXJFLGtCQUFjLEdBQUcsQ0FBakI7QUFDRDtBQUNGLENBN0dEO0FBQUEsSUE4R0lrRixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQkMsY0FBdEIsRUFBc0M7QUFDdkQ7QUFDQSxNQUFJQyxHQUFHLEdBQUczQixjQUFjLENBQUMsS0FBRCxFQUFRLEtBQUs0QixlQUFMLElBQXdCLEtBQUtBLGVBQUwsQ0FBcUJDLFlBQXJCLENBQWtDLE9BQWxDLENBQXhCLElBQXNFLDRCQUE5RSxDQUF4QjtBQUFBLE1BQ0lDLFNBQVMsR0FBRyxLQUFLQyxVQURyQjtBQUFBLE1BRUlDLFVBQVUsR0FBRyxLQUFLQyxXQUZ0QjtBQUFBLE1BR0lDLE1BQU0sR0FBRyxLQUFLakQsS0FBTCxDQUFXdUMsT0FIeEI7QUFBQSxNQUlJVyxJQUpKOztBQU1BN0YsYUFBVyxDQUFDOEYsV0FBWixDQUF3QlQsR0FBeEI7O0FBRUFBLEtBQUcsQ0FBQ1MsV0FBSixDQUFnQixJQUFoQjtBQUNBLE9BQUtuRCxLQUFMLENBQVdvRCxPQUFYLEdBQXFCLE9BQXJCOztBQUVBLE1BQUlYLGNBQUosRUFBb0I7QUFDbEIsUUFBSTtBQUNGUyxVQUFJLEdBQUcsS0FBS0csT0FBTCxFQUFQO0FBQ0EsV0FBS0MsU0FBTCxHQUFpQixLQUFLRCxPQUF0QixDQUZFLENBRTZCOztBQUUvQixXQUFLQSxPQUFMLEdBQWViLFlBQWY7QUFDRCxLQUxELENBS0UsT0FBT2xELENBQVAsRUFBVSxDQUFFO0FBQ2YsR0FQRCxNQU9PLElBQUksS0FBS2dFLFNBQVQsRUFBb0I7QUFDekJKLFFBQUksR0FBRyxLQUFLSSxTQUFMLEVBQVA7QUFDRDs7QUFFRCxNQUFJVCxTQUFKLEVBQWU7QUFDYixRQUFJRSxVQUFKLEVBQWdCO0FBQ2RGLGVBQVMsQ0FBQ1UsWUFBVixDQUF1QixJQUF2QixFQUE2QlIsVUFBN0I7QUFDRCxLQUZELE1BRU87QUFDTEYsZUFBUyxDQUFDTSxXQUFWLENBQXNCLElBQXRCO0FBQ0Q7QUFDRjs7QUFFRDlGLGFBQVcsQ0FBQ21HLFdBQVosQ0FBd0JkLEdBQXhCOztBQUVBLE9BQUsxQyxLQUFMLENBQVd1QyxPQUFYLEdBQXFCVSxNQUFyQjtBQUNBLFNBQU9DLElBQVA7QUFDRCxDQWxKRDtBQUFBLElBbUpJTyxzQkFBc0IsR0FBRyxTQUFTQSxzQkFBVCxDQUFnQzNELE1BQWhDLEVBQXdDNEQsZUFBeEMsRUFBeUQ7QUFDcEYsTUFBSTFCLENBQUMsR0FBRzBCLGVBQWUsQ0FBQ0MsTUFBeEI7O0FBRUEsU0FBTzNCLENBQUMsRUFBUixFQUFZO0FBQ1YsUUFBSWxDLE1BQU0sQ0FBQzhELFlBQVAsQ0FBb0JGLGVBQWUsQ0FBQzFCLENBQUQsQ0FBbkMsQ0FBSixFQUE2QztBQUMzQyxhQUFPbEMsTUFBTSxDQUFDOEMsWUFBUCxDQUFvQmMsZUFBZSxDQUFDMUIsQ0FBRCxDQUFuQyxDQUFQO0FBQ0Q7QUFDRjtBQUNGLENBM0pEO0FBQUEsSUE0Skk2QixRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQi9ELE1BQWxCLEVBQTBCO0FBQ3ZDLE1BQUlnRSxNQUFKOztBQUVBLE1BQUk7QUFDRkEsVUFBTSxHQUFHaEUsTUFBTSxDQUFDdUQsT0FBUCxFQUFULENBREUsQ0FDeUI7QUFDNUIsR0FGRCxDQUVFLE9BQU9VLEtBQVAsRUFBYztBQUNkRCxVQUFNLEdBQUd0QixZQUFZLENBQUN3QixJQUFiLENBQWtCbEUsTUFBbEIsRUFBMEIsSUFBMUIsQ0FBVDtBQUNEOztBQUVEZ0UsUUFBTSxLQUFLQSxNQUFNLENBQUNHLEtBQVAsSUFBZ0JILE1BQU0sQ0FBQ0ksTUFBNUIsQ0FBTixJQUE2Q3BFLE1BQU0sQ0FBQ3VELE9BQVAsS0FBbUJiLFlBQWhFLEtBQWlGc0IsTUFBTSxHQUFHdEIsWUFBWSxDQUFDd0IsSUFBYixDQUFrQmxFLE1BQWxCLEVBQTBCLElBQTFCLENBQTFGLEVBVHVDLENBU3FGOztBQUU1SCxTQUFPZ0UsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQ0csS0FBbEIsSUFBMkIsQ0FBQ0gsTUFBTSxDQUFDSyxDQUFuQyxJQUF3QyxDQUFDTCxNQUFNLENBQUNNLENBQWhELEdBQW9EO0FBQ3pERCxLQUFDLEVBQUUsQ0FBQ1Ysc0JBQXNCLENBQUMzRCxNQUFELEVBQVMsQ0FBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosQ0FBVCxDQUF2QixJQUFzRCxDQURBO0FBRXpEc0UsS0FBQyxFQUFFLENBQUNYLHNCQUFzQixDQUFDM0QsTUFBRCxFQUFTLENBQUMsR0FBRCxFQUFNLElBQU4sRUFBWSxJQUFaLENBQVQsQ0FBdkIsSUFBc0QsQ0FGQTtBQUd6RG1FLFNBQUssRUFBRSxDQUhrRDtBQUl6REMsVUFBTSxFQUFFO0FBSmlELEdBQXBELEdBS0hKLE1BTEo7QUFNRCxDQTdLRDtBQUFBLElBOEtJTyxNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQi9FLENBQWhCLEVBQW1CO0FBQzlCLFNBQU8sQ0FBQyxFQUFFQSxDQUFDLENBQUNnRixNQUFGLEtBQWEsQ0FBQ2hGLENBQUMsQ0FBQ3dELFVBQUgsSUFBaUJ4RCxDQUFDLENBQUNxRCxlQUFoQyxLQUFvRGtCLFFBQVEsQ0FBQ3ZFLENBQUQsQ0FBOUQsQ0FBUjtBQUNELENBaExEO0FBQUEsSUFpTEk7QUFDSmlGLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCekUsTUFBekIsRUFBaUNDLFFBQWpDLEVBQTJDO0FBQzNELE1BQUlBLFFBQUosRUFBYztBQUNaLFFBQUlDLEtBQUssR0FBR0YsTUFBTSxDQUFDRSxLQUFuQjs7QUFFQSxRQUFJRCxRQUFRLElBQUluQyxlQUFaLElBQStCbUMsUUFBUSxLQUFLYyxvQkFBaEQsRUFBc0U7QUFDcEVkLGNBQVEsR0FBR2EsY0FBWDtBQUNEOztBQUVELFFBQUlaLEtBQUssQ0FBQ3dFLGNBQVYsRUFBMEI7QUFDeEIsVUFBSXpFLFFBQVEsQ0FBQ29DLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsTUFBMEIsSUFBMUIsSUFBa0NwQyxRQUFRLENBQUNvQyxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLE1BQTBCLFFBQWhFLEVBQTBFO0FBQ3hFO0FBQ0FwQyxnQkFBUSxHQUFHLE1BQU1BLFFBQWpCO0FBQ0Q7O0FBRURDLFdBQUssQ0FBQ3dFLGNBQU4sQ0FBcUJ6RSxRQUFRLENBQUNvQixPQUFULENBQWlCL0MsUUFBakIsRUFBMkIsS0FBM0IsRUFBa0NzRCxXQUFsQyxFQUFyQjtBQUNELEtBUEQsTUFPTztBQUNMO0FBQ0ExQixXQUFLLENBQUN5RSxlQUFOLENBQXNCMUUsUUFBdEI7QUFDRDtBQUNGO0FBQ0YsQ0F0TUQ7QUFBQSxJQXVNSTJFLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCQyxNQUEzQixFQUFtQzdFLE1BQW5DLEVBQTJDQyxRQUEzQyxFQUFxRDZFLFNBQXJELEVBQWdFQyxHQUFoRSxFQUFxRUMsWUFBckUsRUFBbUY7QUFDekcsTUFBSUMsRUFBRSxHQUFHLElBQUlDLHVEQUFKLENBQWNMLE1BQU0sQ0FBQ00sR0FBckIsRUFBMEJuRixNQUExQixFQUFrQ0MsUUFBbEMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QrRSxZQUFZLEdBQUdsRixnQ0FBSCxHQUFzQ0QsdUJBQXBHLENBQVQ7QUFDQWdGLFFBQU0sQ0FBQ00sR0FBUCxHQUFhRixFQUFiO0FBQ0FBLElBQUUsQ0FBQ3ZGLENBQUgsR0FBT29GLFNBQVA7QUFDQUcsSUFBRSxDQUFDekYsQ0FBSCxHQUFPdUYsR0FBUDs7QUFFQUYsUUFBTSxDQUFDTyxNQUFQLENBQWNDLElBQWQsQ0FBbUJwRixRQUFuQjs7QUFFQSxTQUFPZ0YsRUFBUDtBQUNELENBaE5EO0FBQUEsSUFpTklLLG9CQUFvQixHQUFHO0FBQ3pCQyxLQUFHLEVBQUUsQ0FEb0I7QUFFekJDLEtBQUcsRUFBRSxDQUZvQjtBQUd6QkMsTUFBSSxFQUFFO0FBSG1CLENBak4zQjtBQUFBLElBc05JO0FBQ0pDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCMUYsTUFBeEIsRUFBZ0NDLFFBQWhDLEVBQTBDTCxLQUExQyxFQUFpRCtGLElBQWpELEVBQXVEO0FBQ3RFLE1BQUlDLFFBQVEsR0FBR0MsVUFBVSxDQUFDakcsS0FBRCxDQUFWLElBQXFCLENBQXBDO0FBQUEsTUFDSWtHLE9BQU8sR0FBRyxDQUFDbEcsS0FBSyxHQUFHLEVBQVQsRUFBYW1HLElBQWIsR0FBb0IxRCxNQUFwQixDQUEyQixDQUFDdUQsUUFBUSxHQUFHLEVBQVosRUFBZ0IvQixNQUEzQyxLQUFzRCxJQURwRTtBQUFBLE1BRUk7QUFDSjNELE9BQUssR0FBR3pDLFFBQVEsQ0FBQ3lDLEtBSGpCO0FBQUEsTUFJSThGLFVBQVUsR0FBR3pILGNBQWMsQ0FBQzBILElBQWYsQ0FBb0JoRyxRQUFwQixDQUpqQjtBQUFBLE1BS0lpRyxTQUFTLEdBQUdsRyxNQUFNLENBQUNtRyxPQUFQLENBQWV2RSxXQUFmLE9BQWlDLEtBTGpEO0FBQUEsTUFNSXdFLGVBQWUsR0FBRyxDQUFDRixTQUFTLEdBQUcsUUFBSCxHQUFjLFFBQXhCLEtBQXFDRixVQUFVLEdBQUcsT0FBSCxHQUFhLFFBQTVELENBTnRCO0FBQUEsTUFPSUssTUFBTSxHQUFHLEdBUGI7QUFBQSxNQVFJQyxRQUFRLEdBQUdYLElBQUksS0FBSyxJQVJ4QjtBQUFBLE1BU0lZLFNBQVMsR0FBR1osSUFBSSxLQUFLLEdBVHpCO0FBQUEsTUFVSWEsRUFWSjtBQUFBLE1BV0lDLE1BWEo7QUFBQSxNQVlJOUYsS0FaSjtBQUFBLE1BYUkrRixLQWJKOztBQWVBLE1BQUlmLElBQUksS0FBS0csT0FBVCxJQUFvQixDQUFDRixRQUFyQixJQUFpQ04sb0JBQW9CLENBQUNLLElBQUQsQ0FBckQsSUFBK0RMLG9CQUFvQixDQUFDUSxPQUFELENBQXZGLEVBQWtHO0FBQ2hHLFdBQU9GLFFBQVA7QUFDRDs7QUFFREUsU0FBTyxLQUFLLElBQVosSUFBb0IsQ0FBQ1EsUUFBckIsS0FBa0NWLFFBQVEsR0FBR0YsY0FBYyxDQUFDMUYsTUFBRCxFQUFTQyxRQUFULEVBQW1CTCxLQUFuQixFQUEwQixJQUExQixDQUEzRDtBQUNBOEcsT0FBSyxHQUFHMUcsTUFBTSxDQUFDd0UsTUFBUCxJQUFpQkQsTUFBTSxDQUFDdkUsTUFBRCxDQUEvQjs7QUFFQSxNQUFJLENBQUN1RyxTQUFTLElBQUlULE9BQU8sS0FBSyxHQUExQixNQUFtQ2hJLGVBQWUsQ0FBQ21DLFFBQUQsQ0FBZixJQUE2QixDQUFDQSxRQUFRLENBQUMwRyxPQUFULENBQWlCLE9BQWpCLENBQWpFLENBQUosRUFBaUc7QUFDL0ZILE1BQUUsR0FBR0UsS0FBSyxHQUFHMUcsTUFBTSxDQUFDdUQsT0FBUCxHQUFpQnlDLFVBQVUsR0FBRyxPQUFILEdBQWEsUUFBeEMsQ0FBSCxHQUF1RGhHLE1BQU0sQ0FBQ29HLGVBQUQsQ0FBdkU7QUFDQSxXQUFPUSw0REFBTSxDQUFDTCxTQUFTLEdBQUdYLFFBQVEsR0FBR1ksRUFBWCxHQUFnQkgsTUFBbkIsR0FBNEJULFFBQVEsR0FBRyxHQUFYLEdBQWlCWSxFQUF2RCxDQUFiO0FBQ0Q7O0FBRUR0RyxPQUFLLENBQUM4RixVQUFVLEdBQUcsT0FBSCxHQUFhLFFBQXhCLENBQUwsR0FBeUNLLE1BQU0sSUFBSUMsUUFBUSxHQUFHUixPQUFILEdBQWFILElBQXpCLENBQS9DO0FBQ0FjLFFBQU0sR0FBRyxDQUFDeEcsUUFBUSxDQUFDMEcsT0FBVCxDQUFpQixPQUFqQixDQUFELElBQThCaEIsSUFBSSxLQUFLLElBQVQsSUFBaUIzRixNQUFNLENBQUNxRCxXQUF4QixJQUF1QyxDQUFDNkMsU0FBdEUsR0FBa0ZsRyxNQUFsRixHQUEyRkEsTUFBTSxDQUFDZ0QsVUFBM0c7O0FBRUEsTUFBSTBELEtBQUosRUFBVztBQUNURCxVQUFNLEdBQUcsQ0FBQ3pHLE1BQU0sQ0FBQzZDLGVBQVAsSUFBMEIsRUFBM0IsRUFBK0JHLFVBQXhDO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDeUQsTUFBRCxJQUFXQSxNQUFNLEtBQUtuSixJQUF0QixJQUE4QixDQUFDbUosTUFBTSxDQUFDcEQsV0FBMUMsRUFBdUQ7QUFDckRvRCxVQUFNLEdBQUduSixJQUFJLENBQUN1SixJQUFkO0FBQ0Q7O0FBRURsRyxPQUFLLEdBQUc4RixNQUFNLENBQUNuRyxLQUFmOztBQUVBLE1BQUlLLEtBQUssSUFBSTRGLFNBQVQsSUFBc0I1RixLQUFLLENBQUN3RCxLQUE1QixJQUFxQzZCLFVBQXJDLElBQW1EckYsS0FBSyxDQUFDbUcsSUFBTixLQUFlQyxxREFBTyxDQUFDRCxJQUE5RSxFQUFvRjtBQUNsRixXQUFPRiw0REFBTSxDQUFDaEIsUUFBUSxHQUFHakYsS0FBSyxDQUFDd0QsS0FBakIsR0FBeUJrQyxNQUExQixDQUFiO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsS0FBQ0UsU0FBUyxJQUFJVCxPQUFPLEtBQUssR0FBMUIsTUFBbUM1RixLQUFLLENBQUM4RyxRQUFOLEdBQWlCekYsb0JBQW9CLENBQUN2QixNQUFELEVBQVMsVUFBVCxDQUF4RTtBQUNBeUcsVUFBTSxLQUFLekcsTUFBWCxLQUFzQkUsS0FBSyxDQUFDOEcsUUFBTixHQUFpQixRQUF2QyxFQUZLLENBRTZDOztBQUVsRFAsVUFBTSxDQUFDcEQsV0FBUCxDQUFtQjVGLFFBQW5CO0FBQ0ErSSxNQUFFLEdBQUcvSSxRQUFRLENBQUMySSxlQUFELENBQWI7QUFDQUssVUFBTSxDQUFDL0MsV0FBUCxDQUFtQmpHLFFBQW5CO0FBQ0F5QyxTQUFLLENBQUM4RyxRQUFOLEdBQWlCLFVBQWpCOztBQUVBLFFBQUloQixVQUFVLElBQUlPLFNBQWxCLEVBQTZCO0FBQzNCNUYsV0FBSyxHQUFHc0csK0RBQVMsQ0FBQ1IsTUFBRCxDQUFqQjtBQUNBOUYsV0FBSyxDQUFDbUcsSUFBTixHQUFhQyxxREFBTyxDQUFDRCxJQUFyQjtBQUNBbkcsV0FBSyxDQUFDd0QsS0FBTixHQUFjc0MsTUFBTSxDQUFDTCxlQUFELENBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPUSw0REFBTSxDQUFDTixRQUFRLEdBQUdFLEVBQUUsR0FBR1osUUFBTCxHQUFnQlMsTUFBbkIsR0FBNEJHLEVBQUUsSUFBSVosUUFBTixHQUFpQlMsTUFBTSxHQUFHRyxFQUFULEdBQWNaLFFBQS9CLEdBQTBDLENBQS9FLENBQWI7QUFDRCxDQW5SRDtBQUFBLElBb1JJc0IsSUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBY2xILE1BQWQsRUFBc0JDLFFBQXRCLEVBQWdDMEYsSUFBaEMsRUFBc0N3QixPQUF0QyxFQUErQztBQUN4RCxNQUFJdkgsS0FBSjtBQUNBcEMsZ0JBQWMsSUFBSThFLFNBQVMsRUFBM0I7O0FBRUEsTUFBSXJDLFFBQVEsSUFBSXhCLGdCQUFaLElBQWdDd0IsUUFBUSxLQUFLLFdBQWpELEVBQThEO0FBQzVEQSxZQUFRLEdBQUd4QixnQkFBZ0IsQ0FBQ3dCLFFBQUQsQ0FBM0I7O0FBRUEsUUFBSSxDQUFDQSxRQUFRLENBQUMwRyxPQUFULENBQWlCLEdBQWpCLENBQUwsRUFBNEI7QUFDMUIxRyxjQUFRLEdBQUdBLFFBQVEsQ0FBQzhCLEtBQVQsQ0FBZSxHQUFmLEVBQW9CLENBQXBCLENBQVg7QUFDRDtBQUNGOztBQUVELE1BQUlqRSxlQUFlLENBQUNtQyxRQUFELENBQWYsSUFBNkJBLFFBQVEsS0FBSyxXQUE5QyxFQUEyRDtBQUN6REwsU0FBSyxHQUFHd0gsZUFBZSxDQUFDcEgsTUFBRCxFQUFTbUgsT0FBVCxDQUF2QjtBQUNBdkgsU0FBSyxHQUFHSyxRQUFRLEtBQUssaUJBQWIsR0FBaUNMLEtBQUssQ0FBQ0ssUUFBRCxDQUF0QyxHQUFtRG9ILGFBQWEsQ0FBQzlGLG9CQUFvQixDQUFDdkIsTUFBRCxFQUFTZSxvQkFBVCxDQUFyQixDQUFiLEdBQW9FLEdBQXBFLEdBQTBFbkIsS0FBSyxDQUFDMEgsT0FBaEYsR0FBMEYsSUFBcko7QUFDRCxHQUhELE1BR087QUFDTDFILFNBQUssR0FBR0ksTUFBTSxDQUFDRSxLQUFQLENBQWFELFFBQWIsQ0FBUjs7QUFFQSxRQUFJLENBQUNMLEtBQUQsSUFBVUEsS0FBSyxLQUFLLE1BQXBCLElBQThCdUgsT0FBOUIsSUFBeUMsQ0FBQyxDQUFDdkgsS0FBSyxHQUFHLEVBQVQsRUFBYStHLE9BQWIsQ0FBcUIsT0FBckIsQ0FBOUMsRUFBNkU7QUFDM0UvRyxXQUFLLEdBQUcySCxhQUFhLENBQUN0SCxRQUFELENBQWIsSUFBMkJzSCxhQUFhLENBQUN0SCxRQUFELENBQWIsQ0FBd0JELE1BQXhCLEVBQWdDQyxRQUFoQyxFQUEwQzBGLElBQTFDLENBQTNCLElBQThFcEUsb0JBQW9CLENBQUN2QixNQUFELEVBQVNDLFFBQVQsQ0FBbEcsSUFBd0h1SCxrRUFBWSxDQUFDeEgsTUFBRCxFQUFTQyxRQUFULENBQXBJLEtBQTJKQSxRQUFRLEtBQUssU0FBYixHQUF5QixDQUF6QixHQUE2QixDQUF4TCxDQUFSLENBRDJFLENBQ3lIO0FBQ3JNO0FBQ0Y7O0FBRUQsU0FBTzBGLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQy9GLEtBQUssR0FBRyxFQUFULEVBQWFtRyxJQUFiLEdBQW9CWSxPQUFwQixDQUE0QixHQUE1QixDQUFWLEdBQTZDakIsY0FBYyxDQUFDMUYsTUFBRCxFQUFTQyxRQUFULEVBQW1CTCxLQUFuQixFQUEwQitGLElBQTFCLENBQWQsR0FBZ0RBLElBQTdGLEdBQW9HL0YsS0FBM0c7QUFDRCxDQTVTRDtBQUFBLElBNlNJNkgsc0JBQXNCLEdBQUcsU0FBU0Esc0JBQVQsQ0FBZ0N6SCxNQUFoQyxFQUF3QzBILElBQXhDLEVBQThDQyxLQUE5QyxFQUFxRDVDLEdBQXJELEVBQTBEO0FBQ3JGO0FBQ0EsTUFBSSxDQUFDNEMsS0FBRCxJQUFVQSxLQUFLLEtBQUssTUFBeEIsRUFBZ0M7QUFDOUI7QUFDQSxRQUFJekksQ0FBQyxHQUFHMkMsZ0JBQWdCLENBQUM2RixJQUFELEVBQU8xSCxNQUFQLEVBQWUsQ0FBZixDQUF4QjtBQUFBLFFBQ0laLENBQUMsR0FBR0YsQ0FBQyxJQUFJcUMsb0JBQW9CLENBQUN2QixNQUFELEVBQVNkLENBQVQsRUFBWSxDQUFaLENBRGpDOztBQUdBLFFBQUlFLENBQUMsSUFBSUEsQ0FBQyxLQUFLdUksS0FBZixFQUFzQjtBQUNwQkQsVUFBSSxHQUFHeEksQ0FBUDtBQUNBeUksV0FBSyxHQUFHdkksQ0FBUjtBQUNELEtBSEQsTUFHTyxJQUFJc0ksSUFBSSxLQUFLLGFBQWIsRUFBNEI7QUFDakNDLFdBQUssR0FBR3BHLG9CQUFvQixDQUFDdkIsTUFBRCxFQUFTLGdCQUFULENBQTVCLENBRGlDLENBQ3VCO0FBQ3pEO0FBQ0Y7O0FBRUQsTUFBSWlGLEVBQUUsR0FBRyxJQUFJQyx1REFBSixDQUFjLEtBQUtDLEdBQW5CLEVBQXdCbkYsTUFBTSxDQUFDRSxLQUEvQixFQUFzQ3dILElBQXRDLEVBQTRDLENBQTVDLEVBQStDLENBQS9DLEVBQWtERSxrRUFBbEQsQ0FBVDtBQUFBLE1BQ0lDLEtBQUssR0FBRyxDQURaO0FBQUEsTUFFSUMsVUFBVSxHQUFHLENBRmpCO0FBQUEsTUFHSUMsQ0FISjtBQUFBLE1BSUlDLE1BSko7QUFBQSxNQUtJQyxXQUxKO0FBQUEsTUFNSUMsUUFOSjtBQUFBLE1BT0lDLEtBUEo7QUFBQSxNQVFJQyxVQVJKO0FBQUEsTUFTSUMsUUFUSjtBQUFBLE1BVUlDLE1BVko7QUFBQSxNQVdJQyxLQVhKO0FBQUEsTUFZSUMsT0FaSjtBQUFBLE1BYUlDLFNBYko7QUFBQSxNQWNJQyxRQWRKO0FBQUEsTUFlSUMsU0FmSjtBQWdCQTFELElBQUUsQ0FBQ3ZGLENBQUgsR0FBT2lJLEtBQVA7QUFDQTFDLElBQUUsQ0FBQ3pGLENBQUgsR0FBT3VGLEdBQVA7QUFDQTRDLE9BQUssSUFBSSxFQUFULENBakNxRixDQWlDeEU7O0FBRWI1QyxLQUFHLElBQUksRUFBUDs7QUFFQSxNQUFJQSxHQUFHLEtBQUssTUFBWixFQUFvQjtBQUNsQi9FLFVBQU0sQ0FBQ0UsS0FBUCxDQUFhd0gsSUFBYixJQUFxQjNDLEdBQXJCO0FBQ0FBLE9BQUcsR0FBR3hELG9CQUFvQixDQUFDdkIsTUFBRCxFQUFTMEgsSUFBVCxDQUFwQixJQUFzQzNDLEdBQTVDO0FBQ0EvRSxVQUFNLENBQUNFLEtBQVAsQ0FBYXdILElBQWIsSUFBcUJDLEtBQXJCO0FBQ0Q7O0FBRURJLEdBQUMsR0FBRyxDQUFDSixLQUFELEVBQVE1QyxHQUFSLENBQUo7O0FBRUE2RCwwRUFBa0IsQ0FBQ2IsQ0FBRCxDQUFsQixDQTdDcUYsQ0E2QzlEOzs7QUFHdkJKLE9BQUssR0FBR0ksQ0FBQyxDQUFDLENBQUQsQ0FBVDtBQUNBaEQsS0FBRyxHQUFHZ0QsQ0FBQyxDQUFDLENBQUQsQ0FBUDtBQUNBRSxhQUFXLEdBQUdOLEtBQUssQ0FBQ2tCLEtBQU4sQ0FBWUMsNkRBQVosS0FBZ0MsRUFBOUM7QUFDQUgsV0FBUyxHQUFHNUQsR0FBRyxDQUFDOEQsS0FBSixDQUFVQyw2REFBVixLQUE4QixFQUExQzs7QUFFQSxNQUFJSCxTQUFTLENBQUM5RSxNQUFkLEVBQXNCO0FBQ3BCLFdBQU9tRSxNQUFNLEdBQUdjLDZEQUFlLENBQUNDLElBQWhCLENBQXFCaEUsR0FBckIsQ0FBaEIsRUFBMkM7QUFDekNzRCxjQUFRLEdBQUdMLE1BQU0sQ0FBQyxDQUFELENBQWpCO0FBQ0FPLFdBQUssR0FBR3hELEdBQUcsQ0FBQ2lFLFNBQUosQ0FBY25CLEtBQWQsRUFBcUJHLE1BQU0sQ0FBQ0gsS0FBNUIsQ0FBUjs7QUFFQSxVQUFJTSxLQUFKLEVBQVc7QUFDVEEsYUFBSyxHQUFHLENBQUNBLEtBQUssR0FBRyxDQUFULElBQWMsQ0FBdEI7QUFDRCxPQUZELE1BRU8sSUFBSUksS0FBSyxDQUFDbEcsTUFBTixDQUFhLENBQUMsQ0FBZCxNQUFxQixPQUFyQixJQUFnQ2tHLEtBQUssQ0FBQ2xHLE1BQU4sQ0FBYSxDQUFDLENBQWQsTUFBcUIsT0FBekQsRUFBa0U7QUFDdkU4RixhQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELFVBQUlFLFFBQVEsTUFBTUQsVUFBVSxHQUFHSCxXQUFXLENBQUNILFVBQVUsRUFBWCxDQUFYLElBQTZCLEVBQWhELENBQVosRUFBaUU7QUFDL0RJLGdCQUFRLEdBQUdyQyxVQUFVLENBQUN1QyxVQUFELENBQVYsSUFBMEIsQ0FBckM7QUFDQUssaUJBQVMsR0FBR0wsVUFBVSxDQUFDL0YsTUFBWCxDQUFrQixDQUFDNkYsUUFBUSxHQUFHLEVBQVosRUFBZ0JyRSxNQUFsQyxDQUFaO0FBQ0E2RSxnQkFBUSxHQUFHTCxRQUFRLENBQUNsRyxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZCLEdBQTZCLEVBQUVrRyxRQUFRLENBQUNsRyxNQUFULENBQWdCLENBQWhCLElBQXFCLEdBQXZCLENBQTdCLEdBQTJELENBQXRFOztBQUVBLFlBQUl1RyxRQUFKLEVBQWM7QUFDWkwsa0JBQVEsR0FBR0EsUUFBUSxDQUFDaEcsTUFBVCxDQUFnQixDQUFoQixDQUFYO0FBQ0Q7O0FBRURpRyxjQUFNLEdBQUd6QyxVQUFVLENBQUN3QyxRQUFELENBQW5CO0FBQ0FHLGVBQU8sR0FBR0gsUUFBUSxDQUFDaEcsTUFBVCxDQUFnQixDQUFDaUcsTUFBTSxHQUFHLEVBQVYsRUFBY3pFLE1BQTlCLENBQVY7QUFDQWdFLGFBQUssR0FBR2lCLDZEQUFlLENBQUNHLFNBQWhCLEdBQTRCVCxPQUFPLENBQUMzRSxNQUE1Qzs7QUFFQSxZQUFJLENBQUMyRSxPQUFMLEVBQWM7QUFDWjtBQUNBQSxpQkFBTyxHQUFHQSxPQUFPLElBQUlVLHFEQUFPLENBQUNDLEtBQVIsQ0FBY3pCLElBQWQsQ0FBWCxJQUFrQ2UsU0FBNUM7O0FBRUEsY0FBSVosS0FBSyxLQUFLOUMsR0FBRyxDQUFDbEIsTUFBbEIsRUFBMEI7QUFDeEJrQixlQUFHLElBQUl5RCxPQUFQO0FBQ0F2RCxjQUFFLENBQUN6RixDQUFILElBQVFnSixPQUFSO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJQyxTQUFTLEtBQUtELE9BQWxCLEVBQTJCO0FBQ3pCTixrQkFBUSxHQUFHeEMsY0FBYyxDQUFDMUYsTUFBRCxFQUFTMEgsSUFBVCxFQUFlVSxVQUFmLEVBQTJCSSxPQUEzQixDQUFkLElBQXFELENBQWhFO0FBQ0QsU0F6QjhELENBeUI3RDs7O0FBR0Z2RCxVQUFFLENBQUNFLEdBQUgsR0FBUztBQUNQaUUsZUFBSyxFQUFFbkUsRUFBRSxDQUFDRSxHQURIO0FBRVBqRyxXQUFDLEVBQUVxSixLQUFLLElBQUlULFVBQVUsS0FBSyxDQUF4QixHQUE0QlMsS0FBNUIsR0FBb0MsR0FGaEM7QUFHUDtBQUNBbkosV0FBQyxFQUFFOEksUUFKSTtBQUtQN0ksV0FBQyxFQUFFcUosUUFBUSxHQUFHQSxRQUFRLEdBQUdKLE1BQWQsR0FBdUJBLE1BQU0sR0FBR0osUUFMcEM7QUFNUG1CLFdBQUMsRUFBRWxCLEtBQUssSUFBSUEsS0FBSyxHQUFHLENBQWpCLElBQXNCVCxJQUFJLEtBQUssUUFBL0IsR0FBMEMxSixJQUFJLENBQUNtQixLQUEvQyxHQUF1RDtBQU5uRCxTQUFUO0FBUUQ7QUFDRjs7QUFFRDhGLE1BQUUsQ0FBQzVGLENBQUgsR0FBT3dJLEtBQUssR0FBRzlDLEdBQUcsQ0FBQ2xCLE1BQVosR0FBcUJrQixHQUFHLENBQUNpRSxTQUFKLENBQWNuQixLQUFkLEVBQXFCOUMsR0FBRyxDQUFDbEIsTUFBekIsQ0FBckIsR0FBd0QsRUFBL0QsQ0FsRG9CLENBa0QrQztBQUNwRSxHQW5ERCxNQW1ETztBQUNMb0IsTUFBRSxDQUFDcUUsQ0FBSCxHQUFPNUIsSUFBSSxLQUFLLFNBQVQsSUFBc0IzQyxHQUFHLEtBQUssTUFBOUIsR0FBdUNqRixnQ0FBdkMsR0FBMEVELHVCQUFqRjtBQUNEOztBQUVEMEosdURBQU8sQ0FBQ3RELElBQVIsQ0FBYWxCLEdBQWIsTUFBc0JFLEVBQUUsQ0FBQ3pGLENBQUgsR0FBTyxDQUE3QixFQTVHcUYsQ0E0R3BEOztBQUVqQyxPQUFLMkYsR0FBTCxHQUFXRixFQUFYLENBOUdxRixDQThHdEU7O0FBRWYsU0FBT0EsRUFBUDtBQUNELENBOVpEO0FBQUEsSUErWkl1RSxpQkFBaUIsR0FBRztBQUN0QkMsS0FBRyxFQUFFLElBRGlCO0FBRXRCQyxRQUFNLEVBQUUsTUFGYztBQUd0QkMsTUFBSSxFQUFFLElBSGdCO0FBSXRCQyxPQUFLLEVBQUUsTUFKZTtBQUt0QkMsUUFBTSxFQUFFO0FBTGMsQ0EvWnhCO0FBQUEsSUFzYUlDLDZCQUE2QixHQUFHLFNBQVNBLDZCQUFULENBQXVDbEssS0FBdkMsRUFBOEM7QUFDaEYsTUFBSW1DLEtBQUssR0FBR25DLEtBQUssQ0FBQ21DLEtBQU4sQ0FBWSxHQUFaLENBQVo7QUFBQSxNQUNJc0MsQ0FBQyxHQUFHdEMsS0FBSyxDQUFDLENBQUQsQ0FEYjtBQUFBLE1BRUl1QyxDQUFDLEdBQUd2QyxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVksS0FGcEI7O0FBSUEsTUFBSXNDLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxRQUFyQixJQUFpQ0MsQ0FBQyxLQUFLLE1BQXZDLElBQWlEQSxDQUFDLEtBQUssT0FBM0QsRUFBb0U7QUFDbEU7QUFDQTFFLFNBQUssR0FBR3lFLENBQVI7QUFDQUEsS0FBQyxHQUFHQyxDQUFKO0FBQ0FBLEtBQUMsR0FBRzFFLEtBQUo7QUFDRDs7QUFFRG1DLE9BQUssQ0FBQyxDQUFELENBQUwsR0FBV3lILGlCQUFpQixDQUFDbkYsQ0FBRCxDQUFqQixJQUF3QkEsQ0FBbkM7QUFDQXRDLE9BQUssQ0FBQyxDQUFELENBQUwsR0FBV3lILGlCQUFpQixDQUFDbEYsQ0FBRCxDQUFqQixJQUF3QkEsQ0FBbkM7QUFDQSxTQUFPdkMsS0FBSyxDQUFDZ0ksSUFBTixDQUFXLEdBQVgsQ0FBUDtBQUNELENBcmJEO0FBQUEsSUFzYklDLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCbEwsS0FBM0IsRUFBa0NDLElBQWxDLEVBQXdDO0FBQzlELE1BQUlBLElBQUksQ0FBQ2tMLEtBQUwsSUFBY2xMLElBQUksQ0FBQ2tMLEtBQUwsQ0FBV0MsS0FBWCxLQUFxQm5MLElBQUksQ0FBQ2tMLEtBQUwsQ0FBV0UsSUFBbEQsRUFBd0Q7QUFDdEQsUUFBSW5LLE1BQU0sR0FBR2pCLElBQUksQ0FBQ0UsQ0FBbEI7QUFBQSxRQUNJaUIsS0FBSyxHQUFHRixNQUFNLENBQUNFLEtBRG5CO0FBQUEsUUFFSWtLLEtBQUssR0FBR3JMLElBQUksQ0FBQ08sQ0FGakI7QUFBQSxRQUdJcUIsS0FBSyxHQUFHWCxNQUFNLENBQUNNLEtBSG5CO0FBQUEsUUFJSW9ILElBSko7QUFBQSxRQUtJMkMsZUFMSjtBQUFBLFFBTUluSSxDQU5KOztBQVFBLFFBQUlrSSxLQUFLLEtBQUssS0FBVixJQUFtQkEsS0FBSyxLQUFLLElBQWpDLEVBQXVDO0FBQ3JDbEssV0FBSyxDQUFDdUMsT0FBTixHQUFnQixFQUFoQjtBQUNBNEgscUJBQWUsR0FBRyxDQUFsQjtBQUNELEtBSEQsTUFHTztBQUNMRCxXQUFLLEdBQUdBLEtBQUssQ0FBQ3JJLEtBQU4sQ0FBWSxHQUFaLENBQVI7QUFDQUcsT0FBQyxHQUFHa0ksS0FBSyxDQUFDdkcsTUFBVjs7QUFFQSxhQUFPLEVBQUUzQixDQUFGLEdBQU0sQ0FBQyxDQUFkLEVBQWlCO0FBQ2Z3RixZQUFJLEdBQUcwQyxLQUFLLENBQUNsSSxDQUFELENBQVo7O0FBRUEsWUFBSXBFLGVBQWUsQ0FBQzRKLElBQUQsQ0FBbkIsRUFBMkI7QUFDekIyQyx5QkFBZSxHQUFHLENBQWxCO0FBQ0EzQyxjQUFJLEdBQUdBLElBQUksS0FBSyxpQkFBVCxHQUE2QjNHLG9CQUE3QixHQUFvREQsY0FBM0Q7QUFDRDs7QUFFRDJELHVCQUFlLENBQUN6RSxNQUFELEVBQVMwSCxJQUFULENBQWY7QUFDRDtBQUNGOztBQUVELFFBQUkyQyxlQUFKLEVBQXFCO0FBQ25CNUYscUJBQWUsQ0FBQ3pFLE1BQUQsRUFBU2MsY0FBVCxDQUFmOztBQUVBLFVBQUlILEtBQUosRUFBVztBQUNUQSxhQUFLLENBQUNpQyxHQUFOLElBQWE1QyxNQUFNLENBQUMyRSxlQUFQLENBQXVCLFdBQXZCLENBQWI7O0FBRUF5Qyx1QkFBZSxDQUFDcEgsTUFBRCxFQUFTLENBQVQsQ0FBZixDQUhTLENBR21COzs7QUFHNUJXLGFBQUssQ0FBQ3dHLE9BQU4sR0FBZ0IsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixDQWhlRDtBQUFBLElBaWVJO0FBQ0pJLGFBQWEsR0FBRztBQUNkK0MsWUFBVSxFQUFFLFNBQVNBLFVBQVQsQ0FBb0J6RixNQUFwQixFQUE0QjdFLE1BQTVCLEVBQW9DQyxRQUFwQyxFQUE4Q29JLFFBQTlDLEVBQXdENEIsS0FBeEQsRUFBK0Q7QUFDekUsUUFBSUEsS0FBSyxDQUFDbEwsSUFBTixLQUFlLGFBQW5CLEVBQWtDO0FBQ2hDLFVBQUlrRyxFQUFFLEdBQUdKLE1BQU0sQ0FBQ00sR0FBUCxHQUFhLElBQUlELHVEQUFKLENBQWNMLE1BQU0sQ0FBQ00sR0FBckIsRUFBMEJuRixNQUExQixFQUFrQ0MsUUFBbEMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QrSixpQkFBbEQsQ0FBdEI7QUFDQS9FLFFBQUUsQ0FBQzNGLENBQUgsR0FBTytJLFFBQVA7QUFDQXBELFFBQUUsQ0FBQ3NGLEVBQUgsR0FBUSxDQUFDLEVBQVQ7QUFDQXRGLFFBQUUsQ0FBQ2dGLEtBQUgsR0FBV0EsS0FBWDs7QUFFQXBGLFlBQU0sQ0FBQ08sTUFBUCxDQUFjQyxJQUFkLENBQW1CcEYsUUFBbkI7O0FBRUEsYUFBTyxDQUFQO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYmMsQ0FsZWhCOztBQWlqQkE7Ozs7O0FBS0F1SyxpQkFBaUIsR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBdGpCcEI7QUFBQSxJQXVqQklDLHFCQUFxQixHQUFHLEVBdmpCNUI7QUFBQSxJQXdqQklDLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCOUssS0FBMUIsRUFBaUM7QUFDdEQsU0FBT0EsS0FBSyxLQUFLLDBCQUFWLElBQXdDQSxLQUFLLEtBQUssTUFBbEQsSUFBNEQsQ0FBQ0EsS0FBcEU7QUFDRCxDQTFqQkQ7QUFBQSxJQTJqQkkrSyxrQ0FBa0MsR0FBRyxTQUFTQSxrQ0FBVCxDQUE0QzNLLE1BQTVDLEVBQW9EO0FBQzNGLE1BQUk0SyxZQUFZLEdBQUdySixvQkFBb0IsQ0FBQ3ZCLE1BQUQsRUFBU2MsY0FBVCxDQUF2Qzs7QUFFQSxTQUFPNEosZ0JBQWdCLENBQUNFLFlBQUQsQ0FBaEIsR0FBaUNKLGlCQUFqQyxHQUFxREksWUFBWSxDQUFDdkksTUFBYixDQUFvQixDQUFwQixFQUF1QndHLEtBQXZCLENBQTZCZ0MscURBQTdCLEVBQXNDQyxHQUF0QyxDQUEwQ2xFLG9EQUExQyxDQUE1RDtBQUNELENBL2pCRDtBQUFBLElBZ2tCSW1FLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9CL0ssTUFBcEIsRUFBNEJnTCxPQUE1QixFQUFxQztBQUNwRCxNQUFJckssS0FBSyxHQUFHWCxNQUFNLENBQUNNLEtBQVAsSUFBZ0IyRywrREFBUyxDQUFDakgsTUFBRCxDQUFyQztBQUFBLE1BQ0lFLEtBQUssR0FBR0YsTUFBTSxDQUFDRSxLQURuQjtBQUFBLE1BRUkrSyxNQUFNLEdBQUdOLGtDQUFrQyxDQUFDM0ssTUFBRCxDQUYvQztBQUFBLE1BR0l5RyxNQUhKO0FBQUEsTUFJSXZELFdBSko7QUFBQSxNQUtJZ0ksSUFMSjtBQUFBLE1BTUlDLFVBTko7O0FBUUEsTUFBSXhLLEtBQUssQ0FBQ2lDLEdBQU4sSUFBYTVDLE1BQU0sQ0FBQzhDLFlBQVAsQ0FBb0IsV0FBcEIsQ0FBakIsRUFBbUQ7QUFDakRvSSxRQUFJLEdBQUdsTCxNQUFNLENBQUNvTCxTQUFQLENBQWlCQyxPQUFqQixDQUF5QkMsV0FBekIsR0FBdUNMLE1BQTlDLENBRGlELENBQ0s7O0FBRXREQSxVQUFNLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDbkQsQ0FBTixFQUFTbUQsSUFBSSxDQUFDeEwsQ0FBZCxFQUFpQndMLElBQUksQ0FBQzdMLENBQXRCLEVBQXlCNkwsSUFBSSxDQUFDSyxDQUE5QixFQUFpQ0wsSUFBSSxDQUFDMUwsQ0FBdEMsRUFBeUMwTCxJQUFJLENBQUNNLENBQTlDLENBQVQ7QUFDQSxXQUFPUCxNQUFNLENBQUNsQixJQUFQLENBQVksR0FBWixNQUFxQixhQUFyQixHQUFxQ1MsaUJBQXJDLEdBQXlEUyxNQUFoRTtBQUNELEdBTEQsTUFLTyxJQUFJQSxNQUFNLEtBQUtULGlCQUFYLElBQWdDLENBQUN4SyxNQUFNLENBQUN5TCxZQUF4QyxJQUF3RHpMLE1BQU0sS0FBS3pDLFdBQW5FLElBQWtGLENBQUNvRCxLQUFLLENBQUNpQyxHQUE3RixFQUFrRztBQUN2RztBQUNBO0FBQ0FzSSxRQUFJLEdBQUdoTCxLQUFLLENBQUNvRCxPQUFiO0FBQ0FwRCxTQUFLLENBQUNvRCxPQUFOLEdBQWdCLE9BQWhCO0FBQ0FtRCxVQUFNLEdBQUd6RyxNQUFNLENBQUNnRCxVQUFoQjs7QUFFQSxRQUFJLENBQUN5RCxNQUFELElBQVcsQ0FBQ3pHLE1BQU0sQ0FBQ3lMLFlBQXZCLEVBQXFDO0FBQ25DO0FBQ0FOLGdCQUFVLEdBQUcsQ0FBYixDQUZtQyxDQUVuQjs7QUFFaEJqSSxpQkFBVyxHQUFHbEQsTUFBTSxDQUFDa0QsV0FBckI7O0FBRUEzRixpQkFBVyxDQUFDOEYsV0FBWixDQUF3QnJELE1BQXhCLEVBTm1DLENBTUY7O0FBRWxDOztBQUVEaUwsVUFBTSxHQUFHTixrQ0FBa0MsQ0FBQzNLLE1BQUQsQ0FBM0M7QUFDQWtMLFFBQUksR0FBR2hMLEtBQUssQ0FBQ29ELE9BQU4sR0FBZ0I0SCxJQUFuQixHQUEwQnpHLGVBQWUsQ0FBQ3pFLE1BQUQsRUFBUyxTQUFULENBQTdDOztBQUVBLFFBQUltTCxVQUFKLEVBQWdCO0FBQ2RqSSxpQkFBVyxHQUFHdUQsTUFBTSxDQUFDaEQsWUFBUCxDQUFvQnpELE1BQXBCLEVBQTRCa0QsV0FBNUIsQ0FBSCxHQUE4Q3VELE1BQU0sR0FBR0EsTUFBTSxDQUFDcEQsV0FBUCxDQUFtQnJELE1BQW5CLENBQUgsR0FBZ0N6QyxXQUFXLENBQUNtRyxXQUFaLENBQXdCMUQsTUFBeEIsQ0FBL0Y7QUFDRDtBQUNGOztBQUVELFNBQU9nTCxPQUFPLElBQUlDLE1BQU0sQ0FBQ3BILE1BQVAsR0FBZ0IsQ0FBM0IsR0FBK0IsQ0FBQ29ILE1BQU0sQ0FBQyxDQUFELENBQVAsRUFBWUEsTUFBTSxDQUFDLENBQUQsQ0FBbEIsRUFBdUJBLE1BQU0sQ0FBQyxDQUFELENBQTdCLEVBQWtDQSxNQUFNLENBQUMsQ0FBRCxDQUF4QyxFQUE2Q0EsTUFBTSxDQUFDLEVBQUQsQ0FBbkQsRUFBeURBLE1BQU0sQ0FBQyxFQUFELENBQS9ELENBQS9CLEdBQXNHQSxNQUE3RztBQUNELENBeG1CRDtBQUFBLElBeW1CSVMsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUIxTCxNQUF6QixFQUFpQzJMLE1BQWpDLEVBQXlDQyxnQkFBekMsRUFBMkRDLE1BQTNELEVBQW1FQyxXQUFuRSxFQUFnRkMsdUJBQWhGLEVBQXlHO0FBQzdILE1BQUlwTCxLQUFLLEdBQUdYLE1BQU0sQ0FBQ00sS0FBbkI7QUFBQSxNQUNJMkssTUFBTSxHQUFHYSxXQUFXLElBQUlmLFVBQVUsQ0FBQy9LLE1BQUQsRUFBUyxJQUFULENBRHRDO0FBQUEsTUFFSWdNLFVBQVUsR0FBR3JMLEtBQUssQ0FBQ3NMLE9BQU4sSUFBaUIsQ0FGbEM7QUFBQSxNQUdJQyxVQUFVLEdBQUd2TCxLQUFLLENBQUN3TCxPQUFOLElBQWlCLENBSGxDO0FBQUEsTUFJSUMsVUFBVSxHQUFHekwsS0FBSyxDQUFDMEwsT0FBTixJQUFpQixDQUpsQztBQUFBLE1BS0lDLFVBQVUsR0FBRzNMLEtBQUssQ0FBQzRMLE9BQU4sSUFBaUIsQ0FMbEM7QUFBQSxNQU1JeEUsQ0FBQyxHQUFHa0QsTUFBTSxDQUFDLENBQUQsQ0FOZDtBQUFBLE1BT0l2TCxDQUFDLEdBQUd1TCxNQUFNLENBQUMsQ0FBRCxDQVBkO0FBQUEsTUFRSTVMLENBQUMsR0FBRzRMLE1BQU0sQ0FBQyxDQUFELENBUmQ7QUFBQSxNQVNJTSxDQUFDLEdBQUdOLE1BQU0sQ0FBQyxDQUFELENBVGQ7QUFBQSxNQVVJdUIsRUFBRSxHQUFHdkIsTUFBTSxDQUFDLENBQUQsQ0FWZjtBQUFBLE1BV0l3QixFQUFFLEdBQUd4QixNQUFNLENBQUMsQ0FBRCxDQVhmO0FBQUEsTUFZSXlCLFdBQVcsR0FBR2YsTUFBTSxDQUFDNUosS0FBUCxDQUFhLEdBQWIsQ0FabEI7QUFBQSxNQWFJa0ssT0FBTyxHQUFHcEcsVUFBVSxDQUFDNkcsV0FBVyxDQUFDLENBQUQsQ0FBWixDQUFWLElBQThCLENBYjVDO0FBQUEsTUFjSVAsT0FBTyxHQUFHdEcsVUFBVSxDQUFDNkcsV0FBVyxDQUFDLENBQUQsQ0FBWixDQUFWLElBQThCLENBZDVDO0FBQUEsTUFlSTFJLE1BZko7QUFBQSxNQWdCSTJJLFdBaEJKO0FBQUEsTUFpQkl0SSxDQWpCSjtBQUFBLE1Ba0JJQyxDQWxCSjs7QUFvQkEsTUFBSSxDQUFDc0gsZ0JBQUwsRUFBdUI7QUFDckI1SCxVQUFNLEdBQUdELFFBQVEsQ0FBQy9ELE1BQUQsQ0FBakI7QUFDQWlNLFdBQU8sR0FBR2pJLE1BQU0sQ0FBQ0ssQ0FBUCxJQUFZLENBQUNxSSxXQUFXLENBQUMsQ0FBRCxDQUFYLENBQWUvRixPQUFmLENBQXVCLEdBQXZCLENBQUQsR0FBK0JzRixPQUFPLEdBQUcsR0FBVixHQUFnQmpJLE1BQU0sQ0FBQ0csS0FBdEQsR0FBOEQ4SCxPQUExRSxDQUFWO0FBQ0FFLFdBQU8sR0FBR25JLE1BQU0sQ0FBQ00sQ0FBUCxJQUFZLENBQUMsQ0FBQ29JLFdBQVcsQ0FBQyxDQUFELENBQVgsSUFBa0JBLFdBQVcsQ0FBQyxDQUFELENBQTlCLEVBQW1DL0YsT0FBbkMsQ0FBMkMsR0FBM0MsQ0FBRCxHQUFtRHdGLE9BQU8sR0FBRyxHQUFWLEdBQWdCbkksTUFBTSxDQUFDSSxNQUExRSxHQUFtRitILE9BQS9GLENBQVY7QUFDRCxHQUpELE1BSU8sSUFBSWxCLE1BQU0sS0FBS1QsaUJBQVgsS0FBaUNtQyxXQUFXLEdBQUc1RSxDQUFDLEdBQUd3RCxDQUFKLEdBQVE3TCxDQUFDLEdBQUdMLENBQTNELENBQUosRUFBbUU7QUFDeEU7QUFDQWdGLEtBQUMsR0FBRzRILE9BQU8sSUFBSVYsQ0FBQyxHQUFHb0IsV0FBUixDQUFQLEdBQThCUixPQUFPLElBQUksQ0FBQzlNLENBQUQsR0FBS3NOLFdBQVQsQ0FBckMsR0FBNkQsQ0FBQ3ROLENBQUMsR0FBR29OLEVBQUosR0FBU2xCLENBQUMsR0FBR2lCLEVBQWQsSUFBb0JHLFdBQXJGO0FBQ0FySSxLQUFDLEdBQUcySCxPQUFPLElBQUksQ0FBQ3ZNLENBQUQsR0FBS2lOLFdBQVQsQ0FBUCxHQUErQlIsT0FBTyxJQUFJcEUsQ0FBQyxHQUFHNEUsV0FBUixDQUF0QyxHQUE2RCxDQUFDNUUsQ0FBQyxHQUFHMEUsRUFBSixHQUFTL00sQ0FBQyxHQUFHOE0sRUFBZCxJQUFvQkcsV0FBckY7QUFDQVYsV0FBTyxHQUFHNUgsQ0FBVjtBQUNBOEgsV0FBTyxHQUFHN0gsQ0FBVjtBQUNEOztBQUVELE1BQUl1SCxNQUFNLElBQUlBLE1BQU0sS0FBSyxLQUFYLElBQW9CbEwsS0FBSyxDQUFDa0wsTUFBeEMsRUFBZ0Q7QUFDOUNXLE1BQUUsR0FBR1AsT0FBTyxHQUFHRCxVQUFmO0FBQ0FTLE1BQUUsR0FBR04sT0FBTyxHQUFHRCxVQUFmO0FBQ0F2TCxTQUFLLENBQUMwTCxPQUFOLEdBQWdCRCxVQUFVLElBQUlJLEVBQUUsR0FBR3pFLENBQUwsR0FBUzBFLEVBQUUsR0FBR3BOLENBQWxCLENBQVYsR0FBaUNtTixFQUFqRDtBQUNBN0wsU0FBSyxDQUFDNEwsT0FBTixHQUFnQkQsVUFBVSxJQUFJRSxFQUFFLEdBQUc5TSxDQUFMLEdBQVMrTSxFQUFFLEdBQUdsQixDQUFsQixDQUFWLEdBQWlDa0IsRUFBakQ7QUFDRCxHQUxELE1BS087QUFDTDlMLFNBQUssQ0FBQzBMLE9BQU4sR0FBZ0IxTCxLQUFLLENBQUM0TCxPQUFOLEdBQWdCLENBQWhDO0FBQ0Q7O0FBRUQ1TCxPQUFLLENBQUNzTCxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBdEwsT0FBSyxDQUFDd0wsT0FBTixHQUFnQkEsT0FBaEI7QUFDQXhMLE9BQUssQ0FBQ2tMLE1BQU4sR0FBZSxDQUFDLENBQUNBLE1BQWpCO0FBQ0FsTCxPQUFLLENBQUNnTCxNQUFOLEdBQWVBLE1BQWY7QUFDQWhMLE9BQUssQ0FBQ2lMLGdCQUFOLEdBQXlCLENBQUMsQ0FBQ0EsZ0JBQTNCO0FBQ0E1TCxRQUFNLENBQUNFLEtBQVAsQ0FBYWEsb0JBQWIsSUFBcUMsU0FBckMsQ0EvQzZILENBK0M3RTs7QUFFaEQsTUFBSWdMLHVCQUFKLEVBQTZCO0FBQzNCbkgscUJBQWlCLENBQUNtSCx1QkFBRCxFQUEwQnBMLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDcUwsVUFBNUMsRUFBd0RDLE9BQXhELENBQWpCOztBQUVBckgscUJBQWlCLENBQUNtSCx1QkFBRCxFQUEwQnBMLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDdUwsVUFBNUMsRUFBd0RDLE9BQXhELENBQWpCOztBQUVBdkgscUJBQWlCLENBQUNtSCx1QkFBRCxFQUEwQnBMLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDeUwsVUFBNUMsRUFBd0R6TCxLQUFLLENBQUMwTCxPQUE5RCxDQUFqQjs7QUFFQXpILHFCQUFpQixDQUFDbUgsdUJBQUQsRUFBMEJwTCxLQUExQixFQUFpQyxTQUFqQyxFQUE0QzJMLFVBQTVDLEVBQXdEM0wsS0FBSyxDQUFDNEwsT0FBOUQsQ0FBakI7QUFDRDs7QUFFRHZNLFFBQU0sQ0FBQzRNLFlBQVAsQ0FBb0IsaUJBQXBCLEVBQXVDWCxPQUFPLEdBQUcsR0FBVixHQUFnQkUsT0FBdkQ7QUFDRCxDQXJxQkQ7QUFBQSxJQXNxQkkvRSxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QnBILE1BQXpCLEVBQWlDbUgsT0FBakMsRUFBMEM7QUFDOUQsTUFBSXhHLEtBQUssR0FBR1gsTUFBTSxDQUFDTSxLQUFQLElBQWdCLElBQUl1TSxxREFBSixDQUFZN00sTUFBWixDQUE1Qjs7QUFFQSxNQUFJLE9BQU9XLEtBQVAsSUFBZ0IsQ0FBQ3dHLE9BQWpCLElBQTRCLENBQUN4RyxLQUFLLENBQUN3RyxPQUF2QyxFQUFnRDtBQUM5QyxXQUFPeEcsS0FBUDtBQUNEOztBQUVELE1BQUlULEtBQUssR0FBR0YsTUFBTSxDQUFDRSxLQUFuQjtBQUFBLE1BQ0k0TSxjQUFjLEdBQUduTSxLQUFLLENBQUNILE1BQU4sR0FBZSxDQURwQztBQUFBLE1BRUlnRyxFQUFFLEdBQUcsSUFGVDtBQUFBLE1BR0lqQixHQUFHLEdBQUcsS0FIVjtBQUFBLE1BSUlvRyxNQUFNLEdBQUdwSyxvQkFBb0IsQ0FBQ3ZCLE1BQUQsRUFBU2Usb0JBQVQsQ0FBcEIsSUFBc0QsR0FKbkU7QUFBQSxNQUtJc0QsQ0FMSjtBQUFBLE1BTUlDLENBTko7QUFBQSxNQU9JeUksQ0FQSjtBQUFBLE1BUUl2TSxNQVJKO0FBQUEsTUFTSUMsTUFUSjtBQUFBLE1BVUl1TSxRQVZKO0FBQUEsTUFXSUMsU0FYSjtBQUFBLE1BWUlDLFNBWko7QUFBQSxNQWFJQyxLQWJKO0FBQUEsTUFjSUMsS0FkSjtBQUFBLE1BZUlDLFdBZko7QUFBQSxNQWdCSXBCLE9BaEJKO0FBQUEsTUFpQklFLE9BakJKO0FBQUEsTUFrQklsQixNQWxCSjtBQUFBLE1BbUJJcUMsS0FuQko7QUFBQSxNQW9CSUMsR0FwQko7QUFBQSxNQXFCSUMsR0FyQko7QUFBQSxNQXNCSXpGLENBdEJKO0FBQUEsTUF1QklySSxDQXZCSjtBQUFBLE1Bd0JJTCxDQXhCSjtBQUFBLE1BeUJJa00sQ0F6Qko7QUFBQSxNQTBCSWtDLEdBMUJKO0FBQUEsTUEyQklDLEdBM0JKO0FBQUEsTUE0QklDLEVBNUJKO0FBQUEsTUE2QklDLEVBN0JKO0FBQUEsTUE4QklDLEVBOUJKO0FBQUEsTUErQklDLEdBL0JKO0FBQUEsTUFnQ0lDLEdBaENKO0FBQUEsTUFpQ0lDLEdBakNKO0FBQUEsTUFrQ0lDLEdBbENKO0FBQUEsTUFtQ0lDLEdBbkNKO0FBQUEsTUFvQ0lDLEdBcENKO0FBcUNBOUosR0FBQyxHQUFHQyxDQUFDLEdBQUd5SSxDQUFDLEdBQUdDLFFBQVEsR0FBR0MsU0FBUyxHQUFHQyxTQUFTLEdBQUdDLEtBQUssR0FBR0MsS0FBSyxHQUFHQyxXQUFXLEdBQUcsQ0FBN0U7QUFDQTdNLFFBQU0sR0FBR0MsTUFBTSxHQUFHLENBQWxCO0FBQ0FFLE9BQUssQ0FBQ2lDLEdBQU4sR0FBWSxDQUFDLEVBQUU1QyxNQUFNLENBQUN3RSxNQUFQLElBQWlCRCxNQUFNLENBQUN2RSxNQUFELENBQXpCLENBQWI7QUFDQWlMLFFBQU0sR0FBR0YsVUFBVSxDQUFDL0ssTUFBRCxFQUFTVyxLQUFLLENBQUNpQyxHQUFmLENBQW5COztBQUVBLE1BQUlqQyxLQUFLLENBQUNpQyxHQUFWLEVBQWU7QUFDYitLLE1BQUUsR0FBRyxDQUFDaE4sS0FBSyxDQUFDd0csT0FBUCxJQUFrQixDQUFDQSxPQUFuQixJQUE4Qm5ILE1BQU0sQ0FBQzhDLFlBQVAsQ0FBb0IsaUJBQXBCLENBQW5DOztBQUVBNEksbUJBQWUsQ0FBQzFMLE1BQUQsRUFBUzJOLEVBQUUsSUFBSWhDLE1BQWYsRUFBdUIsQ0FBQyxDQUFDZ0MsRUFBRixJQUFRaE4sS0FBSyxDQUFDaUwsZ0JBQXJDLEVBQXVEakwsS0FBSyxDQUFDa0wsTUFBTixLQUFpQixLQUF4RSxFQUErRVosTUFBL0UsQ0FBZjtBQUNEOztBQUVEZ0IsU0FBTyxHQUFHdEwsS0FBSyxDQUFDc0wsT0FBTixJQUFpQixDQUEzQjtBQUNBRSxTQUFPLEdBQUd4TCxLQUFLLENBQUN3TCxPQUFOLElBQWlCLENBQTNCOztBQUVBLE1BQUlsQixNQUFNLEtBQUtULGlCQUFmLEVBQWtDO0FBQ2hDekMsS0FBQyxHQUFHa0QsTUFBTSxDQUFDLENBQUQsQ0FBVixDQURnQyxDQUNqQjs7QUFFZnZMLEtBQUMsR0FBR3VMLE1BQU0sQ0FBQyxDQUFELENBQVYsQ0FIZ0MsQ0FHakI7O0FBRWY1TCxLQUFDLEdBQUc0TCxNQUFNLENBQUMsQ0FBRCxDQUFWLENBTGdDLENBS2pCOztBQUVmTSxLQUFDLEdBQUdOLE1BQU0sQ0FBQyxDQUFELENBQVYsQ0FQZ0MsQ0FPakI7O0FBRWY1RyxLQUFDLEdBQUdvSixHQUFHLEdBQUd4QyxNQUFNLENBQUMsQ0FBRCxDQUFoQjtBQUNBM0csS0FBQyxHQUFHb0osR0FBRyxHQUFHekMsTUFBTSxDQUFDLENBQUQsQ0FBaEIsQ0FWZ0MsQ0FVWDs7QUFFckIsUUFBSUEsTUFBTSxDQUFDcEgsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUN2QnJELFlBQU0sR0FBR3hDLElBQUksQ0FBQ29RLElBQUwsQ0FBVXJHLENBQUMsR0FBR0EsQ0FBSixHQUFRckksQ0FBQyxHQUFHQSxDQUF0QixDQUFUO0FBQ0FlLFlBQU0sR0FBR3pDLElBQUksQ0FBQ29RLElBQUwsQ0FBVTdDLENBQUMsR0FBR0EsQ0FBSixHQUFRbE0sQ0FBQyxHQUFHQSxDQUF0QixDQUFUO0FBQ0EyTixjQUFRLEdBQUdqRixDQUFDLElBQUlySSxDQUFMLEdBQVN2QixNQUFNLENBQUN1QixDQUFELEVBQUlxSSxDQUFKLENBQU4sR0FBZWhLLFFBQXhCLEdBQW1DLENBQTlDLENBSHVCLENBRzBCOztBQUVqRG9QLFdBQUssR0FBRzlOLENBQUMsSUFBSWtNLENBQUwsR0FBU3BOLE1BQU0sQ0FBQ2tCLENBQUQsRUFBSWtNLENBQUosQ0FBTixHQUFleE4sUUFBZixHQUEwQmlQLFFBQW5DLEdBQThDLENBQXREO0FBQ0FHLFdBQUssS0FBSzFNLE1BQU0sSUFBSXpDLElBQUksQ0FBQ3FRLEdBQUwsQ0FBU3JRLElBQUksQ0FBQ3VQLEdBQUwsQ0FBU0osS0FBSyxHQUFHalAsUUFBakIsQ0FBVCxDQUFmLENBQUw7O0FBRUEsVUFBSXlDLEtBQUssQ0FBQ2lDLEdBQVYsRUFBZTtBQUNieUIsU0FBQyxJQUFJNEgsT0FBTyxJQUFJQSxPQUFPLEdBQUdsRSxDQUFWLEdBQWNvRSxPQUFPLEdBQUc5TSxDQUE1QixDQUFaO0FBQ0FpRixTQUFDLElBQUk2SCxPQUFPLElBQUlGLE9BQU8sR0FBR3ZNLENBQVYsR0FBY3lNLE9BQU8sR0FBR1osQ0FBNUIsQ0FBWjtBQUNELE9BWHNCLENBV3JCOztBQUVILEtBYkQsTUFhTztBQUNMNEMsU0FBRyxHQUFHbEQsTUFBTSxDQUFDLENBQUQsQ0FBWjtBQUNBZ0QsU0FBRyxHQUFHaEQsTUFBTSxDQUFDLENBQUQsQ0FBWjtBQUNBNkMsU0FBRyxHQUFHN0MsTUFBTSxDQUFDLENBQUQsQ0FBWjtBQUNBOEMsU0FBRyxHQUFHOUMsTUFBTSxDQUFDLENBQUQsQ0FBWjtBQUNBK0MsU0FBRyxHQUFHL0MsTUFBTSxDQUFDLEVBQUQsQ0FBWjtBQUNBaUQsU0FBRyxHQUFHakQsTUFBTSxDQUFDLEVBQUQsQ0FBWjtBQUNBNUcsT0FBQyxHQUFHNEcsTUFBTSxDQUFDLEVBQUQsQ0FBVjtBQUNBM0csT0FBQyxHQUFHMkcsTUFBTSxDQUFDLEVBQUQsQ0FBVjtBQUNBOEIsT0FBQyxHQUFHOUIsTUFBTSxDQUFDLEVBQUQsQ0FBVjtBQUNBcUMsV0FBSyxHQUFHblAsTUFBTSxDQUFDZ1EsR0FBRCxFQUFNSCxHQUFOLENBQWQ7QUFDQWYsZUFBUyxHQUFHSyxLQUFLLEdBQUd2UCxRQUFwQixDQVhLLENBV3lCOztBQUU5QixVQUFJdVAsS0FBSixFQUFXO0FBQ1RDLFdBQUcsR0FBR3ZQLElBQUksQ0FBQ3VQLEdBQUwsQ0FBUyxDQUFDRCxLQUFWLENBQU47QUFDQUUsV0FBRyxHQUFHeFAsSUFBSSxDQUFDd1AsR0FBTCxDQUFTLENBQUNGLEtBQVYsQ0FBTjtBQUNBSyxVQUFFLEdBQUdGLEdBQUcsR0FBR0YsR0FBTixHQUFZTyxHQUFHLEdBQUdOLEdBQXZCO0FBQ0FJLFVBQUUsR0FBR0YsR0FBRyxHQUFHSCxHQUFOLEdBQVlRLEdBQUcsR0FBR1AsR0FBdkI7QUFDQUssVUFBRSxHQUFHTSxHQUFHLEdBQUdaLEdBQU4sR0FBWVMsR0FBRyxHQUFHUixHQUF2QjtBQUNBTSxXQUFHLEdBQUdMLEdBQUcsR0FBRyxDQUFDRCxHQUFQLEdBQWFNLEdBQUcsR0FBR1AsR0FBekI7QUFDQVEsV0FBRyxHQUFHTCxHQUFHLEdBQUcsQ0FBQ0YsR0FBUCxHQUFhTyxHQUFHLEdBQUdSLEdBQXpCO0FBQ0FTLFdBQUcsR0FBR0csR0FBRyxHQUFHLENBQUNYLEdBQVAsR0FBYVEsR0FBRyxHQUFHVCxHQUF6QjtBQUNBVyxXQUFHLEdBQUdELEdBQUcsR0FBRyxDQUFDVCxHQUFQLEdBQWFVLEdBQUcsR0FBR1gsR0FBekI7QUFDQUUsV0FBRyxHQUFHRSxFQUFOO0FBQ0FELFdBQUcsR0FBR0UsRUFBTjtBQUNBTyxXQUFHLEdBQUdOLEVBQU47QUFDRCxPQTFCSSxDQTBCSDs7O0FBR0ZQLFdBQUssR0FBR25QLE1BQU0sQ0FBQyxDQUFDa0IsQ0FBRixFQUFLMk8sR0FBTCxDQUFkO0FBQ0FkLGVBQVMsR0FBR0ksS0FBSyxHQUFHdlAsUUFBcEI7O0FBRUEsVUFBSXVQLEtBQUosRUFBVztBQUNUQyxXQUFHLEdBQUd2UCxJQUFJLENBQUN1UCxHQUFMLENBQVMsQ0FBQ0QsS0FBVixDQUFOO0FBQ0FFLFdBQUcsR0FBR3hQLElBQUksQ0FBQ3dQLEdBQUwsQ0FBUyxDQUFDRixLQUFWLENBQU47QUFDQUssVUFBRSxHQUFHNUYsQ0FBQyxHQUFHd0YsR0FBSixHQUFVTyxHQUFHLEdBQUdOLEdBQXJCO0FBQ0FJLFVBQUUsR0FBR2xPLENBQUMsR0FBRzZOLEdBQUosR0FBVVEsR0FBRyxHQUFHUCxHQUFyQjtBQUNBSyxVQUFFLEdBQUd4TyxDQUFDLEdBQUdrTyxHQUFKLEdBQVVTLEdBQUcsR0FBR1IsR0FBckI7QUFDQVUsV0FBRyxHQUFHM0MsQ0FBQyxHQUFHaUMsR0FBSixHQUFVVSxHQUFHLEdBQUdYLEdBQXRCO0FBQ0F4RixTQUFDLEdBQUc0RixFQUFKO0FBQ0FqTyxTQUFDLEdBQUdrTyxFQUFKO0FBQ0F2TyxTQUFDLEdBQUd3TyxFQUFKO0FBQ0QsT0ExQ0ksQ0EwQ0g7OztBQUdGUCxXQUFLLEdBQUduUCxNQUFNLENBQUN1QixDQUFELEVBQUlxSSxDQUFKLENBQWQ7QUFDQWlGLGNBQVEsR0FBR00sS0FBSyxHQUFHdlAsUUFBbkI7O0FBRUEsVUFBSXVQLEtBQUosRUFBVztBQUNUQyxXQUFHLEdBQUd2UCxJQUFJLENBQUN1UCxHQUFMLENBQVNELEtBQVQsQ0FBTjtBQUNBRSxXQUFHLEdBQUd4UCxJQUFJLENBQUN3UCxHQUFMLENBQVNGLEtBQVQsQ0FBTjtBQUNBSyxVQUFFLEdBQUc1RixDQUFDLEdBQUd3RixHQUFKLEdBQVU3TixDQUFDLEdBQUc4TixHQUFuQjtBQUNBSSxVQUFFLEdBQUdILEdBQUcsR0FBR0YsR0FBTixHQUFZRyxHQUFHLEdBQUdGLEdBQXZCO0FBQ0E5TixTQUFDLEdBQUdBLENBQUMsR0FBRzZOLEdBQUosR0FBVXhGLENBQUMsR0FBR3lGLEdBQWxCO0FBQ0FFLFdBQUcsR0FBR0EsR0FBRyxHQUFHSCxHQUFOLEdBQVlFLEdBQUcsR0FBR0QsR0FBeEI7QUFDQXpGLFNBQUMsR0FBRzRGLEVBQUo7QUFDQUYsV0FBRyxHQUFHRyxFQUFOO0FBQ0Q7O0FBRUQsVUFBSVgsU0FBUyxJQUFJalAsSUFBSSxDQUFDcVEsR0FBTCxDQUFTcEIsU0FBVCxJQUFzQmpQLElBQUksQ0FBQ3FRLEdBQUwsQ0FBU3JCLFFBQVQsQ0FBdEIsR0FBMkMsS0FBNUQsRUFBbUU7QUFDakU7QUFDQUMsaUJBQVMsR0FBR0QsUUFBUSxHQUFHLENBQXZCO0FBQ0FFLGlCQUFTLEdBQUcsTUFBTUEsU0FBbEI7QUFDRDs7QUFFRDFNLFlBQU0sR0FBR29HLDREQUFNLENBQUM1SSxJQUFJLENBQUNvUSxJQUFMLENBQVVyRyxDQUFDLEdBQUdBLENBQUosR0FBUXJJLENBQUMsR0FBR0EsQ0FBWixHQUFnQkwsQ0FBQyxHQUFHQSxDQUE5QixDQUFELENBQWY7QUFDQW9CLFlBQU0sR0FBR21HLDREQUFNLENBQUM1SSxJQUFJLENBQUNvUSxJQUFMLENBQVVWLEdBQUcsR0FBR0EsR0FBTixHQUFZUyxHQUFHLEdBQUdBLEdBQTVCLENBQUQsQ0FBZjtBQUNBYixXQUFLLEdBQUduUCxNQUFNLENBQUNzUCxHQUFELEVBQU1DLEdBQU4sQ0FBZDtBQUNBUCxXQUFLLEdBQUduUCxJQUFJLENBQUNxUSxHQUFMLENBQVNmLEtBQVQsSUFBa0IsTUFBbEIsR0FBMkJBLEtBQUssR0FBR3ZQLFFBQW5DLEdBQThDLENBQXREO0FBQ0FzUCxpQkFBVyxHQUFHYSxHQUFHLEdBQUcsS0FBS0EsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFDQSxHQUFYLEdBQWlCQSxHQUF0QixDQUFILEdBQWdDLENBQWpEO0FBQ0Q7O0FBRUQsUUFBSXZOLEtBQUssQ0FBQ2lDLEdBQVYsRUFBZTtBQUNiO0FBQ0ErSyxRQUFFLEdBQUczTixNQUFNLENBQUM4QyxZQUFQLENBQW9CLFdBQXBCLENBQUw7QUFDQW5DLFdBQUssQ0FBQzJOLFFBQU4sR0FBaUJ0TyxNQUFNLENBQUM0TSxZQUFQLENBQW9CLFdBQXBCLEVBQWlDLEVBQWpDLEtBQXdDLENBQUNsQyxnQkFBZ0IsQ0FBQ25KLG9CQUFvQixDQUFDdkIsTUFBRCxFQUFTYyxjQUFULENBQXJCLENBQTFFO0FBQ0E2TSxRQUFFLElBQUkzTixNQUFNLENBQUM0TSxZQUFQLENBQW9CLFdBQXBCLEVBQWlDZSxFQUFqQyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJM1AsSUFBSSxDQUFDcVEsR0FBTCxDQUFTbEIsS0FBVCxJQUFrQixFQUFsQixJQUF3Qm5QLElBQUksQ0FBQ3FRLEdBQUwsQ0FBU2xCLEtBQVQsSUFBa0IsR0FBOUMsRUFBbUQ7QUFDakQsUUFBSUwsY0FBSixFQUFvQjtBQUNsQnRNLFlBQU0sSUFBSSxDQUFDLENBQVg7QUFDQTJNLFdBQUssSUFBSUgsUUFBUSxJQUFJLENBQVosR0FBZ0IsR0FBaEIsR0FBc0IsQ0FBQyxHQUFoQztBQUNBQSxjQUFRLElBQUlBLFFBQVEsSUFBSSxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLENBQUMsR0FBbkM7QUFDRCxLQUpELE1BSU87QUFDTHZNLFlBQU0sSUFBSSxDQUFDLENBQVg7QUFDQTBNLFdBQUssSUFBSUEsS0FBSyxJQUFJLENBQVQsR0FBYSxHQUFiLEdBQW1CLENBQUMsR0FBN0I7QUFDRDtBQUNGOztBQUVEeE0sT0FBSyxDQUFDMEQsQ0FBTixHQUFVQSxDQUFDLElBQUksQ0FBQzFELEtBQUssQ0FBQzROLFFBQU4sR0FBaUJsSyxDQUFDLEtBQUsxRCxLQUFLLENBQUM0TixRQUFOLEtBQW1CdlEsSUFBSSxDQUFDbUIsS0FBTCxDQUFXYSxNQUFNLENBQUN3TyxXQUFQLEdBQXFCLENBQWhDLE1BQXVDeFEsSUFBSSxDQUFDbUIsS0FBTCxDQUFXLENBQUNrRixDQUFaLENBQXZDLEdBQXdELENBQUMsRUFBekQsR0FBOEQsQ0FBakYsQ0FBTCxDQUFuQixJQUFnSHJFLE1BQU0sQ0FBQ3dPLFdBQVAsR0FBcUI3TixLQUFLLENBQUM0TixRQUEzQixHQUFzQyxHQUF0SixHQUE0SixDQUFoSyxDQUFELEdBQXNLL0gsRUFBaEw7QUFDQTdGLE9BQUssQ0FBQzJELENBQU4sR0FBVUEsQ0FBQyxJQUFJLENBQUMzRCxLQUFLLENBQUM4TixRQUFOLEdBQWlCbkssQ0FBQyxLQUFLM0QsS0FBSyxDQUFDOE4sUUFBTixLQUFtQnpRLElBQUksQ0FBQ21CLEtBQUwsQ0FBV2EsTUFBTSxDQUFDME8sWUFBUCxHQUFzQixDQUFqQyxNQUF3QzFRLElBQUksQ0FBQ21CLEtBQUwsQ0FBVyxDQUFDbUYsQ0FBWixDQUF4QyxHQUF5RCxDQUFDLEVBQTFELEdBQStELENBQWxGLENBQUwsQ0FBbkIsSUFBaUh0RSxNQUFNLENBQUMwTyxZQUFQLEdBQXNCL04sS0FBSyxDQUFDOE4sUUFBNUIsR0FBdUMsR0FBeEosR0FBOEosQ0FBbEssQ0FBRCxHQUF3S2pJLEVBQWxMO0FBQ0E3RixPQUFLLENBQUNvTSxDQUFOLEdBQVVBLENBQUMsR0FBR3ZHLEVBQWQ7QUFDQTdGLE9BQUssQ0FBQ0gsTUFBTixHQUFlb0csNERBQU0sQ0FBQ3BHLE1BQUQsQ0FBckI7QUFDQUcsT0FBSyxDQUFDRixNQUFOLEdBQWVtRyw0REFBTSxDQUFDbkcsTUFBRCxDQUFyQjtBQUNBRSxPQUFLLENBQUNxTSxRQUFOLEdBQWlCcEcsNERBQU0sQ0FBQ29HLFFBQUQsQ0FBTixHQUFtQnpILEdBQXBDO0FBQ0E1RSxPQUFLLENBQUNzTSxTQUFOLEdBQWtCckcsNERBQU0sQ0FBQ3FHLFNBQUQsQ0FBTixHQUFvQjFILEdBQXRDO0FBQ0E1RSxPQUFLLENBQUN1TSxTQUFOLEdBQWtCdEcsNERBQU0sQ0FBQ3NHLFNBQUQsQ0FBTixHQUFvQjNILEdBQXRDO0FBQ0E1RSxPQUFLLENBQUN3TSxLQUFOLEdBQWNBLEtBQUssR0FBRzVILEdBQXRCO0FBQ0E1RSxPQUFLLENBQUN5TSxLQUFOLEdBQWNBLEtBQUssR0FBRzdILEdBQXRCO0FBQ0E1RSxPQUFLLENBQUNnTyxvQkFBTixHQUE2QnRCLFdBQVcsR0FBRzdHLEVBQTNDOztBQUVBLE1BQUk3RixLQUFLLENBQUMyRyxPQUFOLEdBQWdCekIsVUFBVSxDQUFDOEYsTUFBTSxDQUFDNUosS0FBUCxDQUFhLEdBQWIsRUFBa0IsQ0FBbEIsQ0FBRCxDQUFWLElBQW9DLENBQXhELEVBQTJEO0FBQ3pEN0IsU0FBSyxDQUFDYSxvQkFBRCxDQUFMLEdBQThCc0csYUFBYSxDQUFDc0UsTUFBRCxDQUEzQztBQUNEOztBQUVEaEwsT0FBSyxDQUFDMEwsT0FBTixHQUFnQjFMLEtBQUssQ0FBQzRMLE9BQU4sR0FBZ0IsQ0FBaEM7QUFDQTVMLE9BQUssQ0FBQ2lPLE9BQU4sR0FBZ0IxRixxREFBTyxDQUFDMEYsT0FBeEI7QUFDQWpPLE9BQUssQ0FBQ0MsZUFBTixHQUF3QkQsS0FBSyxDQUFDaUMsR0FBTixHQUFZaU0sb0JBQVosR0FBbUM3TixXQUFXLEdBQUc4TixvQkFBSCxHQUEwQkMsc0JBQWhHO0FBQ0FwTyxPQUFLLENBQUN3RyxPQUFOLEdBQWdCLENBQWhCO0FBQ0EsU0FBT3hHLEtBQVA7QUFDRCxDQXoyQkQ7QUFBQSxJQTAyQkkwRyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QnpILEtBQXZCLEVBQThCO0FBQ2hELFNBQU8sQ0FBQ0EsS0FBSyxHQUFHQSxLQUFLLENBQUNtQyxLQUFOLENBQVksR0FBWixDQUFULEVBQTJCLENBQTNCLElBQWdDLEdBQWhDLEdBQXNDbkMsS0FBSyxDQUFDLENBQUQsQ0FBbEQ7QUFDRCxDQTUyQkQ7QUFBQSxJQTYyQkk7QUFDSm9QLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCaFAsTUFBekIsRUFBaUMySCxLQUFqQyxFQUF3Qy9ILEtBQXhDLEVBQStDO0FBQy9ELE1BQUkrRixJQUFJLEdBQUdzSiw2REFBTyxDQUFDdEgsS0FBRCxDQUFsQjtBQUNBLFNBQU9mLDREQUFNLENBQUNmLFVBQVUsQ0FBQzhCLEtBQUQsQ0FBVixHQUFvQjlCLFVBQVUsQ0FBQ0gsY0FBYyxDQUFDMUYsTUFBRCxFQUFTLEdBQVQsRUFBY0osS0FBSyxHQUFHLElBQXRCLEVBQTRCK0YsSUFBNUIsQ0FBZixDQUEvQixDQUFOLEdBQTBGQSxJQUFqRztBQUNELENBajNCRDtBQUFBLElBazNCSW9KLHNCQUFzQixHQUFHLFNBQVNBLHNCQUFULENBQWdDalEsS0FBaEMsRUFBdUM2QixLQUF2QyxFQUE4QztBQUN6RUEsT0FBSyxDQUFDb00sQ0FBTixHQUFVLEtBQVY7QUFDQXBNLE9BQUssQ0FBQ3VNLFNBQU4sR0FBa0J2TSxLQUFLLENBQUNzTSxTQUFOLEdBQWtCLE1BQXBDO0FBQ0F0TSxPQUFLLENBQUNpTyxPQUFOLEdBQWdCLENBQWhCOztBQUVBRSxzQkFBb0IsQ0FBQ2hRLEtBQUQsRUFBUTZCLEtBQVIsQ0FBcEI7QUFDRCxDQXgzQkQ7QUFBQSxJQXkzQkl1TyxRQUFRLEdBQUcsTUF6M0JmO0FBQUEsSUEwM0JJQyxPQUFPLEdBQUcsS0ExM0JkO0FBQUEsSUEyM0JJQyxlQUFlLEdBQUcsSUEzM0J0QjtBQUFBLElBNDNCSU4sb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEJoUSxLQUE5QixFQUFxQzZCLEtBQXJDLEVBQTRDO0FBQ3JFLE1BQUkwTyxJQUFJLEdBQUcxTyxLQUFLLElBQUksSUFBcEI7QUFBQSxNQUNJNE4sUUFBUSxHQUFHYyxJQUFJLENBQUNkLFFBRHBCO0FBQUEsTUFFSUUsUUFBUSxHQUFHWSxJQUFJLENBQUNaLFFBRnBCO0FBQUEsTUFHSXBLLENBQUMsR0FBR2dMLElBQUksQ0FBQ2hMLENBSGI7QUFBQSxNQUlJQyxDQUFDLEdBQUcrSyxJQUFJLENBQUMvSyxDQUpiO0FBQUEsTUFLSXlJLENBQUMsR0FBR3NDLElBQUksQ0FBQ3RDLENBTGI7QUFBQSxNQU1JQyxRQUFRLEdBQUdxQyxJQUFJLENBQUNyQyxRQU5wQjtBQUFBLE1BT0lFLFNBQVMsR0FBR21DLElBQUksQ0FBQ25DLFNBUHJCO0FBQUEsTUFRSUQsU0FBUyxHQUFHb0MsSUFBSSxDQUFDcEMsU0FSckI7QUFBQSxNQVNJRSxLQUFLLEdBQUdrQyxJQUFJLENBQUNsQyxLQVRqQjtBQUFBLE1BVUlDLEtBQUssR0FBR2lDLElBQUksQ0FBQ2pDLEtBVmpCO0FBQUEsTUFXSTVNLE1BQU0sR0FBRzZPLElBQUksQ0FBQzdPLE1BWGxCO0FBQUEsTUFZSUMsTUFBTSxHQUFHNE8sSUFBSSxDQUFDNU8sTUFabEI7QUFBQSxNQWFJa08sb0JBQW9CLEdBQUdVLElBQUksQ0FBQ1Ysb0JBYmhDO0FBQUEsTUFjSUMsT0FBTyxHQUFHUyxJQUFJLENBQUNULE9BZG5CO0FBQUEsTUFlSTVPLE1BQU0sR0FBR3FQLElBQUksQ0FBQ3JQLE1BZmxCO0FBQUEsTUFnQklzSCxPQUFPLEdBQUcrSCxJQUFJLENBQUMvSCxPQWhCbkI7QUFBQSxNQWlCSWdJLFVBQVUsR0FBRyxFQWpCakI7QUFBQSxNQWtCSUMsS0FBSyxHQUFHWCxPQUFPLEtBQUssTUFBWixJQUFzQjlQLEtBQXRCLElBQStCQSxLQUFLLEtBQUssQ0FBekMsSUFBOEM4UCxPQUFPLEtBQUssSUFsQnRFLENBRHFFLENBbUJPOzs7QUFHNUUsTUFBSXRILE9BQU8sS0FBSzJGLFNBQVMsS0FBS2lDLFFBQWQsSUFBMEJoQyxTQUFTLEtBQUtnQyxRQUE3QyxDQUFYLEVBQW1FO0FBQ2pFLFFBQUk1QixLQUFLLEdBQUd6SCxVQUFVLENBQUNxSCxTQUFELENBQVYsR0FBd0JoUCxRQUFwQztBQUFBLFFBQ0k0UCxHQUFHLEdBQUc5UCxJQUFJLENBQUN3UCxHQUFMLENBQVNGLEtBQVQsQ0FEVjtBQUFBLFFBRUlVLEdBQUcsR0FBR2hRLElBQUksQ0FBQ3VQLEdBQUwsQ0FBU0QsS0FBVCxDQUZWO0FBQUEsUUFHSUMsR0FISjs7QUFLQUQsU0FBSyxHQUFHekgsVUFBVSxDQUFDb0gsU0FBRCxDQUFWLEdBQXdCL08sUUFBaEM7QUFDQXFQLE9BQUcsR0FBR3ZQLElBQUksQ0FBQ3VQLEdBQUwsQ0FBU0QsS0FBVCxDQUFOO0FBQ0FqSixLQUFDLEdBQUcySyxlQUFlLENBQUNoUCxNQUFELEVBQVNxRSxDQUFULEVBQVl5SixHQUFHLEdBQUdQLEdBQU4sR0FBWSxDQUFDakcsT0FBekIsQ0FBbkI7QUFDQWhELEtBQUMsR0FBRzBLLGVBQWUsQ0FBQ2hQLE1BQUQsRUFBU3NFLENBQVQsRUFBWSxDQUFDdEcsSUFBSSxDQUFDd1AsR0FBTCxDQUFTRixLQUFULENBQUQsR0FBbUIsQ0FBQ2hHLE9BQWhDLENBQW5CO0FBQ0F5RixLQUFDLEdBQUdpQyxlQUFlLENBQUNoUCxNQUFELEVBQVMrTSxDQUFULEVBQVlpQixHQUFHLEdBQUdULEdBQU4sR0FBWSxDQUFDakcsT0FBYixHQUF1QkEsT0FBbkMsQ0FBbkI7QUFDRDs7QUFFRCxNQUFJcUgsb0JBQW9CLEtBQUtRLE9BQTdCLEVBQXNDO0FBQ3BDRyxjQUFVLElBQUksaUJBQWlCWCxvQkFBakIsR0FBd0NTLGVBQXREO0FBQ0Q7O0FBRUQsTUFBSWIsUUFBUSxJQUFJRSxRQUFoQixFQUEwQjtBQUN4QmEsY0FBVSxJQUFJLGVBQWVmLFFBQWYsR0FBMEIsS0FBMUIsR0FBa0NFLFFBQWxDLEdBQTZDLEtBQTNEO0FBQ0Q7O0FBRUQsTUFBSWMsS0FBSyxJQUFJbEwsQ0FBQyxLQUFLOEssT0FBZixJQUEwQjdLLENBQUMsS0FBSzZLLE9BQWhDLElBQTJDcEMsQ0FBQyxLQUFLb0MsT0FBckQsRUFBOEQ7QUFDNURHLGNBQVUsSUFBSXZDLENBQUMsS0FBS29DLE9BQU4sSUFBaUJJLEtBQWpCLEdBQXlCLGlCQUFpQmxMLENBQWpCLEdBQXFCLElBQXJCLEdBQTRCQyxDQUE1QixHQUFnQyxJQUFoQyxHQUF1Q3lJLENBQXZDLEdBQTJDLElBQXBFLEdBQTJFLGVBQWUxSSxDQUFmLEdBQW1CLElBQW5CLEdBQTBCQyxDQUExQixHQUE4QjhLLGVBQXZIO0FBQ0Q7O0FBRUQsTUFBSXBDLFFBQVEsS0FBS2tDLFFBQWpCLEVBQTJCO0FBQ3pCSSxjQUFVLElBQUksWUFBWXRDLFFBQVosR0FBdUJvQyxlQUFyQztBQUNEOztBQUVELE1BQUlsQyxTQUFTLEtBQUtnQyxRQUFsQixFQUE0QjtBQUMxQkksY0FBVSxJQUFJLGFBQWFwQyxTQUFiLEdBQXlCa0MsZUFBdkM7QUFDRDs7QUFFRCxNQUFJbkMsU0FBUyxLQUFLaUMsUUFBbEIsRUFBNEI7QUFDMUJJLGNBQVUsSUFBSSxhQUFhckMsU0FBYixHQUF5Qm1DLGVBQXZDO0FBQ0Q7O0FBRUQsTUFBSWpDLEtBQUssS0FBSytCLFFBQVYsSUFBc0I5QixLQUFLLEtBQUs4QixRQUFwQyxFQUE4QztBQUM1Q0ksY0FBVSxJQUFJLFVBQVVuQyxLQUFWLEdBQWtCLElBQWxCLEdBQXlCQyxLQUF6QixHQUFpQ2dDLGVBQS9DO0FBQ0Q7O0FBRUQsTUFBSTVPLE1BQU0sS0FBSyxDQUFYLElBQWdCQyxNQUFNLEtBQUssQ0FBL0IsRUFBa0M7QUFDaEM2TyxjQUFVLElBQUksV0FBVzlPLE1BQVgsR0FBb0IsSUFBcEIsR0FBMkJDLE1BQTNCLEdBQW9DMk8sZUFBbEQ7QUFDRDs7QUFFRHBQLFFBQU0sQ0FBQ0UsS0FBUCxDQUFhWSxjQUFiLElBQStCd08sVUFBVSxJQUFJLGlCQUE3QztBQUNELENBaDhCRDtBQUFBLElBaThCSVQsb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEIvUCxLQUE5QixFQUFxQzZCLEtBQXJDLEVBQTRDO0FBQ3JFLE1BQUk2TyxLQUFLLEdBQUc3TyxLQUFLLElBQUksSUFBckI7QUFBQSxNQUNJNE4sUUFBUSxHQUFHaUIsS0FBSyxDQUFDakIsUUFEckI7QUFBQSxNQUVJRSxRQUFRLEdBQUdlLEtBQUssQ0FBQ2YsUUFGckI7QUFBQSxNQUdJcEssQ0FBQyxHQUFHbUwsS0FBSyxDQUFDbkwsQ0FIZDtBQUFBLE1BSUlDLENBQUMsR0FBR2tMLEtBQUssQ0FBQ2xMLENBSmQ7QUFBQSxNQUtJMEksUUFBUSxHQUFHd0MsS0FBSyxDQUFDeEMsUUFMckI7QUFBQSxNQU1JRyxLQUFLLEdBQUdxQyxLQUFLLENBQUNyQyxLQU5sQjtBQUFBLE1BT0lDLEtBQUssR0FBR29DLEtBQUssQ0FBQ3BDLEtBUGxCO0FBQUEsTUFRSTVNLE1BQU0sR0FBR2dQLEtBQUssQ0FBQ2hQLE1BUm5CO0FBQUEsTUFTSUMsTUFBTSxHQUFHK08sS0FBSyxDQUFDL08sTUFUbkI7QUFBQSxNQVVJVCxNQUFNLEdBQUd3UCxLQUFLLENBQUN4UCxNQVZuQjtBQUFBLE1BV0lpTSxPQUFPLEdBQUd1RCxLQUFLLENBQUN2RCxPQVhwQjtBQUFBLE1BWUlFLE9BQU8sR0FBR3FELEtBQUssQ0FBQ3JELE9BWnBCO0FBQUEsTUFhSUUsT0FBTyxHQUFHbUQsS0FBSyxDQUFDbkQsT0FicEI7QUFBQSxNQWNJRSxPQUFPLEdBQUdpRCxLQUFLLENBQUNqRCxPQWRwQjtBQUFBLE1BZUkrQixRQUFRLEdBQUdrQixLQUFLLENBQUNsQixRQWZyQjtBQUFBLE1BZ0JJOUIsRUFBRSxHQUFHM0csVUFBVSxDQUFDeEIsQ0FBRCxDQWhCbkI7QUFBQSxNQWlCSW9JLEVBQUUsR0FBRzVHLFVBQVUsQ0FBQ3ZCLENBQUQsQ0FqQm5CO0FBQUEsTUFrQkltTCxHQWxCSjtBQUFBLE1BbUJJQyxHQW5CSjtBQUFBLE1Bb0JJakMsR0FwQko7QUFBQSxNQXFCSUMsR0FyQko7QUFBQSxNQXNCSXhDLElBdEJKOztBQXdCQThCLFVBQVEsR0FBR25ILFVBQVUsQ0FBQ21ILFFBQUQsQ0FBckI7QUFDQUcsT0FBSyxHQUFHdEgsVUFBVSxDQUFDc0gsS0FBRCxDQUFsQjtBQUNBQyxPQUFLLEdBQUd2SCxVQUFVLENBQUN1SCxLQUFELENBQWxCOztBQUVBLE1BQUlBLEtBQUosRUFBVztBQUNUO0FBQ0FBLFNBQUssR0FBR3ZILFVBQVUsQ0FBQ3VILEtBQUQsQ0FBbEI7QUFDQUQsU0FBSyxJQUFJQyxLQUFUO0FBQ0FKLFlBQVEsSUFBSUksS0FBWjtBQUNEOztBQUVELE1BQUlKLFFBQVEsSUFBSUcsS0FBaEIsRUFBdUI7QUFDckJILFlBQVEsSUFBSTlPLFFBQVo7QUFDQWlQLFNBQUssSUFBSWpQLFFBQVQ7QUFDQXVSLE9BQUcsR0FBR3pSLElBQUksQ0FBQ3VQLEdBQUwsQ0FBU1AsUUFBVCxJQUFxQnhNLE1BQTNCO0FBQ0FrUCxPQUFHLEdBQUcxUixJQUFJLENBQUN3UCxHQUFMLENBQVNSLFFBQVQsSUFBcUJ4TSxNQUEzQjtBQUNBaU4sT0FBRyxHQUFHelAsSUFBSSxDQUFDd1AsR0FBTCxDQUFTUixRQUFRLEdBQUdHLEtBQXBCLElBQTZCLENBQUMxTSxNQUFwQztBQUNBaU4sT0FBRyxHQUFHMVAsSUFBSSxDQUFDdVAsR0FBTCxDQUFTUCxRQUFRLEdBQUdHLEtBQXBCLElBQTZCMU0sTUFBbkM7O0FBRUEsUUFBSTBNLEtBQUosRUFBVztBQUNUQyxXQUFLLElBQUlsUCxRQUFUO0FBQ0FnTixVQUFJLEdBQUdsTixJQUFJLENBQUMyUixHQUFMLENBQVN4QyxLQUFLLEdBQUdDLEtBQWpCLENBQVA7QUFDQWxDLFVBQUksR0FBR2xOLElBQUksQ0FBQ29RLElBQUwsQ0FBVSxJQUFJbEQsSUFBSSxHQUFHQSxJQUFyQixDQUFQO0FBQ0F1QyxTQUFHLElBQUl2QyxJQUFQO0FBQ0F3QyxTQUFHLElBQUl4QyxJQUFQOztBQUVBLFVBQUlrQyxLQUFKLEVBQVc7QUFDVGxDLFlBQUksR0FBR2xOLElBQUksQ0FBQzJSLEdBQUwsQ0FBU3ZDLEtBQVQsQ0FBUDtBQUNBbEMsWUFBSSxHQUFHbE4sSUFBSSxDQUFDb1EsSUFBTCxDQUFVLElBQUlsRCxJQUFJLEdBQUdBLElBQXJCLENBQVA7QUFDQXVFLFdBQUcsSUFBSXZFLElBQVA7QUFDQXdFLFdBQUcsSUFBSXhFLElBQVA7QUFDRDtBQUNGOztBQUVEdUUsT0FBRyxHQUFHN0ksNERBQU0sQ0FBQzZJLEdBQUQsQ0FBWjtBQUNBQyxPQUFHLEdBQUc5SSw0REFBTSxDQUFDOEksR0FBRCxDQUFaO0FBQ0FqQyxPQUFHLEdBQUc3Ryw0REFBTSxDQUFDNkcsR0FBRCxDQUFaO0FBQ0FDLE9BQUcsR0FBRzlHLDREQUFNLENBQUM4RyxHQUFELENBQVo7QUFDRCxHQTNCRCxNQTJCTztBQUNMK0IsT0FBRyxHQUFHalAsTUFBTjtBQUNBa04sT0FBRyxHQUFHak4sTUFBTjtBQUNBaVAsT0FBRyxHQUFHakMsR0FBRyxHQUFHLENBQVo7QUFDRDs7QUFFRCxNQUFJakIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDbkksQ0FBQyxHQUFHLEVBQUwsRUFBU3NDLE9BQVQsQ0FBaUIsSUFBakIsQ0FBUixJQUFrQzhGLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQ25JLENBQUMsR0FBRyxFQUFMLEVBQVNxQyxPQUFULENBQWlCLElBQWpCLENBQTlDLEVBQXNFO0FBQ3BFNkYsTUFBRSxHQUFHOUcsY0FBYyxDQUFDMUYsTUFBRCxFQUFTLEdBQVQsRUFBY3FFLENBQWQsRUFBaUIsSUFBakIsQ0FBbkI7QUFDQW9JLE1BQUUsR0FBRy9HLGNBQWMsQ0FBQzFGLE1BQUQsRUFBUyxHQUFULEVBQWNzRSxDQUFkLEVBQWlCLElBQWpCLENBQW5CO0FBQ0Q7O0FBRUQsTUFBSTJILE9BQU8sSUFBSUUsT0FBWCxJQUFzQkUsT0FBdEIsSUFBaUNFLE9BQXJDLEVBQThDO0FBQzVDQyxNQUFFLEdBQUc1Riw0REFBTSxDQUFDNEYsRUFBRSxHQUFHUCxPQUFMLElBQWdCQSxPQUFPLEdBQUd3RCxHQUFWLEdBQWdCdEQsT0FBTyxHQUFHc0IsR0FBMUMsSUFBaURwQixPQUFsRCxDQUFYO0FBQ0FJLE1BQUUsR0FBRzdGLDREQUFNLENBQUM2RixFQUFFLEdBQUdOLE9BQUwsSUFBZ0JGLE9BQU8sR0FBR3lELEdBQVYsR0FBZ0J2RCxPQUFPLEdBQUd1QixHQUExQyxJQUFpRG5CLE9BQWxELENBQVg7QUFDRDs7QUFFRCxNQUFJZ0MsUUFBUSxJQUFJRSxRQUFoQixFQUEwQjtBQUN4QjtBQUNBdkQsUUFBSSxHQUFHbEwsTUFBTSxDQUFDdUQsT0FBUCxFQUFQO0FBQ0FpSixNQUFFLEdBQUc1Riw0REFBTSxDQUFDNEYsRUFBRSxHQUFHK0IsUUFBUSxHQUFHLEdBQVgsR0FBaUJyRCxJQUFJLENBQUMvRyxLQUE1QixDQUFYO0FBQ0FzSSxNQUFFLEdBQUc3Riw0REFBTSxDQUFDNkYsRUFBRSxHQUFHZ0MsUUFBUSxHQUFHLEdBQVgsR0FBaUJ2RCxJQUFJLENBQUM5RyxNQUE1QixDQUFYO0FBQ0Q7O0FBRUQ4RyxNQUFJLEdBQUcsWUFBWXVFLEdBQVosR0FBa0IsR0FBbEIsR0FBd0JDLEdBQXhCLEdBQThCLEdBQTlCLEdBQW9DakMsR0FBcEMsR0FBMEMsR0FBMUMsR0FBZ0RDLEdBQWhELEdBQXNELEdBQXRELEdBQTREbEIsRUFBNUQsR0FBaUUsR0FBakUsR0FBdUVDLEVBQXZFLEdBQTRFLEdBQW5GO0FBQ0F6TSxRQUFNLENBQUM0TSxZQUFQLENBQW9CLFdBQXBCLEVBQWlDMUIsSUFBakM7QUFDQW9ELFVBQVEsS0FBS3RPLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhWSxjQUFiLElBQStCb0ssSUFBcEMsQ0FBUixDQXhGcUUsQ0F3RmxCO0FBQ3BELENBMWhDRDtBQUFBLElBMmhDSTBFLHVCQUF1QixHQUFHLFNBQVNBLHVCQUFULENBQWlDL0ssTUFBakMsRUFBeUM3RSxNQUF6QyxFQUFpREMsUUFBakQsRUFBMkRpSSxRQUEzRCxFQUFxRUcsUUFBckUsRUFBK0VLLFFBQS9FLEVBQXlGO0FBQ3JILE1BQUltSCxHQUFHLEdBQUcsR0FBVjtBQUFBLE1BQ0lDLFFBQVEsR0FBR0MsK0RBQVMsQ0FBQzFILFFBQUQsQ0FEeEI7QUFBQSxNQUVJQyxNQUFNLEdBQUd6QyxVQUFVLENBQUN3QyxRQUFELENBQVYsSUFBd0J5SCxRQUFRLElBQUksQ0FBQ3pILFFBQVEsQ0FBQzFCLE9BQVQsQ0FBaUIsS0FBakIsQ0FBYixHQUF1QzVJLFFBQXZDLEdBQWtELENBQTFFLENBRmI7QUFBQSxNQUdJaVMsTUFBTSxHQUFHdEgsUUFBUSxHQUFHSixNQUFNLEdBQUdJLFFBQVosR0FBdUJKLE1BQU0sR0FBR0osUUFIckQ7QUFBQSxNQUlJK0gsVUFBVSxHQUFHL0gsUUFBUSxHQUFHOEgsTUFBWCxHQUFvQixLQUpyQztBQUFBLE1BS0lFLFNBTEo7QUFBQSxNQU1JakwsRUFOSjs7QUFRQSxNQUFJNkssUUFBSixFQUFjO0FBQ1pJLGFBQVMsR0FBRzdILFFBQVEsQ0FBQ3RHLEtBQVQsQ0FBZSxHQUFmLEVBQW9CLENBQXBCLENBQVo7O0FBRUEsUUFBSW1PLFNBQVMsS0FBSyxPQUFsQixFQUEyQjtBQUN6QkYsWUFBTSxJQUFJSCxHQUFWOztBQUVBLFVBQUlHLE1BQU0sS0FBS0EsTUFBTSxJQUFJSCxHQUFHLEdBQUcsQ0FBVixDQUFyQixFQUFtQztBQUNqQ0csY0FBTSxJQUFJQSxNQUFNLEdBQUcsQ0FBVCxHQUFhSCxHQUFiLEdBQW1CLENBQUNBLEdBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJSyxTQUFTLEtBQUssSUFBZCxJQUFzQkYsTUFBTSxHQUFHLENBQW5DLEVBQXNDO0FBQ3BDQSxZQUFNLEdBQUcsQ0FBQ0EsTUFBTSxHQUFHSCxHQUFHLEdBQUd4UixPQUFoQixJQUEyQndSLEdBQTNCLEdBQWlDLENBQUMsRUFBRUcsTUFBTSxHQUFHSCxHQUFYLENBQUQsR0FBbUJBLEdBQTdEO0FBQ0QsS0FGRCxNQUVPLElBQUlLLFNBQVMsS0FBSyxLQUFkLElBQXVCRixNQUFNLEdBQUcsQ0FBcEMsRUFBdUM7QUFDNUNBLFlBQU0sR0FBRyxDQUFDQSxNQUFNLEdBQUdILEdBQUcsR0FBR3hSLE9BQWhCLElBQTJCd1IsR0FBM0IsR0FBaUMsQ0FBQyxFQUFFRyxNQUFNLEdBQUdILEdBQVgsQ0FBRCxHQUFtQkEsR0FBN0Q7QUFDRDtBQUNGOztBQUVEaEwsUUFBTSxDQUFDTSxHQUFQLEdBQWFGLEVBQUUsR0FBRyxJQUFJQyx1REFBSixDQUFjTCxNQUFNLENBQUNNLEdBQXJCLEVBQTBCbkYsTUFBMUIsRUFBa0NDLFFBQWxDLEVBQTRDaUksUUFBNUMsRUFBc0Q4SCxNQUF0RCxFQUE4RHpRLGtCQUE5RCxDQUFsQjtBQUNBMEYsSUFBRSxDQUFDekYsQ0FBSCxHQUFPeVEsVUFBUDtBQUNBaEwsSUFBRSxDQUFDM0YsQ0FBSCxHQUFPLEtBQVA7O0FBRUF1RixRQUFNLENBQUNPLE1BQVAsQ0FBY0MsSUFBZCxDQUFtQnBGLFFBQW5COztBQUVBLFNBQU9nRixFQUFQO0FBQ0QsQ0E3akNEO0FBQUEsSUE4akNJa0wsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJuUSxNQUFqQixFQUF5Qm9RLE1BQXpCLEVBQWlDO0FBQzdDO0FBQ0EsT0FBSyxJQUFJbFIsQ0FBVCxJQUFja1IsTUFBZCxFQUFzQjtBQUNwQnBRLFVBQU0sQ0FBQ2QsQ0FBRCxDQUFOLEdBQVlrUixNQUFNLENBQUNsUixDQUFELENBQWxCO0FBQ0Q7O0FBRUQsU0FBT2MsTUFBUDtBQUNELENBcmtDRDtBQUFBLElBc2tDSXFRLG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULENBQTZCeEwsTUFBN0IsRUFBcUN5SyxVQUFyQyxFQUFpRHRQLE1BQWpELEVBQXlEO0FBQ2pGO0FBQ0EsTUFBSXNRLFVBQVUsR0FBR0gsT0FBTyxDQUFDLEVBQUQsRUFBS25RLE1BQU0sQ0FBQ00sS0FBWixDQUF4QjtBQUFBLE1BQ0lpUSxPQUFPLEdBQUcsK0NBRGQ7QUFBQSxNQUVJclEsS0FBSyxHQUFHRixNQUFNLENBQUNFLEtBRm5CO0FBQUEsTUFHSXNRLFFBSEo7QUFBQSxNQUlJdFIsQ0FKSjtBQUFBLE1BS0lrSixVQUxKO0FBQUEsTUFNSUMsUUFOSjtBQUFBLE1BT0lILFFBUEo7QUFBQSxNQVFJSSxNQVJKO0FBQUEsTUFTSUcsU0FUSjtBQUFBLE1BVUlELE9BVko7O0FBWUEsTUFBSThILFVBQVUsQ0FBQzFOLEdBQWYsRUFBb0I7QUFDbEJ3RixjQUFVLEdBQUdwSSxNQUFNLENBQUM4QyxZQUFQLENBQW9CLFdBQXBCLENBQWI7QUFDQTlDLFVBQU0sQ0FBQzRNLFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUMsRUFBakM7QUFDQTFNLFNBQUssQ0FBQ1ksY0FBRCxDQUFMLEdBQXdCd08sVUFBeEI7QUFDQWtCLFlBQVEsR0FBR3BKLGVBQWUsQ0FBQ3BILE1BQUQsRUFBUyxDQUFULENBQTFCOztBQUVBeUUsbUJBQWUsQ0FBQ3pFLE1BQUQsRUFBU2MsY0FBVCxDQUFmOztBQUVBZCxVQUFNLENBQUM0TSxZQUFQLENBQW9CLFdBQXBCLEVBQWlDeEUsVUFBakM7QUFDRCxHQVRELE1BU087QUFDTEEsY0FBVSxHQUFHMUcsZ0JBQWdCLENBQUMxQixNQUFELENBQWhCLENBQXlCYyxjQUF6QixDQUFiO0FBQ0FaLFNBQUssQ0FBQ1ksY0FBRCxDQUFMLEdBQXdCd08sVUFBeEI7QUFDQWtCLFlBQVEsR0FBR3BKLGVBQWUsQ0FBQ3BILE1BQUQsRUFBUyxDQUFULENBQTFCO0FBQ0FFLFNBQUssQ0FBQ1ksY0FBRCxDQUFMLEdBQXdCc0gsVUFBeEI7QUFDRDs7QUFFRCxPQUFLbEosQ0FBTCxJQUFVcEIsZUFBVixFQUEyQjtBQUN6QnNLLGNBQVUsR0FBR2tJLFVBQVUsQ0FBQ3BSLENBQUQsQ0FBdkI7QUFDQW1KLFlBQVEsR0FBR21JLFFBQVEsQ0FBQ3RSLENBQUQsQ0FBbkI7O0FBRUEsUUFBSWtKLFVBQVUsS0FBS0MsUUFBZixJQUEyQmtJLE9BQU8sQ0FBQzVKLE9BQVIsQ0FBZ0J6SCxDQUFoQixJQUFxQixDQUFwRCxFQUF1RDtBQUNyRDtBQUNBdUosZUFBUyxHQUFHd0csNkRBQU8sQ0FBQzdHLFVBQUQsQ0FBbkI7QUFDQUksYUFBTyxHQUFHeUcsNkRBQU8sQ0FBQzVHLFFBQUQsQ0FBakI7QUFDQUgsY0FBUSxHQUFHTyxTQUFTLEtBQUtELE9BQWQsR0FBd0I5QyxjQUFjLENBQUMxRixNQUFELEVBQVNkLENBQVQsRUFBWWtKLFVBQVosRUFBd0JJLE9BQXhCLENBQXRDLEdBQXlFM0MsVUFBVSxDQUFDdUMsVUFBRCxDQUE5RjtBQUNBRSxZQUFNLEdBQUd6QyxVQUFVLENBQUN3QyxRQUFELENBQW5CO0FBQ0F4RCxZQUFNLENBQUNNLEdBQVAsR0FBYSxJQUFJRCx1REFBSixDQUFjTCxNQUFNLENBQUNNLEdBQXJCLEVBQTBCcUwsUUFBMUIsRUFBb0N0UixDQUFwQyxFQUF1Q2dKLFFBQXZDLEVBQWlESSxNQUFNLEdBQUdKLFFBQTFELEVBQW9FckosY0FBcEUsQ0FBYjtBQUNBZ0csWUFBTSxDQUFDTSxHQUFQLENBQVc3RixDQUFYLEdBQWVrSixPQUFPLElBQUksQ0FBMUI7O0FBRUEzRCxZQUFNLENBQUNPLE1BQVAsQ0FBY0MsSUFBZCxDQUFtQm5HLENBQW5CO0FBQ0Q7QUFDRjs7QUFFRGlSLFNBQU8sQ0FBQ0ssUUFBRCxFQUFXRixVQUFYLENBQVA7QUFDRCxDQXRuQ0QsQyxDQXNuQ0c7OztBQUdIRyxrRUFBWSxDQUFDLDZCQUFELEVBQWdDLFVBQVVDLElBQVYsRUFBZ0I3SSxLQUFoQixFQUF1QjtBQUNqRSxNQUFJNUksQ0FBQyxHQUFHLEtBQVI7QUFBQSxNQUNJcUssQ0FBQyxHQUFHLE9BRFI7QUFBQSxNQUVJNUosQ0FBQyxHQUFHLFFBRlI7QUFBQSxNQUdJaVIsQ0FBQyxHQUFHLE1BSFI7QUFBQSxNQUlJdkcsS0FBSyxHQUFHLENBQUN2QyxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQUM1SSxDQUFELEVBQUlxSyxDQUFKLEVBQU81SixDQUFQLEVBQVVpUixDQUFWLENBQVosR0FBMkIsQ0FBQzFSLENBQUMsR0FBRzBSLENBQUwsRUFBUTFSLENBQUMsR0FBR3FLLENBQVosRUFBZTVKLENBQUMsR0FBRzRKLENBQW5CLEVBQXNCNUosQ0FBQyxHQUFHaVIsQ0FBMUIsQ0FBNUIsRUFBMEQ3RixHQUExRCxDQUE4RCxVQUFVOEYsSUFBVixFQUFnQjtBQUN4RixXQUFPL0ksS0FBSyxHQUFHLENBQVIsR0FBWTZJLElBQUksR0FBR0UsSUFBbkIsR0FBMEIsV0FBV0EsSUFBWCxHQUFrQkYsSUFBbkQ7QUFDRCxHQUZXLENBSlo7O0FBUUFuSixlQUFhLENBQUNNLEtBQUssR0FBRyxDQUFSLEdBQVksV0FBVzZJLElBQXZCLEdBQThCQSxJQUEvQixDQUFiLEdBQW9ELFVBQVU3TCxNQUFWLEVBQWtCN0UsTUFBbEIsRUFBMEJDLFFBQTFCLEVBQW9Db0ksUUFBcEMsRUFBOEM0QixLQUE5QyxFQUFxRDtBQUN2RyxRQUFJbEMsQ0FBSixFQUFPOEksSUFBUDs7QUFFQSxRQUFJQyxTQUFTLENBQUNqTixNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0FrRSxPQUFDLEdBQUdxQyxLQUFLLENBQUNVLEdBQU4sQ0FBVSxVQUFVcEQsSUFBVixFQUFnQjtBQUM1QixlQUFPUixJQUFJLENBQUNyQyxNQUFELEVBQVM2QyxJQUFULEVBQWV6SCxRQUFmLENBQVg7QUFDRCxPQUZHLENBQUo7QUFHQTRRLFVBQUksR0FBRzlJLENBQUMsQ0FBQ2dDLElBQUYsQ0FBTyxHQUFQLENBQVA7QUFDQSxhQUFPOEcsSUFBSSxDQUFDOU8sS0FBTCxDQUFXZ0csQ0FBQyxDQUFDLENBQUQsQ0FBWixFQUFpQmxFLE1BQWpCLEtBQTRCLENBQTVCLEdBQWdDa0UsQ0FBQyxDQUFDLENBQUQsQ0FBakMsR0FBdUM4SSxJQUE5QztBQUNEOztBQUVEOUksS0FBQyxHQUFHLENBQUNNLFFBQVEsR0FBRyxFQUFaLEVBQWdCdEcsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBSjtBQUNBOE8sUUFBSSxHQUFHLEVBQVA7QUFDQXpHLFNBQUssQ0FBQzJHLE9BQU4sQ0FBYyxVQUFVckosSUFBVixFQUFnQnhGLENBQWhCLEVBQW1CO0FBQy9CLGFBQU8yTyxJQUFJLENBQUNuSixJQUFELENBQUosR0FBYUssQ0FBQyxDQUFDN0YsQ0FBRCxDQUFELEdBQU82RixDQUFDLENBQUM3RixDQUFELENBQUQsSUFBUTZGLENBQUMsQ0FBQyxDQUFDN0YsQ0FBQyxHQUFHLENBQUwsSUFBVSxDQUFWLEdBQWMsQ0FBZixDQUFwQztBQUNELEtBRkQ7QUFHQTJDLFVBQU0sQ0FBQ21NLElBQVAsQ0FBWWhSLE1BQVosRUFBb0I2USxJQUFwQixFQUEwQjVHLEtBQTFCO0FBQ0QsR0FsQkQ7QUFtQkQsQ0E1QlcsQ0FBWjs7QUE4Qk8sSUFBSWdILFNBQVMsR0FBRztBQUNyQlAsTUFBSSxFQUFFLEtBRGU7QUFFckJRLFVBQVEsRUFBRTVPLFNBRlc7QUFHckI2TyxZQUFVLEVBQUUsU0FBU0EsVUFBVCxDQUFvQm5SLE1BQXBCLEVBQTRCO0FBQ3RDLFdBQU9BLE1BQU0sQ0FBQ0UsS0FBUCxJQUFnQkYsTUFBTSxDQUFDb1IsUUFBOUI7QUFDRCxHQUxvQjtBQU1yQkosTUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY2hSLE1BQWQsRUFBc0I2USxJQUF0QixFQUE0QjVHLEtBQTVCLEVBQW1DcEMsS0FBbkMsRUFBMEN3SixPQUExQyxFQUFtRDtBQUN2RCxRQUFJakgsS0FBSyxHQUFHLEtBQUtoRixNQUFqQjtBQUFBLFFBQ0lsRixLQUFLLEdBQUdGLE1BQU0sQ0FBQ0UsS0FEbkI7QUFBQSxRQUVJb1IsT0FBTyxHQUFHckgsS0FBSyxDQUFDNEcsSUFBTixDQUFXUyxPQUZ6QjtBQUFBLFFBR0lsSixVQUhKO0FBQUEsUUFJSUMsUUFKSjtBQUFBLFFBS0lDLE1BTEo7QUFBQSxRQU1JSixRQU5KO0FBQUEsUUFPSWhILElBUEo7QUFBQSxRQVFJcVEsV0FSSjtBQUFBLFFBU0lyUyxDQVRKO0FBQUEsUUFVSXVKLFNBVko7QUFBQSxRQVdJRCxPQVhKO0FBQUEsUUFZSUUsUUFaSjtBQUFBLFFBYUk4SSxrQkFiSjtBQUFBLFFBY0lDLGtCQWRKO0FBQUEsUUFlSTlRLEtBZko7QUFBQSxRQWdCSWtMLE1BaEJKO0FBQUEsUUFpQkk2RixXQWpCSjtBQWtCQWxVLGtCQUFjLElBQUk4RSxTQUFTLEVBQTNCOztBQUVBLFNBQUtwRCxDQUFMLElBQVUyUixJQUFWLEVBQWdCO0FBQ2QsVUFBSTNSLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRURtSixjQUFRLEdBQUd3SSxJQUFJLENBQUMzUixDQUFELENBQWY7O0FBRUEsVUFBSXlTLHNEQUFRLENBQUN6UyxDQUFELENBQVIsSUFBZTBTLGtFQUFZLENBQUMxUyxDQUFELEVBQUkyUixJQUFKLEVBQVU1RyxLQUFWLEVBQWlCcEMsS0FBakIsRUFBd0I3SCxNQUF4QixFQUFnQ3FSLE9BQWhDLENBQS9CLEVBQXlFO0FBQ3ZFO0FBQ0E7QUFDRDs7QUFFRG5RLFVBQUksR0FBRyxPQUFPbUgsUUFBZDtBQUNBa0osaUJBQVcsR0FBR2hLLGFBQWEsQ0FBQ3JJLENBQUQsQ0FBM0I7O0FBRUEsVUFBSWdDLElBQUksS0FBSyxVQUFiLEVBQXlCO0FBQ3ZCbUgsZ0JBQVEsR0FBR0EsUUFBUSxDQUFDbkUsSUFBVCxDQUFjK0YsS0FBZCxFQUFxQnBDLEtBQXJCLEVBQTRCN0gsTUFBNUIsRUFBb0NxUixPQUFwQyxDQUFYO0FBQ0FuUSxZQUFJLEdBQUcsT0FBT21ILFFBQWQ7QUFDRDs7QUFFRCxVQUFJbkgsSUFBSSxLQUFLLFFBQVQsSUFBcUIsQ0FBQ21ILFFBQVEsQ0FBQzFCLE9BQVQsQ0FBaUIsU0FBakIsQ0FBMUIsRUFBdUQ7QUFDckQwQixnQkFBUSxHQUFHd0osb0VBQWMsQ0FBQ3hKLFFBQUQsQ0FBekI7QUFDRDs7QUFFRCxVQUFJa0osV0FBSixFQUFpQjtBQUNmQSxtQkFBVyxDQUFDLElBQUQsRUFBT3ZSLE1BQVAsRUFBZWQsQ0FBZixFQUFrQm1KLFFBQWxCLEVBQTRCNEIsS0FBNUIsQ0FBWCxLQUFrRHlILFdBQVcsR0FBRyxDQUFoRTtBQUNELE9BRkQsTUFFTyxJQUFJeFMsQ0FBQyxDQUFDbUQsTUFBRixDQUFTLENBQVQsRUFBWSxDQUFaLE1BQW1CLElBQXZCLEVBQTZCO0FBQ2xDO0FBQ0ErRixrQkFBVSxHQUFHLENBQUMxRyxnQkFBZ0IsQ0FBQzFCLE1BQUQsQ0FBaEIsQ0FBeUIyQixnQkFBekIsQ0FBMEN6QyxDQUExQyxJQUErQyxFQUFoRCxFQUFvRDZHLElBQXBELEVBQWI7QUFDQXNDLGdCQUFRLElBQUksRUFBWjtBQUNBeUosK0RBQVMsQ0FBQzdJLFNBQVYsR0FBc0IsQ0FBdEI7O0FBRUEsWUFBSSxDQUFDNkksdURBQVMsQ0FBQzdMLElBQVYsQ0FBZW1DLFVBQWYsQ0FBTCxFQUFpQztBQUMvQjtBQUNBSyxtQkFBUyxHQUFHd0csNkRBQU8sQ0FBQzdHLFVBQUQsQ0FBbkI7QUFDQUksaUJBQU8sR0FBR3lHLDZEQUFPLENBQUM1RyxRQUFELENBQWpCO0FBQ0Q7O0FBRURHLGVBQU8sR0FBR0MsU0FBUyxLQUFLRCxPQUFkLEtBQTBCSixVQUFVLEdBQUcxQyxjQUFjLENBQUMxRixNQUFELEVBQVNkLENBQVQsRUFBWWtKLFVBQVosRUFBd0JJLE9BQXhCLENBQWQsR0FBaURBLE9BQXhGLENBQUgsR0FBc0dDLFNBQVMsS0FBS0osUUFBUSxJQUFJSSxTQUFqQixDQUF0SDtBQUNBLGFBQUtzSixHQUFMLENBQVM3UixLQUFULEVBQWdCLGFBQWhCLEVBQStCa0ksVUFBL0IsRUFBMkNDLFFBQTNDLEVBQXFEUixLQUFyRCxFQUE0RHdKLE9BQTVELEVBQXFFLENBQXJFLEVBQXdFLENBQXhFLEVBQTJFblMsQ0FBM0U7QUFDRCxPQWRNLE1BY0EsSUFBSWdDLElBQUksS0FBSyxXQUFiLEVBQTBCO0FBQy9CLFlBQUlvUSxPQUFPLElBQUlwUyxDQUFDLElBQUlvUyxPQUFwQixFQUE2QjtBQUMzQjtBQUNBbEosb0JBQVUsR0FBRyxPQUFPa0osT0FBTyxDQUFDcFMsQ0FBRCxDQUFkLEtBQXNCLFVBQXRCLEdBQW1Db1MsT0FBTyxDQUFDcFMsQ0FBRCxDQUFQLENBQVdnRixJQUFYLENBQWdCK0YsS0FBaEIsRUFBdUJwQyxLQUF2QixFQUE4QjdILE1BQTlCLEVBQXNDcVIsT0FBdEMsQ0FBbkMsR0FBb0ZDLE9BQU8sQ0FBQ3BTLENBQUQsQ0FBeEc7QUFDQUEsV0FBQyxJQUFJZ0sscURBQU8sQ0FBQ0MsS0FBYixJQUFzQixDQUFDOEYsNkRBQU8sQ0FBQzdHLFVBQUQsQ0FBOUIsS0FBK0NBLFVBQVUsSUFBSWMscURBQU8sQ0FBQ0MsS0FBUixDQUFjakssQ0FBZCxDQUE3RCxFQUgyQixDQUdxRDs7QUFFaEYsV0FBQ2tKLFVBQVUsR0FBRyxFQUFkLEVBQWtCakcsTUFBbEIsQ0FBeUIsQ0FBekIsTUFBZ0MsR0FBaEMsS0FBd0NpRyxVQUFVLEdBQUdsQixJQUFJLENBQUNsSCxNQUFELEVBQVNkLENBQVQsQ0FBekQsRUFMMkIsQ0FLNEM7QUFDeEUsU0FORCxNQU1PO0FBQ0xrSixvQkFBVSxHQUFHbEIsSUFBSSxDQUFDbEgsTUFBRCxFQUFTZCxDQUFULENBQWpCO0FBQ0Q7O0FBRURnSixnQkFBUSxHQUFHckMsVUFBVSxDQUFDdUMsVUFBRCxDQUFyQjtBQUNBTSxnQkFBUSxHQUFHeEgsSUFBSSxLQUFLLFFBQVQsSUFBcUJtSCxRQUFRLENBQUNsRyxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQTVDLEdBQWtELEVBQUVrRyxRQUFRLENBQUNsRyxNQUFULENBQWdCLENBQWhCLElBQXFCLEdBQXZCLENBQWxELEdBQWdGLENBQTNGO0FBQ0F1RyxnQkFBUSxLQUFLTCxRQUFRLEdBQUdBLFFBQVEsQ0FBQ2hHLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBaEIsQ0FBUjtBQUNBaUcsY0FBTSxHQUFHekMsVUFBVSxDQUFDd0MsUUFBRCxDQUFuQjs7QUFFQSxZQUFJbkosQ0FBQyxJQUFJVCxnQkFBVCxFQUEyQjtBQUN6QixjQUFJUyxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNyQjtBQUNBLGdCQUFJZ0osUUFBUSxLQUFLLENBQWIsSUFBa0JoQixJQUFJLENBQUNsSCxNQUFELEVBQVMsWUFBVCxDQUFKLEtBQStCLFFBQWpELElBQTZEc0ksTUFBakUsRUFBeUU7QUFDdkU7QUFDQUosc0JBQVEsR0FBRyxDQUFYO0FBQ0Q7O0FBRUR0RCw2QkFBaUIsQ0FBQyxJQUFELEVBQU8xRSxLQUFQLEVBQWMsWUFBZCxFQUE0QmdJLFFBQVEsR0FBRyxTQUFILEdBQWUsUUFBbkQsRUFBNkRJLE1BQU0sR0FBRyxTQUFILEdBQWUsUUFBbEYsRUFBNEYsQ0FBQ0EsTUFBN0YsQ0FBakI7QUFDRDs7QUFFRCxjQUFJcEosQ0FBQyxLQUFLLE9BQU4sSUFBaUJBLENBQUMsS0FBSyxXQUEzQixFQUF3QztBQUN0Q0EsYUFBQyxHQUFHVCxnQkFBZ0IsQ0FBQ1MsQ0FBRCxDQUFwQjtBQUNBLGFBQUNBLENBQUMsQ0FBQ3lILE9BQUYsQ0FBVSxHQUFWLENBQUQsS0FBb0J6SCxDQUFDLEdBQUdBLENBQUMsQ0FBQzZDLEtBQUYsQ0FBUSxHQUFSLEVBQWEsQ0FBYixDQUF4QjtBQUNEO0FBQ0Y7O0FBRUR5UCwwQkFBa0IsR0FBR3RTLENBQUMsSUFBSXBCLGVBQTFCLENBakMrQixDQWlDWTs7QUFFM0MsWUFBSTBULGtCQUFKLEVBQXdCO0FBQ3RCLGNBQUksQ0FBQ0Msa0JBQUwsRUFBeUI7QUFDdkI5USxpQkFBSyxHQUFHWCxNQUFNLENBQUNNLEtBQWY7QUFDQUssaUJBQUssQ0FBQ0MsZUFBTixJQUF5QixDQUFDaVEsSUFBSSxDQUFDbUIsY0FBL0IsSUFBaUQ1SyxlQUFlLENBQUNwSCxNQUFELEVBQVM2USxJQUFJLENBQUNtQixjQUFkLENBQWhFLENBRnVCLENBRXdFOztBQUUvRm5HLGtCQUFNLEdBQUdnRixJQUFJLENBQUNvQixZQUFMLEtBQXNCLEtBQXRCLElBQStCdFIsS0FBSyxDQUFDa0wsTUFBOUM7QUFDQTRGLDhCQUFrQixHQUFHLEtBQUt0TSxHQUFMLEdBQVcsSUFBSUQsdURBQUosQ0FBYyxLQUFLQyxHQUFuQixFQUF3QmpGLEtBQXhCLEVBQStCWSxjQUEvQixFQUErQyxDQUEvQyxFQUFrRCxDQUFsRCxFQUFxREgsS0FBSyxDQUFDQyxlQUEzRCxFQUE0RUQsS0FBNUUsRUFBbUYsQ0FBbkYsRUFBc0YsQ0FBQyxDQUF2RixDQUFoQyxDQUx1QixDQUtvRzs7QUFFM0g4USw4QkFBa0IsQ0FBQ1MsR0FBbkIsR0FBeUIsQ0FBekIsQ0FQdUIsQ0FPSztBQUM3Qjs7QUFFRCxjQUFJaFQsQ0FBQyxLQUFLLE9BQVYsRUFBbUI7QUFDakIsaUJBQUtpRyxHQUFMLEdBQVcsSUFBSUQsdURBQUosQ0FBYyxLQUFLQyxHQUFuQixFQUF3QnhFLEtBQXhCLEVBQStCLFFBQS9CLEVBQXlDQSxLQUFLLENBQUNGLE1BQS9DLEVBQXVEaUksUUFBUSxHQUFHQSxRQUFRLEdBQUdKLE1BQWQsR0FBdUJBLE1BQU0sR0FBRzNILEtBQUssQ0FBQ0YsTUFBckcsQ0FBWDtBQUNBMkosaUJBQUssQ0FBQy9FLElBQU4sQ0FBVyxRQUFYLEVBQXFCbkcsQ0FBckI7QUFDQUEsYUFBQyxJQUFJLEdBQUw7QUFDRCxXQUpELE1BSU8sSUFBSUEsQ0FBQyxLQUFLLGlCQUFWLEVBQTZCO0FBQ2xDbUosb0JBQVEsR0FBR3lCLDZCQUE2QixDQUFDekIsUUFBRCxDQUF4QyxDQURrQyxDQUNrQjs7QUFFcEQsZ0JBQUkxSCxLQUFLLENBQUNpQyxHQUFWLEVBQWU7QUFDYjhJLDZCQUFlLENBQUMxTCxNQUFELEVBQVNxSSxRQUFULEVBQW1CLENBQW5CLEVBQXNCd0QsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsSUFBakMsQ0FBZjtBQUNELGFBRkQsTUFFTztBQUNMckQscUJBQU8sR0FBRzNDLFVBQVUsQ0FBQ3dDLFFBQVEsQ0FBQ3RHLEtBQVQsQ0FBZSxHQUFmLEVBQW9CLENBQXBCLENBQUQsQ0FBVixJQUFzQyxDQUFoRCxDQURLLENBQzhDOztBQUVuRHlHLHFCQUFPLEtBQUs3SCxLQUFLLENBQUMyRyxPQUFsQixJQUE2QjFDLGlCQUFpQixDQUFDLElBQUQsRUFBT2pFLEtBQVAsRUFBYyxTQUFkLEVBQXlCQSxLQUFLLENBQUMyRyxPQUEvQixFQUF3Q2tCLE9BQXhDLENBQTlDOztBQUVBNUQsK0JBQWlCLENBQUMsSUFBRCxFQUFPMUUsS0FBUCxFQUFjaEIsQ0FBZCxFQUFpQm1JLGFBQWEsQ0FBQ2UsVUFBRCxDQUE5QixFQUE0Q2YsYUFBYSxDQUFDZ0IsUUFBRCxDQUF6RCxDQUFqQjtBQUNEOztBQUVEO0FBQ0QsV0FkTSxNQWNBLElBQUluSixDQUFDLEtBQUssV0FBVixFQUF1QjtBQUM1QndNLDJCQUFlLENBQUMxTCxNQUFELEVBQVNxSSxRQUFULEVBQW1CLENBQW5CLEVBQXNCd0QsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsSUFBakMsQ0FBZjs7QUFFQTtBQUNELFdBSk0sTUFJQSxJQUFJM00sQ0FBQyxJQUFJdUwscUJBQVQsRUFBZ0M7QUFDckNtRixtQ0FBdUIsQ0FBQyxJQUFELEVBQU9qUCxLQUFQLEVBQWN6QixDQUFkLEVBQWlCZ0osUUFBakIsRUFBMkJHLFFBQTNCLEVBQXFDSyxRQUFyQyxDQUF2Qjs7QUFFQTtBQUNELFdBSk0sTUFJQSxJQUFJeEosQ0FBQyxLQUFLLGNBQVYsRUFBMEI7QUFDL0IwRiw2QkFBaUIsQ0FBQyxJQUFELEVBQU9qRSxLQUFQLEVBQWMsUUFBZCxFQUF3QkEsS0FBSyxDQUFDa0wsTUFBOUIsRUFBc0N4RCxRQUF0QyxDQUFqQjs7QUFFQTtBQUNELFdBSk0sTUFJQSxJQUFJbkosQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDMUJ5QixpQkFBSyxDQUFDekIsQ0FBRCxDQUFMLEdBQVdtSixRQUFYO0FBQ0E7QUFDRCxXQUhNLE1BR0EsSUFBSW5KLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQzVCbVIsK0JBQW1CLENBQUMsSUFBRCxFQUFPaEksUUFBUCxFQUFpQnJJLE1BQWpCLENBQW5COztBQUVBO0FBQ0Q7QUFDRixTQWpERCxNQWlETyxJQUFJLEVBQUVkLENBQUMsSUFBSWdCLEtBQVAsQ0FBSixFQUFtQjtBQUN4QmhCLFdBQUMsR0FBRzJDLGdCQUFnQixDQUFDM0MsQ0FBRCxDQUFoQixJQUF1QkEsQ0FBM0I7QUFDRDs7QUFFRCxZQUFJc1Msa0JBQWtCLElBQUksQ0FBQ2xKLE1BQU0sSUFBSUEsTUFBTSxLQUFLLENBQXRCLE1BQTZCSixRQUFRLElBQUlBLFFBQVEsS0FBSyxDQUF0RCxLQUE0RCxDQUFDMUosV0FBVyxDQUFDeUgsSUFBWixDQUFpQm9DLFFBQWpCLENBQTdELElBQTJGbkosQ0FBQyxJQUFJZ0IsS0FBMUgsRUFBaUk7QUFDL0h1SSxtQkFBUyxHQUFHLENBQUNMLFVBQVUsR0FBRyxFQUFkLEVBQWtCL0YsTUFBbEIsQ0FBeUIsQ0FBQzZGLFFBQVEsR0FBRyxFQUFaLEVBQWdCckUsTUFBekMsQ0FBWjtBQUNBeUUsZ0JBQU0sS0FBS0EsTUFBTSxHQUFHLENBQWQsQ0FBTixDQUYrSCxDQUV2Rzs7QUFFeEJFLGlCQUFPLEdBQUd5Ryw2REFBTyxDQUFDNUcsUUFBRCxDQUFQLEtBQXNCbkosQ0FBQyxJQUFJZ0sscURBQU8sQ0FBQ0MsS0FBYixHQUFxQkQscURBQU8sQ0FBQ0MsS0FBUixDQUFjakssQ0FBZCxDQUFyQixHQUF3Q3VKLFNBQTlELENBQVY7QUFDQUEsbUJBQVMsS0FBS0QsT0FBZCxLQUEwQk4sUUFBUSxHQUFHeEMsY0FBYyxDQUFDMUYsTUFBRCxFQUFTZCxDQUFULEVBQVlrSixVQUFaLEVBQXdCSSxPQUF4QixDQUFuRDtBQUNBLGVBQUtyRCxHQUFMLEdBQVcsSUFBSUQsdURBQUosQ0FBYyxLQUFLQyxHQUFuQixFQUF3QnFNLGtCQUFrQixHQUFHN1EsS0FBSCxHQUFXVCxLQUFyRCxFQUE0RGhCLENBQTVELEVBQStEZ0osUUFBL0QsRUFBeUVRLFFBQVEsR0FBR0EsUUFBUSxHQUFHSixNQUFkLEdBQXVCQSxNQUFNLEdBQUdKLFFBQWpILEVBQTJILENBQUNzSixrQkFBRCxLQUF3QmhKLE9BQU8sS0FBSyxJQUFaLElBQW9CdEosQ0FBQyxLQUFLLFFBQWxELEtBQStEMlIsSUFBSSxDQUFDc0IsU0FBTCxLQUFtQixLQUFsRixHQUEwRnhTLHFCQUExRixHQUFrSGQsY0FBN08sQ0FBWDtBQUNBLGVBQUtzRyxHQUFMLENBQVM3RixDQUFULEdBQWFrSixPQUFPLElBQUksQ0FBeEI7O0FBRUEsY0FBSUMsU0FBUyxLQUFLRCxPQUFsQixFQUEyQjtBQUN6QjtBQUNBLGlCQUFLckQsR0FBTCxDQUFTekYsQ0FBVCxHQUFhMEksVUFBYjtBQUNBLGlCQUFLakQsR0FBTCxDQUFTbUUsQ0FBVCxHQUFhN0osMkJBQWI7QUFDRDtBQUNGLFNBZEQsTUFjTyxJQUFJLEVBQUVQLENBQUMsSUFBSWdCLEtBQVAsQ0FBSixFQUFtQjtBQUN4QixjQUFJaEIsQ0FBQyxJQUFJYyxNQUFULEVBQWlCO0FBQ2Y7QUFDQSxpQkFBSytSLEdBQUwsQ0FBUy9SLE1BQVQsRUFBaUJkLENBQWpCLEVBQW9CYyxNQUFNLENBQUNkLENBQUQsQ0FBMUIsRUFBK0JtSixRQUEvQixFQUF5Q1IsS0FBekMsRUFBZ0R3SixPQUFoRDtBQUNELFdBSEQsTUFHTztBQUNMZSxnRkFBYyxDQUFDbFQsQ0FBRCxFQUFJbUosUUFBSixDQUFkOztBQUVBO0FBQ0Q7QUFDRixTQVRNLE1BU0E7QUFDTFosZ0NBQXNCLENBQUN2RCxJQUF2QixDQUE0QixJQUE1QixFQUFrQ2xFLE1BQWxDLEVBQTBDZCxDQUExQyxFQUE2Q2tKLFVBQTdDLEVBQXlEQyxRQUF6RDtBQUNEOztBQUVEK0IsYUFBSyxDQUFDL0UsSUFBTixDQUFXbkcsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUR3UyxlQUFXLElBQUlXLCtFQUF5QixDQUFDLElBQUQsQ0FBeEM7QUFDRCxHQTNMb0I7QUE0THJCQyxLQUFHLEVBQUVwTCxJQTVMZ0I7QUE2THJCcUwsU0FBTyxFQUFFOVQsZ0JBN0xZO0FBOExyQitULFdBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CeFMsTUFBbkIsRUFBMkJDLFFBQTNCLEVBQXFDNEUsTUFBckMsRUFBNkM7QUFDdEQ7QUFDQSxRQUFJM0YsQ0FBQyxHQUFHVCxnQkFBZ0IsQ0FBQ3dCLFFBQUQsQ0FBeEI7QUFDQWYsS0FBQyxJQUFJQSxDQUFDLENBQUN5SCxPQUFGLENBQVUsR0FBVixJQUFpQixDQUF0QixLQUE0QjFHLFFBQVEsR0FBR2YsQ0FBdkM7QUFDQSxXQUFPZSxRQUFRLElBQUluQyxlQUFaLElBQStCbUMsUUFBUSxLQUFLYyxvQkFBNUMsS0FBcUVmLE1BQU0sQ0FBQ00sS0FBUCxDQUFhK0QsQ0FBYixJQUFrQjZDLElBQUksQ0FBQ2xILE1BQUQsRUFBUyxHQUFULENBQTNGLElBQTRHNkUsTUFBTSxJQUFJbEgsbUJBQW1CLEtBQUtrSCxNQUFsQyxHQUEyQzVFLFFBQVEsS0FBSyxPQUFiLEdBQXVCTSxZQUF2QixHQUFzQ0YsZ0JBQWpGLEdBQW9HLENBQUMxQyxtQkFBbUIsR0FBR2tILE1BQU0sSUFBSSxFQUFqQyxNQUF5QzVFLFFBQVEsS0FBSyxPQUFiLEdBQXVCUyxzQkFBdkIsR0FBZ0RHLDBCQUF6RixDQUFoTixHQUF1VWIsTUFBTSxDQUFDRSxLQUFQLElBQWdCLENBQUN1UyxrRUFBWSxDQUFDelMsTUFBTSxDQUFDRSxLQUFQLENBQWFELFFBQWIsQ0FBRCxDQUE3QixHQUF3REYsZUFBeEQsR0FBMEUsQ0FBQ0UsUUFBUSxDQUFDMEcsT0FBVCxDQUFpQixHQUFqQixDQUFELEdBQXlCeEcsY0FBekIsR0FBMEN1UyxnRUFBVSxDQUFDMVMsTUFBRCxFQUFTQyxRQUFULENBQTVjO0FBQ0QsR0FuTW9CO0FBb01yQjBTLE1BQUksRUFBRTtBQUNKbE8sbUJBQWUsRUFBRUEsZUFEYjtBQUVKc0csY0FBVSxFQUFFQTtBQUZSO0FBcE1lLENBQWhCO0FBeU1QNkgsa0RBQUksQ0FBQ0MsS0FBTCxDQUFXQyxXQUFYLEdBQXlCalIsZ0JBQXpCOztBQUVBLENBQUMsVUFBVWtSLGdCQUFWLEVBQTRCL0YsUUFBNUIsRUFBc0NnRyxNQUF0QyxFQUE4Q1QsT0FBOUMsRUFBdUQ7QUFDdEQsTUFBSVUsR0FBRyxHQUFHeEMsa0VBQVksQ0FBQ3NDLGdCQUFnQixHQUFHLEdBQW5CLEdBQXlCL0YsUUFBekIsR0FBb0MsR0FBcEMsR0FBMENnRyxNQUEzQyxFQUFtRCxVQUFVdEMsSUFBVixFQUFnQjtBQUN2RjVTLG1CQUFlLENBQUM0UyxJQUFELENBQWYsR0FBd0IsQ0FBeEI7QUFDRCxHQUZxQixDQUF0Qjs7QUFJQUQsb0VBQVksQ0FBQ3pELFFBQUQsRUFBVyxVQUFVMEQsSUFBVixFQUFnQjtBQUNyQ3hILHlEQUFPLENBQUNDLEtBQVIsQ0FBY3VILElBQWQsSUFBc0IsS0FBdEI7QUFDQWpHLHlCQUFxQixDQUFDaUcsSUFBRCxDQUFyQixHQUE4QixDQUE5QjtBQUNELEdBSFcsQ0FBWjs7QUFLQWpTLGtCQUFnQixDQUFDd1UsR0FBRyxDQUFDLEVBQUQsQ0FBSixDQUFoQixHQUE0QkYsZ0JBQWdCLEdBQUcsR0FBbkIsR0FBeUIvRixRQUFyRDs7QUFFQXlELG9FQUFZLENBQUM4QixPQUFELEVBQVUsVUFBVTdCLElBQVYsRUFBZ0I7QUFDcEMsUUFBSTNPLEtBQUssR0FBRzJPLElBQUksQ0FBQzNPLEtBQUwsQ0FBVyxHQUFYLENBQVo7QUFDQXRELG9CQUFnQixDQUFDc0QsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFoQixHQUE2QmtSLEdBQUcsQ0FBQ2xSLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBaEM7QUFDRCxHQUhXLENBQVo7QUFJRCxDQWhCRCxFQWdCRyw2Q0FoQkgsRUFnQmtELDBDQWhCbEQsRUFnQjhGLCtFQWhCOUYsRUFnQitLLDRGQWhCL0s7O0FBa0JBME8sa0VBQVksQ0FBQyw4RUFBRCxFQUFpRixVQUFVQyxJQUFWLEVBQWdCO0FBQzNHeEgsdURBQU8sQ0FBQ0MsS0FBUixDQUFjdUgsSUFBZCxJQUFzQixJQUF0QjtBQUNELENBRlcsQ0FBWjs7QUFJQWtDLGtEQUFJLENBQUNNLGNBQUwsQ0FBb0JqQyxTQUFwQiIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1BsdWdpbiAzLjYuMVxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXG59IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuXG52YXIgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9wbHVnaW5Jbml0dGVkLFxuICAgIF90ZW1wRGl2LFxuICAgIF90ZW1wRGl2U3R5bGVyLFxuICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKD86bGVmdHxyaWdodHx3aWR0aHxtYXJnaW58cGFkZGluZ3x4KS9pLFxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgYXV0b0FscGhhOiBcIm9wYWNpdHksdmlzaWJpbGl0eVwiLFxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gIGFscGhhOiBcIm9wYWNpdHlcIlxufSxcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcbl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xufSxcbiAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xuICAgICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHIoMCwgMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgb25seVNldEF0RW5kID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSk7XG4gIHBsdWdpbi5fcHQgPSBwdDtcbiAgcHQuYiA9IGJlZ2lubmluZztcbiAgcHQuZSA9IGVuZDtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxLFxuICB0dXJuOiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBlbmRWYWx1ZXM7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIHJlbGF0aXZlID0gZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcblxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG5cbiAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgYzogcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gIWNhY2hlLnVuY2FjaGUgJiYgIXVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XG5cbiAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgeCAtPSB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhICsgeU9yaWdpbiAqIGMpO1xuICAgICAgICB5IC09IHlPcmlnaW4gLSAoeE9yaWdpbiAqIGIgKyB5T3JpZ2luICogZCk7XG4gICAgICB9IC8vM0QgbWF0cml4XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYTMyID0gbWF0cml4WzZdO1xuICAgICAgYTQyID0gbWF0cml4WzddO1xuICAgICAgYTEzID0gbWF0cml4WzhdO1xuICAgICAgYTIzID0gbWF0cml4WzldO1xuICAgICAgYTMzID0gbWF0cml4WzEwXTtcbiAgICAgIGE0MyA9IG1hdHJpeFsxMV07XG4gICAgICB4ID0gbWF0cml4WzEyXTtcbiAgICAgIHkgPSBtYXRyaXhbMTNdO1xuICAgICAgeiA9IG1hdHJpeFsxNF07XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMzIsIGEzMyk7XG4gICAgICByb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHOyAvL3JvdGF0aW9uWFxuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhMTIgKiBjb3MgKyBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYTIyICogY29zICsgYTIzICogc2luO1xuICAgICAgICB0MyA9IGEzMiAqIGNvcyArIGEzMyAqIHNpbjtcbiAgICAgICAgYTEzID0gYTEyICogLXNpbiArIGExMyAqIGNvcztcbiAgICAgICAgYTIzID0gYTIyICogLXNpbiArIGEyMyAqIGNvcztcbiAgICAgICAgYTMzID0gYTMyICogLXNpbiArIGEzMyAqIGNvcztcbiAgICAgICAgYTQzID0gYTQyICogLXNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYTEyID0gdDE7XG4gICAgICAgIGEyMiA9IHQyO1xuICAgICAgICBhMzIgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvbllcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMigtYywgYTMzKTtcbiAgICAgIHJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgLSBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYiAqIGNvcyAtIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBjICogY29zIC0gYTMzICogc2luO1xuICAgICAgICBhNDMgPSBkICogc2luICsgYTQzICogY29zO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGIgPSB0MjtcbiAgICAgICAgYyA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWlxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKGIsIGEpO1xuICAgICAgcm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyArIGIgKiBzaW47XG4gICAgICAgIHQyID0gYTEyICogY29zICsgYTIyICogc2luO1xuICAgICAgICBiID0gYiAqIGNvcyAtIGEgKiBzaW47XG4gICAgICAgIGEyMiA9IGEyMiAqIGNvcyAtIGExMiAqIHNpbjtcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBhMTIgPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uWCAmJiBNYXRoLmFicyhyb3RhdGlvblgpICsgTWF0aC5hYnMocm90YXRpb24pID4gMzU5LjkpIHtcbiAgICAgICAgLy93aGVuIHJvdGF0aW9uWSBpcyBzZXQsIGl0IHdpbGwgb2Z0ZW4gYmUgcGFyc2VkIGFzIDE4MCBkZWdyZWVzIGRpZmZlcmVudCB0aGFuIGl0IHNob3VsZCBiZSwgYW5kIHJvdGF0aW9uWCBhbmQgcm90YXRpb24gYm90aCBiZWluZyAxODAgKGl0IGxvb2tzIHRoZSBzYW1lKSwgc28gd2UgYWRqdXN0IGZvciB0aGF0IGhlcmUuXG4gICAgICAgIHJvdGF0aW9uWCA9IHJvdGF0aW9uID0gMDtcbiAgICAgICAgcm90YXRpb25ZID0gMTgwIC0gcm90YXRpb25ZO1xuICAgICAgfVxuXG4gICAgICBzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xuICAgICAgc2NhbGVZID0gX3JvdW5kKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpKTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGExMiwgYTIyKTtcbiAgICAgIHNrZXdYID0gTWF0aC5hYnMoYW5nbGUpID4gMC4wMDAyID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XG4gICAgICBwZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoYTQzIDwgMCA/IC1hNDMgOiBhNDMpIDogMDtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAvL3NlbnNlIGlmIHRoZXJlIGFyZSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9uIGFuIFNWRyBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB3aGVuIHJlbmRlcmluZy4gVGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaXMgbW9yZSByZWxpYWJsZSBjcm9zcy1icm93c2VyLCBidXQgd2UgY2FuJ3QganVzdCByZW1vdmUgdGhlIENTUyBvbmVzIGJlY2F1c2UgdGhleSBtYXkgYmUgYXBwbGllZCBpbiBhIENTUyBydWxlIHNvbWV3aGVyZSAobm90IGp1c3QgaW5saW5lKS5cbiAgICAgIHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIGNhY2hlLmZvcmNlQ1NTID0gdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKSB8fCAhX2lzTnVsbFRyYW5zZm9ybShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKSk7XG4gICAgICB0MSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHQxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG4gICAgaWYgKGludmVydGVkU2NhbGVYKSB7XG4gICAgICBzY2FsZVggKj0gLTE7XG4gICAgICBza2V3WCArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICAgIHJvdGF0aW9uICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICBza2V3WCArPSBza2V3WCA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9XG4gIH1cblxuICBjYWNoZS54ID0geCAtICgoY2FjaGUueFBlcmNlbnQgPSB4ICYmIChjYWNoZS54UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSA9PT0gTWF0aC5yb3VuZCgteCkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldFdpZHRoICogY2FjaGUueFBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS55ID0geSAtICgoY2FjaGUueVBlcmNlbnQgPSB5ICYmIChjYWNoZS55UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0SGVpZ2h0IC8gMikgPT09IE1hdGgucm91bmQoLXkpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRIZWlnaHQgKiBjYWNoZS55UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnogPSB6ICsgcHg7XG4gIGNhY2hlLnNjYWxlWCA9IF9yb3VuZChzY2FsZVgpO1xuICBjYWNoZS5zY2FsZVkgPSBfcm91bmQoc2NhbGVZKTtcbiAgY2FjaGUucm90YXRpb24gPSBfcm91bmQocm90YXRpb24pICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblggPSBfcm91bmQocm90YXRpb25YKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25ZID0gX3JvdW5kKHJvdGF0aW9uWSkgKyBkZWc7XG4gIGNhY2hlLnNrZXdYID0gc2tld1ggKyBkZWc7XG4gIGNhY2hlLnNrZXdZID0gc2tld1kgKyBkZWc7XG4gIGNhY2hlLnRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgKyBweDtcblxuICBpZiAoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgMCkge1xuICAgIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IF9maXJzdFR3b09ubHkob3JpZ2luKTtcbiAgfVxuXG4gIGNhY2hlLnhPZmZzZXQgPSBjYWNoZS55T2Zmc2V0ID0gMDtcbiAgY2FjaGUuZm9yY2UzRCA9IF9jb25maWcuZm9yY2UzRDtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtID0gY2FjaGUuc3ZnID8gX3JlbmRlclNWR1RyYW5zZm9ybXMgOiBfc3VwcG9ydHMzRCA/IF9yZW5kZXJDU1NUcmFuc2Zvcm1zIDogX3JlbmRlck5vbjNEVHJhbnNmb3JtcztcbiAgY2FjaGUudW5jYWNoZSA9IDA7XG4gIHJldHVybiBjYWNoZTtcbn0sXG4gICAgX2ZpcnN0VHdvT25seSA9IGZ1bmN0aW9uIF9maXJzdFR3b09ubHkodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiIFwiKSlbMF0gKyBcIiBcIiArIHZhbHVlWzFdO1xufSxcbiAgICAvL2ZvciBoYW5kbGluZyB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzLCBzdHJpcHBpbmcgb3V0IHRoZSAzcmQgZGltZW5zaW9uXG5fYWRkUHhUcmFuc2xhdGUgPSBmdW5jdGlvbiBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCBzdGFydCwgdmFsdWUpIHtcbiAgdmFyIHVuaXQgPSBnZXRVbml0KHN0YXJ0KTtcbiAgcmV0dXJuIF9yb3VuZChwYXJzZUZsb2F0KHN0YXJ0KSArIHBhcnNlRmxvYXQoX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgdmFsdWUgKyBcInB4XCIsIHVuaXQpKSkgKyB1bml0O1xufSxcbiAgICBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlck5vbjNEVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgY2FjaGUueiA9IFwiMHB4XCI7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IGNhY2hlLnJvdGF0aW9uWCA9IFwiMGRlZ1wiO1xuICBjYWNoZS5mb3JjZTNEID0gMDtcblxuICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfemVyb0RlZyA9IFwiMGRlZ1wiLFxuICAgIF96ZXJvUHggPSBcIjBweFwiLFxuICAgIF9lbmRQYXJlbnRoZXNpcyA9IFwiKSBcIixcbiAgICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICB2YXIgX3JlZiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICB4UGVyY2VudCA9IF9yZWYueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYueVBlcmNlbnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHogPSBfcmVmLnosXG4gICAgICByb3RhdGlvbiA9IF9yZWYucm90YXRpb24sXG4gICAgICByb3RhdGlvblkgPSBfcmVmLnJvdGF0aW9uWSxcbiAgICAgIHJvdGF0aW9uWCA9IF9yZWYucm90YXRpb25YLFxuICAgICAgc2tld1ggPSBfcmVmLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmLnNrZXdZLFxuICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlID0gX3JlZi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSxcbiAgICAgIGZvcmNlM0QgPSBfcmVmLmZvcmNlM0QsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHpPcmlnaW4gPSBfcmVmLnpPcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1zID0gXCJcIixcbiAgICAgIHVzZTNEID0gZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEgfHwgZm9yY2UzRCA9PT0gdHJ1ZTsgLy8gU2FmYXJpIGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCBub3QgdG8gcmVuZGVyIDNEIHRyYW5zZm9ybS1vcmlnaW4gdmFsdWVzIHByb3Blcmx5LCBzbyB3ZSBmb3JjZSB0aGUgeiBvcmlnaW4gdG8gMCwgcmVjb3JkIGl0IGluIHRoZSBjYWNoZSwgYW5kIHRoZW4gZG8gdGhlIG1hdGggaGVyZSB0byBvZmZzZXQgdGhlIHRyYW5zbGF0ZSB2YWx1ZXMgYWNjb3JkaW5nbHkgKGJhc2ljYWxseSBkbyB0aGUgM0QgdHJhbnNmb3JtLW9yaWdpbiBwYXJ0IG1hbnVhbGx5KVxuXG5cbiAgaWYgKHpPcmlnaW4gJiYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcgfHwgcm90YXRpb25ZICE9PSBfemVyb0RlZykpIHtcbiAgICB2YXIgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWSkgKiBfREVHMlJBRCxcbiAgICAgICAgYTEzID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBhMzMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIGNvcztcblxuICAgIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblgpICogX0RFRzJSQUQ7XG4gICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHggPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB4LCBhMTMgKiBjb3MgKiAtek9yaWdpbik7XG4gICAgeSA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHksIC1NYXRoLnNpbihhbmdsZSkgKiAtek9yaWdpbik7XG4gICAgeiA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHosIGEzMyAqIGNvcyAqIC16T3JpZ2luICsgek9yaWdpbik7XG4gIH1cblxuICBpZiAodHJhbnNmb3JtUGVyc3BlY3RpdmUgIT09IF96ZXJvUHgpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicGVyc3BlY3RpdmUoXCIgKyB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJ0cmFuc2xhdGUoXCIgKyB4UGVyY2VudCArIFwiJSwgXCIgKyB5UGVyY2VudCArIFwiJSkgXCI7XG4gIH1cblxuICBpZiAodXNlM0QgfHwgeCAhPT0gX3plcm9QeCB8fCB5ICE9PSBfemVyb1B4IHx8IHogIT09IF96ZXJvUHgpIHtcbiAgICB0cmFuc2Zvcm1zICs9IHogIT09IF96ZXJvUHggfHwgdXNlM0QgPyBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwiLCBcIiArIHkgKyBcIiwgXCIgKyB6ICsgXCIpIFwiIDogXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvbiAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlKFwiICsgcm90YXRpb24gKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb25ZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVZKFwiICsgcm90YXRpb25ZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWChcIiArIHJvdGF0aW9uWCArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChza2V3WCAhPT0gX3plcm9EZWcgfHwgc2tld1kgIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNrZXcoXCIgKyBza2V3WCArIFwiLCBcIiArIHNrZXdZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDEpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwic2NhbGUoXCIgKyBzY2FsZVggKyBcIiwgXCIgKyBzY2FsZVkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcyB8fCBcInRyYW5zbGF0ZSgwLCAwKVwiO1xufSxcbiAgICBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJTVkdUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICB2YXIgX3JlZjIgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmMi54UGVyY2VudCxcbiAgICAgIHlQZXJjZW50ID0gX3JlZjIueVBlcmNlbnQsXG4gICAgICB4ID0gX3JlZjIueCxcbiAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgcm90YXRpb24gPSBfcmVmMi5yb3RhdGlvbixcbiAgICAgIHNrZXdYID0gX3JlZjIuc2tld1gsXG4gICAgICBza2V3WSA9IF9yZWYyLnNrZXdZLFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgeE9yaWdpbiA9IF9yZWYyLnhPcmlnaW4sXG4gICAgICB5T3JpZ2luID0gX3JlZjIueU9yaWdpbixcbiAgICAgIHhPZmZzZXQgPSBfcmVmMi54T2Zmc2V0LFxuICAgICAgeU9mZnNldCA9IF9yZWYyLnlPZmZzZXQsXG4gICAgICBmb3JjZUNTUyA9IF9yZWYyLmZvcmNlQ1NTLFxuICAgICAgdHggPSBwYXJzZUZsb2F0KHgpLFxuICAgICAgdHkgPSBwYXJzZUZsb2F0KHkpLFxuICAgICAgYTExLFxuICAgICAgYTIxLFxuICAgICAgYTEyLFxuICAgICAgYTIyLFxuICAgICAgdGVtcDtcblxuICByb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xuICBza2V3WCA9IHBhcnNlRmxvYXQoc2tld1gpO1xuICBza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuXG4gIGlmIChza2V3WSkge1xuICAgIC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG4gICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcbiAgICBza2V3WCArPSBza2V3WTtcbiAgICByb3RhdGlvbiArPSBza2V3WTtcbiAgfVxuXG4gIGlmIChyb3RhdGlvbiB8fCBza2V3WCkge1xuICAgIHJvdGF0aW9uICo9IF9ERUcyUkFEO1xuICAgIHNrZXdYICo9IF9ERUcyUkFEO1xuICAgIGExMSA9IE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWDtcbiAgICBhMjEgPSBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTEyID0gTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiAtc2NhbGVZO1xuICAgIGEyMiA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuXG4gICAgaWYgKHNrZXdYKSB7XG4gICAgICBza2V3WSAqPSBfREVHMlJBRDtcbiAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WCAtIHNrZXdZKTtcbiAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgIGExMiAqPSB0ZW1wO1xuICAgICAgYTIyICo9IHRlbXA7XG5cbiAgICAgIGlmIChza2V3WSkge1xuICAgICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xuICAgICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICAgIGExMSAqPSB0ZW1wO1xuICAgICAgICBhMjEgKj0gdGVtcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhMTEgPSBfcm91bmQoYTExKTtcbiAgICBhMjEgPSBfcm91bmQoYTIxKTtcbiAgICBhMTIgPSBfcm91bmQoYTEyKTtcbiAgICBhMjIgPSBfcm91bmQoYTIyKTtcbiAgfSBlbHNlIHtcbiAgICBhMTEgPSBzY2FsZVg7XG4gICAgYTIyID0gc2NhbGVZO1xuICAgIGEyMSA9IGExMiA9IDA7XG4gIH1cblxuICBpZiAodHggJiYgIX4oeCArIFwiXCIpLmluZGV4T2YoXCJweFwiKSB8fCB0eSAmJiAhfih5ICsgXCJcIikuaW5kZXhPZihcInB4XCIpKSB7XG4gICAgdHggPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB4LCBcInB4XCIpO1xuICAgIHR5ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInlcIiwgeSwgXCJweFwiKTtcbiAgfVxuXG4gIGlmICh4T3JpZ2luIHx8IHlPcmlnaW4gfHwgeE9mZnNldCB8fCB5T2Zmc2V0KSB7XG4gICAgdHggPSBfcm91bmQodHggKyB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhMTEgKyB5T3JpZ2luICogYTEyKSArIHhPZmZzZXQpO1xuICAgIHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcbiAgfVxuXG4gIGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xuICAgIC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgdHJhbnNsYXRpb24gdG8gc2ltdWxhdGUgaXQuXG4gICAgdGVtcCA9IHRhcmdldC5nZXRCQm94KCk7XG4gICAgdHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xuICAgIHR5ID0gX3JvdW5kKHR5ICsgeVBlcmNlbnQgLyAxMDAgKiB0ZW1wLmhlaWdodCk7XG4gIH1cblxuICB0ZW1wID0gXCJtYXRyaXgoXCIgKyBhMTEgKyBcIixcIiArIGEyMSArIFwiLFwiICsgYTEyICsgXCIsXCIgKyBhMjIgKyBcIixcIiArIHR4ICsgXCIsXCIgKyB0eSArIFwiKVwiO1xuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRlbXApO1xuICBmb3JjZUNTUyAmJiAodGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRlbXApOyAvL3NvbWUgYnJvd3NlcnMgcHJpb3JpdGl6ZSBDU1MgdHJhbnNmb3JtcyBvdmVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLiBXaGVuIHdlIHNlbnNlIHRoYXQgdGhlIHVzZXIgaGFzIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQsIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gdGhpcyB3YXkgKG90aGVyd2lzZSBzb21lIGJyb3dzZXIgc2ltcGx5IHdvbid0IHJlbmRlciB0aGUgIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG59LFxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUsIHJlbGF0aXZlKSB7XG4gIHZhciBjYXAgPSAzNjAsXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSAqIChpc1N0cmluZyAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhZFwiKSA/IF9SQUQyREVHIDogMSksXG4gICAgICBjaGFuZ2UgPSByZWxhdGl2ZSA/IGVuZE51bSAqIHJlbGF0aXZlIDogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICBmaW5hbFZhbHVlID0gc3RhcnROdW0gKyBjaGFuZ2UgKyBcImRlZ1wiLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcHQ7XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICBjaGFuZ2UgJT0gY2FwO1xuXG4gICAgICBpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlICsgY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgLSBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgcHQudSA9IFwiZGVnXCI7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hc3NpZ24gPSBmdW5jdGlvbiBfYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgaGF2ZSBPYmplY3QuYXNzaWduKCksIHNvIHdlIHJlY3JlYXRlIGl0IGhlcmUuXG4gIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgdGFyZ2V0W3BdID0gc291cmNlW3BdO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3RhcnRDYWNoZSA9IF9hc3NpZ24oe30sIHRhcmdldC5fZ3NhcCksXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgZW5kQ2FjaGUsXG4gICAgICBwLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBlbmROdW0sXG4gICAgICBzdGFydFVuaXQsXG4gICAgICBlbmRVbml0O1xuXG4gIGlmIChzdGFydENhY2hlLnN2Zykge1xuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuXG4gICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdGFydFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgIGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcbiAgfVxuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBlbmRDYWNoZSwgcCwgc3RhcnROdW0sIGVuZE51bSAtIHN0YXJ0TnVtLCBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICBwbHVnaW4uX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cblxuICBfYXNzaWduKGVuZENhY2hlLCBzdGFydENhY2hlKTtcbn07IC8vIGhhbmRsZSBzcGxpdHRpbmcgYXBhcnQgcGFkZGluZywgbWFyZ2luLCBib3JkZXJXaWR0aCwgYW5kIGJvcmRlclJhZGl1cyBpbnRvIHRoZWlyIDQgY29tcG9uZW50cy4gRmlyZWZveCwgZm9yIGV4YW1wbGUsIHdvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5IC0gaXQgd2lsbCBvbmx5IGRvIGJvcmRlclRvcExlZnRSYWRpdXMgYW5kIHRoZSBvdGhlciBjb3JuZXJzLiBXZSBhbHNvIHdhbnQgdG8gaGFuZGxlIHBhZGRpbmdUb3AsIG1hcmdpbkxlZnQsIGJvcmRlclJpZ2h0V2lkdGgsIGV0Yy5cblxuXG5fZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gIHZhciB0ID0gXCJUb3BcIixcbiAgICAgIHIgPSBcIlJpZ2h0XCIsXG4gICAgICBiID0gXCJCb3R0b21cIixcbiAgICAgIGwgPSBcIkxlZnRcIixcbiAgICAgIHByb3BzID0gKGluZGV4IDwgMyA/IFt0LCByLCBiLCBsXSA6IFt0ICsgbCwgdCArIHIsIGIgKyByLCBiICsgbF0pLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcbiAgfSk7XG5cbiAgX3NwZWNpYWxQcm9wc1tpbmRleCA+IDEgPyBcImJvcmRlclwiICsgbmFtZSA6IG5hbWVdID0gZnVuY3Rpb24gKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGEsIHZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcbiAgICAgIC8vIGdldHRlciwgcGFzc2VkIHRhcmdldCwgcHJvcGVydHksIGFuZCB1bml0IChmcm9tIF9nZXQoKSlcbiAgICAgIGEgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XG4gICAgICB9KTtcbiAgICAgIHZhcnMgPSBhLmpvaW4oXCIgXCIpO1xuICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG4gICAgfVxuXG4gICAgYSA9IChlbmRWYWx1ZSArIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICB2YXJzID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgcmV0dXJuIHZhcnNbcHJvcF0gPSBhW2ldID0gYVtpXSB8fCBhWyhpIC0gMSkgLyAyIHwgMF07XG4gICAgfSk7XG4gICAgcGx1Z2luLmluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbik7XG4gIH07XG59KTtcblxuZXhwb3J0IHZhciBDU1NQbHVnaW4gPSB7XG4gIG5hbWU6IFwiY3NzXCIsXG4gIHJlZ2lzdGVyOiBfaW5pdENvcmUsXG4gIHRhcmdldFRlc3Q6IGZ1bmN0aW9uIHRhcmdldFRlc3QodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGU7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHN0YXJ0QXQgPSB0d2Vlbi52YXJzLnN0YXJ0QXQsXG4gICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgIGVuZFZhbHVlLFxuICAgICAgICBlbmROdW0sXG4gICAgICAgIHN0YXJ0TnVtLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzcGVjaWFsUHJvcCxcbiAgICAgICAgcCxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRVbml0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkLFxuICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4sXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgIGhhc1ByaW9yaXR5O1xuICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHNvbWVvbmUgaGFyZC1jb2RlcyBhIGNvbXBsZXggdmFsdWUgYXMgdGhlIHN0YXJ0LCBsaWtlIHRvcDogXCJjYWxjKDJ2aCAvIDIpXCIuIFdpdGhvdXQgdGhpcywgaXQnZCB1c2UgdGhlIGNvbXB1dGVkIHZhbHVlIChhbHdheXMgaW4gcHgpXG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IHR5cGVvZiBzdGFydEF0W3BdID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEF0W3BdLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogc3RhcnRBdFtwXTtcbiAgICAgICAgICBwIGluIF9jb25maWcudW5pdHMgJiYgIWdldFVuaXQoc3RhcnRWYWx1ZSkgJiYgKHN0YXJ0VmFsdWUgKz0gX2NvbmZpZy51bml0c1twXSk7IC8vIGZvciBjYXNlcyB3aGVuIHNvbWVvbmUgcGFzc2VzIGluIGEgdW5pdGxlc3MgdmFsdWUgbGlrZSB7eDogMTAwfTsgaWYgd2UgdHJ5IHNldHRpbmcgdHJhbnNsYXRlKDEwMCwgMHB4KSBpdCB3b24ndCB3b3JrLlxuXG4gICAgICAgICAgKHN0YXJ0VmFsdWUgKyBcIlwiKS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApKTsgLy8gY2FuJ3Qgd29yayB3aXRoIHJlbGF0aXZlIHZhbHVlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuICAgICAgICByZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblxuICAgICAgICBpZiAocCBpbiBfcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgICAgICAgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgYWxvbmcgd2l0aCBvcGFjaXR5LiBXZSBzdGlsbCBhbGxvdyB0aGUgb3BhY2l0eSB2YWx1ZSB0byBwYXNzIHRocm91Z2ggYW5kIGdldCB0d2VlbmVkLlxuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7XG4gICAgICAgICAgICAgIC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG4gICAgICAgICAgICAgIHN0YXJ0TnVtID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCAhPT0gXCJzY2FsZVwiICYmIHAgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIHAgPSBfcHJvcGVydHlBbGlhc2VzW3BdO1xuICAgICAgICAgICAgfnAuaW5kZXhPZihcIixcIikgJiYgKHAgPSBwLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7IC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybVByb3BUd2Vlbikge1xuICAgICAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gICAgICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gJiYgIXZhcnMucGFyc2VUcmFuc2Zvcm0gfHwgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdmFycy5wYXJzZVRyYW5zZm9ybSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgZ3NhcC5zZXQoLi4uIHt0cmFuc2Zvcm06XCJ0cmFuc2xhdGVYKDUwdncpXCJ9KSwgdGhlIF9nZXQoKSBjYWxsIGRvZXNuJ3QgcGFyc2UgdGhlIHRyYW5zZm9ybSwgdGh1cyBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gd29uJ3QgYmUgc2V0IHlldCBzbyBmb3JjZSB0aGUgcGFyc2luZyBvZiB0aGUgdHJhbnNmb3JtIGhlcmUuXG5cbiAgICAgICAgICAgIHNtb290aCA9IHZhcnMuc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGg7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4gPSB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHN0eWxlLCBfdHJhbnNmb3JtUHJvcCwgMCwgMSwgY2FjaGUucmVuZGVyVHJhbnNmb3JtLCBjYWNoZSwgMCwgLTEpOyAvL3RoZSBmaXJzdCB0aW1lIHRocm91Z2gsIGNyZWF0ZSB0aGUgcmVuZGVyaW5nIFByb3BUd2VlbiBzbyB0aGF0IGl0IHJ1bnMgTEFTVCAoaW4gdGhlIGxpbmtlZCBsaXN0LCB3ZSBrZWVwIGFkZGluZyB0byB0aGUgYmVnaW5uaW5nKVxuXG4gICAgICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4uZGVwID0gMTsgLy9mbGFnIGl0IGFzIGRlcGVuZGVudCBzbyB0aGF0IGlmIHRoaW5ncyBnZXQga2lsbGVkL292ZXJ3cml0dGVuIGFuZCB0aGlzIGlzIHRoZSBvbmx5IFByb3BUd2VlbiBsZWZ0LCB3ZSBjYW4gc2FmZWx5IGtpbGwgdGhlIHdob2xlIHR3ZWVuLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwID09PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgY2FjaGUsIFwic2NhbGVZXCIsIGNhY2hlLnNjYWxlWSwgcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIGNhY2hlLnNjYWxlWSk7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuICAgICAgICAgICAgcCArPSBcIlhcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpOyAvL2luIGNhc2Ugc29tZXRoaW5nIGxpa2UgXCJsZWZ0IHRvcFwiIG9yIFwiYm90dG9tIHJpZ2h0XCIgaXMgcGFzc2VkIGluLiBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VzLlxuXG4gICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAwLCBzbW9vdGgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxuXG4gICAgICAgICAgICAgIGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4gJiYgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwiek9yaWdpblwiLCBjYWNoZS56T3JpZ2luLCBlbmRVbml0KTtcblxuICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgcCwgX2ZpcnN0VHdvT25seShzdGFydFZhbHVlKSwgX2ZpcnN0VHdvT25seShlbmRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic3ZnT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgaW4gX3JvdGF0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCBjYWNoZSwgcCwgc3RhcnROdW0sIGVuZFZhbHVlLCByZWxhdGl2ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzbW9vdGhPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwic21vb3RoXCIsIGNhY2hlLnNtb290aCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZm9yY2UzRFwiKSB7XG4gICAgICAgICAgICBjYWNoZVtwXSA9IGVuZFZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBfYWRkUmF3VHJhbnNmb3JtUFRzKHRoaXMsIGVuZFZhbHVlLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIHAgPSBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkIHx8IChlbmROdW0gfHwgZW5kTnVtID09PSAwKSAmJiAoc3RhcnROdW0gfHwgc3RhcnROdW0gPT09IDApICYmICFfY29tcGxleEV4cC50ZXN0KGVuZFZhbHVlKSAmJiBwIGluIHN0eWxlKSB7XG4gICAgICAgICAgc3RhcnRVbml0ID0gKHN0YXJ0VmFsdWUgKyBcIlwiKS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgICBlbmROdW0gfHwgKGVuZE51bSA9IDApOyAvLyBwcm90ZWN0IGFnYWluc3QgTmFOXG5cbiAgICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSkgfHwgKHAgaW4gX2NvbmZpZy51bml0cyA/IF9jb25maWcudW5pdHNbcF0gOiBzdGFydFVuaXQpO1xuICAgICAgICAgIHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpKTtcbiAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGlzVHJhbnNmb3JtUmVsYXRlZCA/IGNhY2hlIDogc3R5bGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHRhcmdldFtwXSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21pc3NpbmdQbHVnaW4ocCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHRoaXMpO1xuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuXG4oZnVuY3Rpb24gKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcbiAgdmFyIGFsbCA9IF9mb3JFYWNoTmFtZShwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbiArIFwiLFwiICsgb3RoZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjtcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cbiAgX2ZvckVhY2hOYW1lKGFsaWFzZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdChcIjpcIik7XG4gICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuICB9KTtcbn0pKFwieCx5LHosc2NhbGUsc2NhbGVYLHNjYWxlWSx4UGVyY2VudCx5UGVyY2VudFwiLCBcInJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblksc2tld1gsc2tld1lcIiwgXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbixmb3JjZTNELHNtb290aE9yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcIjA6dHJhbnNsYXRlWCwxOnRyYW5zbGF0ZVksMjp0cmFuc2xhdGVaLDg6cm90YXRlLDg6cm90YXRpb25aLDg6cm90YXRlWiw5OnJvdGF0ZVgsMTA6cm90YXRlWVwiKTtcblxuX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwiO1xufSk7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/gsap/CSSPlugin.js\n')},"../node_modules/gsap/gsap-core.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSCache", function() { return GSCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return Timeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTween", function() { return PropTween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return Power0; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return Power1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return Power2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return Power3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return Power4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return Linear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return Quad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return Cubic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return Quart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return Quint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return Strong; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return Elastic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return Back; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return SteppedEase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return Sine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return Expo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return Circ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return Tween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return Tween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return Timeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return Timeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapYoyo", function() { return wrapYoyo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distribute", function() { return distribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnit", function() { return getUnit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitColor", function() { return splitColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapRange", function() { return mapRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitize", function() { return unitize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getProperty", function() { return _getProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numExp", function() { return _numExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numWithUnitExp", function() { return _numWithUnitExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isString", function() { return _isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isUndefined", function() { return _isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_renderComplexString", function() { return _renderComplexString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_relExp", function() { return _relExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_setDefaults", function() { return _setDefaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_removeLinkedListItem", function() { return _removeLinkedListItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_forEachName", function() { return _forEachName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_sortPropTweensByPriority", function() { return _sortPropTweensByPriority; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorStringFilter", function() { return _colorStringFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_replaceRandom", function() { return _replaceRandom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_checkPlugin", function() { return _checkPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_plugins", function() { return _plugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ticker", function() { return _ticker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_config", function() { return _config; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_roundModifier", function() { return _roundModifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_round", function() { return _round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_missingPlugin", function() { return _missingPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getSetter", function() { return _getSetter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getCache", function() { return _getCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorExp", function() { return _colorExp; });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/*!\n * GSAP 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar _config = {\n  autoSleep: 120,\n  force3D: "auto",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: ""\n  }\n},\n    _defaults = {\n  duration: .5,\n  overwrite: false,\n  delay: 0\n},\n    _suppressOverwrites,\n    _bigNum = 1e8,\n    _tinyNum = 1 / _bigNum,\n    _2PI = Math.PI * 2,\n    _HALF_PI = _2PI / 4,\n    _gsID = 0,\n    _sqrt = Math.sqrt,\n    _cos = Math.cos,\n    _sin = Math.sin,\n    _isString = function _isString(value) {\n  return typeof value === "string";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === "function";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === "number";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === "undefined";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === "object";\n},\n    _isNotFalse = function _isNotFalse(value) {\n  return value !== false;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== "undefined";\n},\n    _isFuncOrString = function _isFuncOrString(value) {\n  return _isFunction(value) || _isString(value);\n},\n    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},\n    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray,\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n    //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n    _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\n    //duplicate so that while we\'re looping through matches from exec(), it doesn\'t contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/,\n    _delimitedValueExp = /[#\\-+.]*\\b[a-z\\d-=+%.]+/gi,\n    _unitExp = /[\\d.+\\-=]+(?:e[-+]\\d*)*/i,\n    _globalTimeline,\n    _win,\n    _coreInitted,\n    _doc,\n    _globals = {},\n    _installScope = {},\n    _coreReady,\n    _install = function _install(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n},\n    _missingPlugin = function _missingPlugin(property, value) {\n  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");\n},\n    _warn = function _warn(message, suppress) {\n  return !suppress && console.warn(message);\n},\n    _addGlobal = function _addGlobal(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n},\n    _emptyFunc = function _emptyFunc() {\n  return 0;\n},\n    _reservedProps = {},\n    _lazyTweens = [],\n    _lazyLookup = {},\n    _lastRenderedFrame,\n    _plugins = {},\n    _effects = {},\n    _nextGCFrame = 30,\n    _harnessPlugins = [],\n    _callbackNames = "",\n    _harness = function _harness(targets) {\n  var target = targets[0],\n      harnessPlugin,\n      i;\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\n\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n    i = _harnessPlugins.length;\n\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n    harnessPlugin = _harnessPlugins[i];\n  }\n\n  i = targets.length;\n\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n\n  return targets;\n},\n    _getCache = function _getCache(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n},\n    _getProperty = function _getProperty(target, property, v) {\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n},\n    _forEachName = function _forEachName(names, func) {\n  return (names = names.split(",")).forEach(func) || names;\n},\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it\'s simply a boolean search.\n  var l = toFind.length,\n      i = 0;\n\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n\n  return i < l;\n},\n    _parseVars = function _parseVars(params, type, parent) {\n  //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()\n  var isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars;\n\n  isLegacy && (vars.duration = params[1]);\n  vars.parent = parent;\n\n  if (type) {\n    irVars = vars;\n\n    while (parent && !("immediateRender" in irVars)) {\n      // inheritance hasn\'t happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that\'d exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We\'re paying a small kb price here to gain speed.\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars\n  }\n\n  return vars;\n},\n    _lazyRender = function _lazyRender() {\n  var l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n},\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n  _lazyTweens.length && _lazyRender();\n  animation.render(time, suppressEvents, force);\n  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n},\n    _numericIfPossible = function _numericIfPossible(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);\n  }\n},\n    _merge = function _merge(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n\n  return base;\n},\n    _mergeDeep = function _mergeDeep(base, toMerge) {\n  for (var p in toMerge) {\n    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n  }\n\n  return base;\n},\n    _copyExcluding = function _copyExcluding(obj, excluding) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n\n  return copy;\n},\n    _inheritDefaults = function _inheritDefaults(vars) {\n  var parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;\n\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n\n  return vars;\n},\n    _arraysMatch = function _arraysMatch(a1, a2) {\n  var i = a1.length,\n      match = i === a2.length;\n\n  while (match && i-- && a1[i] === a2[i]) {}\n\n  return i < 0;\n},\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = "_first";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = "_last";\n  }\n\n  var prev = parent[lastProp],\n      t;\n\n  if (sortBy) {\n    t = child[sortBy];\n\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n},\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = "_first";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = "_last";\n  }\n\n  var prev = child._prev,\n      next = child._next;\n\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n\n  child._next = child._prev = child.parent = null; // don\'t delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn\'t in a linked list.\n},\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);\n  child._act = 0;\n},\n    _uncache = function _uncache(animation, child) {\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n    var a = animation;\n\n    while (a) {\n      a._dirty = 1;\n      a = a.parent;\n    }\n  }\n\n  return animation;\n},\n    _recacheAncestors = function _recacheAncestors(animation) {\n  var parent = animation.parent;\n\n  while (parent && parent.parent) {\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween\'s timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween\'s render (startTime). Doesn\'t matter for the root timeline though.\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n\n  return animation;\n},\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n},\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n},\n    // feed in the totalTime and cycleDuration and it\'ll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n  var whole = Math.floor(tTime /= cycleDuration);\n  return tTime && whole === tTime ? whole - 1 : whole;\n},\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n},\n    _setEnd = function _setEnd(animation) {\n  return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n},\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n  // adjusts the animation\'s _start and _end according to the provided totalTime (only if the parent\'s smoothChildTiming is true and the animation isn\'t paused). It doesn\'t do any rendering or forcing things back into parent timelines, etc. - that\'s what totalTime() is for.\n  var parent = animation._dp;\n\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n    _setEnd(animation);\n\n    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent\'s cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n  }\n\n  return animation;\n},\n\n/*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/\n_postAddChecks = function _postAddChecks(timeline, child) {\n  var t;\n\n  if (child._time || child._initted && !child._dur) {\n    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it\'s at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline\'s when appropriate.\n\n\n  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n    //in case any of the ancestors had completed but should now be enabled...\n    if (timeline._dur < timeline.duration()) {\n      t = timeline;\n\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it\'s currently zero, though, it may not be scheduled to render until later so there\'s no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n\n        t = t._dp;\n      }\n    }\n\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn\'t changed (we\'re adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn\'t want things to get triggered in the wrong order.\n  }\n},\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _round(position + child._delay);\n  child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);\n\n  timeline._recent = child;\n  skipChecks || _postAddChecks(timeline, child);\n  return timeline;\n},\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n},\n    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {\n  _initTween(tween, totalTime);\n\n  if (!tween._initted) {\n    return 1;\n  }\n\n  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n\n    tween._lazy = [totalTime, suppressEvents];\n    return 1;\n  }\n},\n    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n  var parent = _ref.parent;\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n},\n    // check parent\'s _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn\'t force the ratio back to 0\n_renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) || (tween._ts < 0 || tween._dp._ts < 0) && tween.data !== "isFromStart" && tween.data !== "isStart") ? 0 : 1,\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0.\n  repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n\n  if (repeatDelay && tween._repeat) {\n    // in case there\'s a zero-duration tween that has a repeat with a repeatDelay\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    prevIteration = _animationCycle(tween._tTime, repeatDelay);\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n\n    if (iteration !== prevIteration) {\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n\n  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {\n      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn\'t need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n      return;\n    }\n\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON\'T fire callbacks otherwise they\'ll seem like duplicates.\n\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    pt = tween._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");\n\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n\n      if (!suppressEvents) {\n        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);\n\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n},\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n  var child;\n\n  if (time > prevTime) {\n    child = animation._first;\n\n    while (child && child._start <= time) {\n      if (!child._dur && child.data === "isPause" && child._start > prevTime) {\n        return child;\n      }\n\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n\n    while (child && child._start >= time) {\n      if (!child._dur && child.data === "isPause" && child._start < prevTime) {\n        return child;\n      }\n\n      child = child._prev;\n    }\n  }\n},\n    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n  var repeat = animation._repeat,\n      dur = _round(duration) || 0,\n      totalProgress = animation._tTime / animation._tDur;\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);\n  totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);\n  skipUncache || _uncache(animation.parent, animation);\n  return animation;\n},\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n},\n    _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc\n},\n    _parsePosition = function _parsePosition(animation, position) {\n  var labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there\'s a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child\'s endTime should be used instead.\n  i,\n      offset;\n\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    //if the string is a number like "1", check to see if there\'s a label with that name, otherwise interpret it as a number (absolute value).\n    i = position.charAt(0);\n\n    if (i === "<" || i === ">") {\n      return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);\n    }\n\n    i = position.indexOf("=");\n\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n\n    offset = +(position.charAt(i - 1) + position.substr(i + 1));\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;\n  }\n\n  return position == null ? clippedDuration : +position;\n},\n    _conditionalReturn = function _conditionalReturn(value, func) {\n  return value || value === 0 ? func(value) : func;\n},\n    _clamp = function _clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n},\n    getUnit = function getUnit(value) {\n  if (typeof value !== "string") {\n    return "";\n  }\n\n  var v = _unitExp.exec(value);\n\n  return v ? value.substr(v.index + v[0].length) : "";\n},\n    // note: protect against padded numbers as strings, like "100.100". That shouldn\'t return "00" as the unit. If it\'s numeric, return no unit.\nclamp = function clamp(min, max, value) {\n  return _conditionalReturn(value, function (v) {\n    return _clamp(min, max, v);\n  });\n},\n    _slice = [].slice,\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\n  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n},\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n\n  return ar.forEach(function (value) {\n    var _accumulator;\n\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n},\n    //takes any value and returns an array. If it\'s a string (and leaveStrings isn\'t true), it\'ll use document.querySelectorAll() and convert that to an array. It\'ll also accept iterables like jQuery objects.\ntoArray = function toArray(value, leaveStrings) {\n  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n},\n    shuffle = function shuffle(a) {\n  return a.sort(function () {\n    return .5 - Math.random();\n  });\n},\n    // alternative that\'s a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n\n  var vars = _isObject(v) ? v : {\n    each: v\n  },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that\'s chunked out among them all.\n  ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: .5,\n      edges: .5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n\n  return function (i, target, a) {\n    var l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n\n    if (!distances) {\n      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n      if (!wrapAt) {\n        max = -_bigNum;\n\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n\n        wrapAt--;\n      }\n\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n\n      from === "random" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n  };\n},\n    _roundModifier = function _roundModifier(v) {\n  //pass in 0.1 get a function that\'ll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()\n\n  return function (raw) {\n    var n = Math.round(parseFloat(raw) / v) * v * p;\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n  };\n},\n    snap = function snap(snapTo, value) {\n  var isArray = _isArray(snapTo),\n      radius,\n      is2D;\n\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius; //performance optimization so we don\'t have to Math.sqrt() in the loop.\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function (raw) {\n    var x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n},\n    random = function random(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n},\n    pipe = function pipe() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    return functions.reduce(function (v, f) {\n      return f(v);\n    }, value);\n  };\n},\n    unitize = function unitize(func, unit) {\n  return function (value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n},\n    normalize = function normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n},\n    _wrapArray = function _wrapArray(a, wrapper, value) {\n  return _conditionalReturn(value, function (index) {\n    return a[~~wrapper(index)];\n  });\n},\n    wrap = function wrap(min, max, value) {\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n    return (range + (value - min) % range) % range + min;\n  });\n},\n    wrapYoyo = function wrapYoyo(min, max, value) {\n  var range = max - min,\n      total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n    value = (total + (value - min) % total) % total || 0;\n    return min + (value > range ? total - value : value);\n  });\n},\n    _replaceRandom = function _replaceRandom(value) {\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n  var prev = 0,\n      s = "",\n      i,\n      nums,\n      end,\n      isArray;\n\n  while (~(i = value.indexOf("random(", prev))) {\n    end = value.indexOf(")", i);\n    isArray = value.charAt(i + 7) === "[";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n\n  return s + value.substr(prev, value.length - prev);\n},\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin,\n      outRange = outMax - outMin;\n  return _conditionalReturn(value, function (value) {\n    return outMin + ((value - inMin) / inRange * outRange || 0);\n  });\n},\n    interpolate = function interpolate(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function (p) {\n    return (1 - p) * start + p * end;\n  };\n\n  if (!func) {\n    var isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n\n    progress === true && (mutate = 1) && (progress = null);\n\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n      }\n\n      l--;\n\n      func = function func(p) {\n        p *= l;\n        var i = Math.min(il, ~~p);\n        return interpolators[i](p - i);\n      };\n\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, "get", end[p]);\n      }\n\n      func = function func(p) {\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\n      };\n    }\n  }\n\n  return _conditionalReturn(progress, func);\n},\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n  //used for nextLabel() and previousLabel()\n  var labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n\n  return label;\n},\n    _callback = function _callback(animation, type, executeLazyFirst) {\n  var v = animation.vars,\n      callback = v[type],\n      params,\n      scope;\n\n  if (!callback) {\n    return;\n  }\n\n  params = v[type + "Params"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n\n  return params ? callback.apply(scope, params) : callback.call(scope);\n},\n    _interrupt = function _interrupt(animation) {\n  _removeFromParent(animation);\n\n  animation.scrollTrigger && animation.scrollTrigger.kill(false);\n  animation.progress() < 1 && _callback(animation, "onInterrupt");\n  return animation;\n},\n    _quickTween,\n    _createPlugin = function _createPlugin(config) {\n  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n\n  var name = config.name,\n      isFunc = _isFunction(config),\n      Plugin = name && !isFunc && config.init ? function () {\n    this._props = [];\n  } : config,\n      //in case someone passes in an object that\'s not a plugin, like CustomEase\n  instanceDefaults = {\n    init: _emptyFunc,\n    render: _renderPropTweens,\n    add: _addPropTween,\n    kill: _killPropTweensOf,\n    modifier: _addPluginModifier,\n    rawVars: 0\n  },\n      statics = {\n    targetTest: 0,\n    get: 0,\n    getSetter: _getSetter,\n    aliases: {},\n    register: 0\n  };\n\n  _wake();\n\n  if (config !== Plugin) {\n    if (_plugins[name]) {\n      return;\n    }\n\n    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n\n\n    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n\n\n    _plugins[Plugin.prop = name] = Plugin;\n\n    if (config.targetTest) {\n      _harnessPlugins.push(Plugin);\n\n      _reservedProps[name] = 1;\n    }\n\n    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin\n  }\n\n  _addGlobal(name, Plugin);\n\n  config.register && config.register(gsap, Plugin, PropTween);\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */\n_255 = 255,\n    _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n},\n    _hue = function _hue(h, m1, m2) {\n  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n},\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n\n  if (!a) {\n    if (v.substr(-1) === ",") {\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we\'d need to do it to the beginning and ending values plus it wouldn\'t provide protection from other potential scenarios like if the user passes in a similar value.\n      v = v.substr(0, v.length - 1);\n    }\n\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === "#") {\n      if (v.length < 6) {\n        //for shorthand like #9F0 or #9F0F (could have alpha)\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");\n      }\n\n      if (v.length === 9) {\n        // hex with alpha, like #fd5e53ff\n        a = parseInt(v.substr(1, 6), 16);\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n      }\n\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === "hsl") {\n      a = wasHSL = v.match(_strictNumExp);\n\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n        a.length > 3 && (a[3] *= 1); //cast as number\n\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf("=")) {\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n\n    a = a.map(Number);\n  }\n\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n\n    a[0] = ~~(h + .5);\n    a[1] = ~~(s * 100 + .5);\n    a[2] = ~~(l * 100 + .5);\n  }\n\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n},\n    _colorOrderData = function _colorOrderData(v) {\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there\'s a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n  var values = [],\n      c = [],\n      i = -1;\n  v.split(_colorExp).forEach(function (v) {\n    var a = v.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n},\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n  var result = "",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? "hsla(" : "rgba(",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n\n  if (!colors) {\n    return s;\n  }\n\n  colors = colors.map(function (color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";\n  });\n\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);\n      l = shell.length - 1;\n\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n\n  return result + shell[l];\n},\n    _colorExp = function () {\n  var s = "(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b",\n      //we\'ll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n  p;\n\n  for (p in _colorLookup) {\n    s += "|" + p + "\\\\b";\n  }\n\n  return new RegExp(s + ")", "gi");\n}(),\n    _hslExp = /hsl[a]?\\(/,\n    _colorStringFilter = function _colorStringFilter(a) {\n  var combined = a.join(" "),\n      toHSL;\n  _colorExp.lastIndex = 0;\n\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n\n    return true;\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */\n_tickerActive,\n    _ticker = function () {\n  var _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1000 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _delta,\n      _i,\n      _tick = function _tick(v) {\n    var elapsed = _getTime() - _lastUpdate,\n        manual = v === true,\n        overlap,\n        dispatch,\n        time,\n        frame;\n\n    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);\n    _lastUpdate += elapsed;\n    time = _lastUpdate - _startTime;\n    overlap = time - _nextTime;\n\n    if (overlap > 0 || manual) {\n      frame = ++_self.frame;\n      _delta = time - _self.time * 1000;\n      _self.time = time = time / 1000;\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n      dispatch = 1;\n    }\n\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we\'re using a setTimeout() that\'s based on 16.7ms, it\'d technically take 31.7ms between frames otherwise.\n\n    if (dispatch) {\n      for (_i = 0; _i < _listeners.length; _i++) {\n        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it\'d throw things off in the loop.\n        _listeners[_i](time, _delta, frame, v);\n      }\n    }\n  };\n\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    deltaRatio: function deltaRatio(fps) {\n      return _delta / (1000 / (fps || 60));\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n          _raf = _win.requestAnimationFrame;\n        }\n\n        _id && _self.sleep();\n\n        _req = _raf || function (f) {\n          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n        };\n\n        _tickerActive = 1;\n\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited\n\n      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);\n    },\n    fps: function fps(_fps) {\n      _gap = 1000 / (_fps || 240);\n      _nextTime = _self.time * 1000 + _gap;\n    },\n    add: function add(callback) {\n      _listeners.indexOf(callback) < 0 && _listeners.push(callback);\n\n      _wake();\n    },\n    remove: function remove(callback) {\n      var i;\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n    },\n    _listeners: _listeners\n  };\n  return _self;\n}(),\n    _wake = function _wake() {\n  return !_tickerActive && _ticker.wake();\n},\n    //also ensures the core classes are initialized.\n\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/\n_easeMap = {},\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n    _quotesExp = /["\']/g,\n    _parseObjectInString = function _parseObjectInString(value) {\n  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n  var obj = {},\n      split = value.substr(1, value.length - 3).split(":"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n\n  return obj;\n},\n    _valueInParentheses = function _valueInParentheses(value) {\n  var open = value.indexOf("(") + 1,\n      close = value.indexOf(")"),\n      nested = value.indexOf("(", open);\n  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);\n},\n    _configEaseFromString = function _configEaseFromString(name) {\n  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it\'ll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n  var split = (name + "").split("("),\n      ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;\n},\n    _invertEase = function _invertEase(ease) {\n  return function (p) {\n    return 1 - ease(1 - p);\n  };\n},\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n  var child = timeline._first,\n      ease;\n\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n\n    child = child._next;\n  }\n},\n    _parseEase = function _parseEase(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n},\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut(p) {\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n\n  var ease = {\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut\n  },\n      lowercaseName;\n\n  _forEachName(names, function (name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];\n    }\n  });\n\n  return ease;\n},\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n  return function (p) {\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n  };\n},\n    _configElastic = function _configElastic(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn\'t work right and the curve starts at 1.\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = function easeOut(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  },\n      ease = type === "out" ? easeOut : type === "in" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  p2 = _2PI / p2; //precalculate to optimize\n\n  ease.config = function (amplitude, period) {\n    return _configElastic(type, amplitude, period);\n  };\n\n  return ease;\n},\n    _configBack = function _configBack(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n\n  var easeOut = function easeOut(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  },\n      ease = type === "out" ? easeOut : type === "in" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  ease.config = function (overshoot) {\n    return _configBack(type, overshoot);\n  };\n\n  return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n\n_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {\n  var power = i < 5 ? i + 1 : i;\n\n  _insertEase(name + ",Power" + (power - 1), i ? function (p) {\n    return Math.pow(p, power);\n  } : function (p) {\n    return p;\n  }, function (p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function (p) {\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());\n\n(function (n, c) {\n  var n1 = 1 / c,\n      n2 = 2 * n1,\n      n3 = 2.5 * n1,\n      easeOut = function easeOut(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n  };\n\n  _insertEase("Bounce", function (p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n\n_insertEase("Expo", function (p) {\n  return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n\n_insertEase("Circ", function (p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n\n_insertEase("Sine", function (p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n\n_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());\n\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n\n    var p1 = 1 / steps,\n        p2 = steps + (immediateStart ? 0 : 1),\n        p3 = immediateStart ? 1 : 0,\n        max = 1 - _tinyNum;\n    return function (p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap["quad.out"];\n\n_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {\n  return _callbackNames += name + "," + name + "Params,";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\n\n\nvar GSCache = function GSCache(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nvar Animation = /*#__PURE__*/function () {\n  function Animation(vars, time) {\n    var parent = vars.parent || _globalTimeline;\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      // TODO: repeat: Infinity on a timeline\'s children must flag that timeline internally and affect its totalDuration, otherwise it\'ll stop in the negative direction when reaching the start.\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n\n    this._ts = 1;\n\n    _setDuration(this, +vars.duration, 1, 1);\n\n    this.data = vars.data;\n    _tickerActive || _ticker.wake();\n    parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);\n    vars.reversed && this.reverse();\n    vars.paused && this.paused(true);\n  }\n\n  var _proto = Animation.prototype;\n\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n\n    return this._delay;\n  };\n\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  };\n\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    var parent = this._dp;\n\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime);\n\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they\'re lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there\'s a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n\n      while (parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        //if the animation doesn\'t have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn\'t get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren\'t populated, thus when _init() is called there won\'t be any PropTweens (it\'ll act like the tween is non-functional)\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it\'d revert back to the original time at the pause\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it\'s worth the performance hit)\n      //   this._lock = 1;\n\n      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n      //}\n\n    }\n\n    return this;\n  };\n\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  };\n\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;\n  };\n\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;\n  };\n\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  } // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n  ;\n\n  _proto.timeScale = function timeScale(value) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it\'s reversed.\n    }\n\n    if (this._rts === value) {\n      return this;\n    }\n\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // prioritize rendering where the parent\'s playhead lines up instead of this._tTime because there could be a tween that\'s animating another tween\'s timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n\n    return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));\n  };\n\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n\n    if (this._ps !== value) {\n      this._ps = value;\n\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that\'s factored in when resuming.\n\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn\'t have smoothChildTiming, we render at the rawTime() because the startTime won\'t get updated.\n\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn\'t render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that\'ll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn\'t -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn\'t render those otherwise.\n      }\n    }\n\n    return this;\n  };\n\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n\n    return this._start;\n  };\n\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);\n  };\n\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp; // _dp = detatched parent\n\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this,\n        time = arguments.length ? rawTime : animation.rawTime();\n\n    while (animation) {\n      time = animation._start + time / (animation._ts || 1);\n      animation = animation._dp;\n    }\n\n    return time;\n  };\n\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._repeat === -2 ? Infinity : this._repeat;\n  };\n\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      this._rDelay = value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._rDelay;\n  };\n\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n\n    return this._yoyo;\n  };\n\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  };\n\n  _proto.play = function play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  };\n\n  _proto.reverse = function reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  };\n\n  _proto.pause = function pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  };\n\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n\n      return this;\n    }\n\n    return this._rts < 0;\n  };\n\n  _proto.invalidate = function invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp,\n        start = this._start,\n        rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + "Params"] = params);\n        type === "onUpdate" && (this._onUpdate = callback);\n      }\n\n      return this;\n    }\n\n    return vars[type];\n  };\n\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function (resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n          _resolve = function _resolve() {\n        var _then = self.then;\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n\n  return Animation;\n}();\n\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\n\nvar Timeline = /*#__PURE__*/function (_Animation) {\n  _inheritsLoose(Timeline, _Animation);\n\n  function Timeline(vars, time) {\n    var _this;\n\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    _this = _Animation.call(this, vars, time) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _this.parent && _postAddChecks(_this.parent, _assertThisInitialized(_this));\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n\n  var _proto2 = Timeline.prototype;\n\n  _proto2.to = function to(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  };\n\n  _proto2.from = function from(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  };\n\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));\n    return this;\n  };\n\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));\n  } //ONLY for backward compatibility! Maybe delete?\n  ;\n\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\n        dur = this._dur,\n        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n        time,\n        child,\n        next,\n        iteration,\n        cycleDuration,\n        prevPaused,\n        pauseTween,\n        timeScale,\n        prevStart,\n        prevIteration,\n        yoyo,\n        isYoyo;\n\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline\'s startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n\n      if (crossingStart) {\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there\'s a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn\'t)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005\n\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that\'s at 2.95 or 3 seconds in which wouldn\'t render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n\n\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1,\n              doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : dur;\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          !suppressEvents && this.parent && _callback(this, "onRepeat");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won\'t match. So in this edge case, prevTime won\'t match _time but that\'s okay. If it gets killed in the onRepeat, eject as well.\n            return this;\n          }\n\n          dur = this._dur; // in case the duration changed in the onRepeat\n\n          tDur = this._tDur;\n\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -0.0001;\n            this.render(prevTime, true);\n          }\n\n          this._lock = 0;\n\n          if (!this._ts && !prevPaused) {\n            return this;\n          } //in order for yoyoEase to work properly when there\'s a stagger, we must swap out the ease in each sub-tween.\n\n\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));\n\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n      }\n\n      !prevTime && time && !suppressEvents && _callback(this, "onStart");\n\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n\n        while (child) {\n          next = child._next;\n\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn\'t finish rendering, so flag zTime as negative so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n\n        while (child) {\n          next = child._prev;\n\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn\'t finish rendering, so adjust zTime so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      }\n\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it\'s SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn\'t shift.\n\n          _setEnd(this);\n\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);\n      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n\n    _isNumber(position) || (position = _parsePosition(this, position));\n\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function (obj) {\n          return _this2.add(obj, position);\n        });\n        return this;\n      }\n\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n\n    return this !== child ? _addToTimeline(this, child, position) : this; //don\'t allow a timeline to be added to itself as a child!\n  };\n\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n\n    if (tweens === void 0) {\n      tweens = true;\n    }\n\n    if (timelines === void 0) {\n      timelines = true;\n    }\n\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n\n    var a = [],\n        child = this._first;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.getById = function getById(id) {\n    var animations = this.getChildren(1, 1, 1),\n        i = animations.length;\n\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n\n    _removeLinkedListItem(this, child);\n\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    this._forcing = 1;\n\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n    this._forcing = 0;\n    return this;\n  };\n\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = "isPause";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n\n    while (child) {\n      if (child._start === position && child.data === "isPause") {\n        _removeFromParent(child);\n      }\n\n      child = child._next;\n    }\n  };\n\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive),\n        i = tweens.length;\n\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n\n    return this;\n  };\n\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n    var a = [],\n        parsedTargets = toArray(targets),\n        child = this._first,\n        isGlobalTime = _isNumber(onlyActive),\n        // a number is interpreted as a global time. If the animation spans\n    children;\n\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren\'t paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  } // potential future feature - targets() on timelines\n  // targets() {\n  // \tlet result = [];\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\n  // \treturn result;\n  // }\n  ;\n\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n\n    var tl = this,\n        endTime = _parsePosition(tl, position),\n        _vars = vars,\n        startAt = _vars.startAt,\n        _onStart = _vars.onStart,\n        onStartParams = _vars.onStartParams,\n        immediateRender = _vars.immediateRender,\n        tween = Tween.to(tl, _setDefaults({\n      ease: vars.ease || "none",\n      lazy: false,\n      immediateRender: false,\n      time: endTime,\n      overwrite: "auto",\n      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n        var duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());\n        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don\'t want to overwrite it.\n      }\n    }, vars));\n\n    return immediateRender ? tween.render(0) : tween;\n  };\n\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n\n    var child = this._first,\n        labels = this.labels,\n        p;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n\n      child = child._next;\n    }\n\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.invalidate = function invalidate() {\n    var child = this._first;\n    this._lock = 0;\n\n    while (child) {\n      child.invalidate();\n      child = child._next;\n    }\n\n    return _Animation.prototype.invalidate.call(this);\n  };\n\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n\n    var child = this._first,\n        next;\n\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  };\n\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0,\n        self = this,\n        child = self._last,\n        prevStart = _bigNum,\n        prev,\n        start,\n        parent;\n\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n\n    if (self._dirty) {\n      parent = self.parent;\n\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation\'s cache is clean before analyzing it.\n\n        start = child._start;\n\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n\n        if (start < 0 && child._ts) {\n          //children aren\'t allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n\n      self._dirty = 0;\n    }\n\n    return self._tDur;\n  };\n\n  Timeline.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n      _lastRenderedFrame = _ticker.frame;\n    }\n\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n\n        child || _ticker.sleep();\n      }\n    }\n  };\n\n  return Timeline;\n}(Animation);\n\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\n\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n  pt.b = start;\n  pt.e = end;\n  start += ""; //ensure values are strings\n\n  end += "";\n\n  if (hasRandom = ~end.indexOf("random(")) {\n    end = _replaceRandom(end);\n  }\n\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n    start = a[0];\n    end = a[1];\n  }\n\n  startNums = start.match(_complexStringNumExp) || [];\n\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === "rgba(") {\n      color = 1;\n    }\n\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : ",",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n\n  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n\n  pt.fp = funcParam;\n\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n\n  return pt;\n},\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop],\n      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n\n  if (_isString(end)) {\n    if (~end.indexOf("random(")) {\n      end = _replaceRandom(end);\n    }\n\n    if (end.charAt(1) === "=") {\n      end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);\n    }\n  }\n\n  if (parsedStart !== end) {\n    if (!isNaN(parsedStart * end)) {\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n},\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n\n  var copy = {},\n      p;\n\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n\n  return copy;\n},\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can\'t use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won\'t match what it is in each individual tween that spawns from the stagger.\n\n      i = plugin._props.length;\n\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n\n  return plugin;\n},\n    _overwritingTween,\n    //store a reference temporarily so we can avoid overwriting itself.\n_initTween = function _initTween(tween, time) {\n  var vars = tween.vars,\n      ease = vars.ease,\n      startAt = vars.startAt,\n      immediateRender = vars.immediateRender,\n      lazy = vars.lazy,\n      onUpdate = vars.onUpdate,\n      onUpdateParams = vars.onUpdateParams,\n      callbackScope = vars.callbackScope,\n      runBackwards = vars.runBackwards,\n      yoyoEase = vars.yoyoEase,\n      keyframes = vars.keyframes,\n      autoRevert = vars.autoRevert,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,\n      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n  tl && (!keyframes || !ease) && (ease = "none");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n\n  if (!tl) {\n    //if there\'s an internal timeline, skip all the parsing because we passed that task down the chain.\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it\'s a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n\n    cleanVars = _copyExcluding(vars, _reservedProps);\n    prevStartAt && prevStartAt.render(-1, true).kill();\n\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: "isStart",\n        overwrite: false,\n        parent: parent,\n        immediateRender: true,\n        lazy: _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate,\n        onUpdateParams: onUpdateParams,\n        callbackScope: callbackScope,\n        stagger: 0\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n\n\n      if (immediateRender) {\n        if (time > 0) {\n          autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn\'t revert when their parent timeline\'s playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn\'t be directly correlated to this tween\'s startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn\'t happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween\'s startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.\n        } else if (dur && !(time < 0 && prevStartAt)) {\n          time && (tween._zTime = time);\n          return; //we skip initialization here so that overwriting doesn\'t occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn\'t get placed into the timeline yet before the first render occurs and kicks in overwriting.\n        }\n      } else if (autoRevert === false) {\n        tween._startAt = 0;\n      }\n    } else if (runBackwards && dur) {\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don\'t want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n      if (prevStartAt) {\n        !autoRevert && (tween._startAt = 0);\n      } else {\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there\'s no need to force the render in this context when the _time is greater than 0\n\n        p = _setDefaults({\n          overwrite: false,\n          data: "isFromStart",\n          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that\'s setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it\'d kick back in.\n          lazy: immediateRender && _isNotFalse(lazy),\n          immediateRender: immediateRender,\n          //zero-duration tweens render immediately by default, but if we\'re not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we\'d have to render(-1) immediately after)\n          stagger: 0,\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})\n\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n        if (!immediateRender) {\n          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded\n\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n\n    tween._pt = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven\'t rendered yet, we\'ve got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n        plugin._props.forEach(function (name) {\n          ptLookup[name] = pt;\n        });\n\n        plugin.priority && (hasPriority = 1);\n      }\n\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn\'t overwrite THIS tween!!!\n\n\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin\'s init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it\'s fast and keeps file size down.\n  }\n\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n},\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n\n  if (!propertyAliases) {\n    return vars;\n  }\n\n  copy = _merge({}, vars);\n\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(",");\n      i = aliases.length;\n\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n\n  return copy;\n},\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;\n},\n    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",\n    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar Tween = /*#__PURE__*/function (_Animation2) {\n  _inheritsLoose(Tween, _Animation2);\n\n  function Tween(targets, vars, time, skipInherit) {\n    var _this3;\n\n    if (typeof vars === "number") {\n      time.duration = vars;\n      vars = time;\n      time = null;\n    }\n\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars), time) || this;\n    var _this3$vars = _this3.vars,\n        duration = _this3$vars.duration,\n        delay = _this3$vars.delay,\n        immediateRender = _this3$vars.immediateRender,\n        stagger = _this3$vars.stagger,\n        overwrite = _this3$vars.overwrite,\n        keyframes = _this3$vars.keyframes,\n        defaults = _this3$vars.defaults,\n        scrollTrigger = _this3$vars.scrollTrigger,\n        yoyoEase = _this3$vars.yoyoEase,\n        parent = _this3.parent,\n        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),\n        tl,\n        i,\n        copy,\n        l,\n        p,\n        curTarget,\n        staggerFunc,\n        staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n\n    _this3._overwrite = overwrite;\n\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: "nested",\n        defaults: defaults || {}\n      });\n      tl.kill();\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\n      tl._start = 0;\n\n      if (keyframes) {\n        _setDefaults(tl.vars.defaults, {\n          ease: "none"\n        });\n\n        keyframes.forEach(function (frame) {\n          return tl.to(parsedTargets, frame, ">");\n        });\n      } else {\n        l = parsedTargets.length;\n        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;\n\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n\n        for (i = 0; i < l; i++) {\n          copy = {};\n\n          for (p in vars) {\n            if (_staggerPropsToSkip.indexOf(p) < 0) {\n              copy[p] = vars[p];\n            }\n          }\n\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i]; //don\'t just copy duration or delay because if they\'re a string or function, we\'d end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn\'t be inside the repeat.\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n\n          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));\n        }\n\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline\'s duration is 0, we don\'t need a timeline internally!\n      }\n\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = _assertThisInitialized(_this3);\n\n      _globalTimeline.killTweensOf(parsedTargets);\n\n      _overwritingTween = 0;\n    }\n\n    parent && _postAddChecks(parent, _assertThisInitialized(_this3));\n\n    if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)\n\n      _this3.render(Math.max(0, -delay)); //in case delay is negative\n\n    }\n\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n\n  var _proto3 = Tween.prototype;\n\n  _proto3.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._tDur,\n        dur = this._dur,\n        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        time,\n        pt,\n        iteration,\n        cycleDuration,\n        prevIteration,\n        isYoyo,\n        ratio,\n        timeline,\n        yoyoEase;\n\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {\n      //this senses if we\'re crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there\'s a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn\'t)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        isYoyo = this._yoyo && iteration & 1;\n\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n        if (time === prevTime && !force && this._initted) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          return this;\n        }\n\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we\'ll jump out and get caught bouncing on each tick.\n\n            this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n\n      if (!this._initted) {\n        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can\'t leave _tTime as a negative number.\n\n          return this;\n        }\n\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n\n        this._lazy = 0;\n      }\n\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n\n      time && !prevTime && !suppressEvents && _callback(this, "onStart");\n      pt = this._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n      if (this._onUpdate && !suppressEvents) {\n        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don\'t have an onUpdate). We\'d just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it\'s not called, we do so later near the onComplete.\n\n        _callback(this, "onUpdate");\n      }\n\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");\n\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if we\'re rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          // if prevTime and tTime are zero, we shouldn\'t fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n\n  _proto3.invalidate = function invalidate() {\n    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate();\n    return _Animation2.prototype.invalidate.call(this);\n  };\n\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = "all";\n    }\n\n    if (!targets && (!vars || vars === "all")) {\n      this._lazy = this._pt = 0;\n      return this.parent ? _interrupt(this) : this;\n    }\n\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween\'s duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don\'t all add up to whatever the parent tween\'s duration was set to.\n\n      return this;\n    }\n\n    var parsedTargets = this._targets,\n        killingTargets = targets ? toArray(targets) : parsedTargets,\n        propTweenLookup = this._ptLookup,\n        firstPT = this._pt,\n        overwrittenProps,\n        curLookup,\n        curOverwriteProps,\n        props,\n        p,\n        pt,\n        i;\n\n    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === "all" && (this._pt = 0);\n      return _interrupt(this);\n    }\n\n    overwrittenProps = this._op = this._op || [];\n\n    if (vars !== "all") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n\n        _forEachName(vars, function (name) {\n          return p[name] = 1;\n        });\n\n        vars = p;\n      }\n\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n\n    i = parsedTargets.length;\n\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n\n        if (vars === "all") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n\n          if (pt) {\n            if (!("kill" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, "_pt");\n            }\n\n            delete curLookup[p];\n          }\n\n          if (curOverwriteProps !== "all") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there\'s a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren\'t any more properties tweening.\n\n    return this;\n  };\n\n  Tween.to = function to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  };\n\n  Tween.from = function from(targets, vars) {\n    return new Tween(targets, _parseVars(arguments, 1));\n  };\n\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    });\n  };\n\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n    return new Tween(targets, _parseVars(arguments, 2));\n  };\n\n  Tween.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  };\n\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n\n  return Tween;\n}(Animation);\n\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it\'d ultimately add to more confusion especially for beginners)\n// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n\n\n_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {\n  Tween[name] = function () {\n    var tl = new Timeline(),\n        params = _slice.call(arguments, 0);\n\n    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _setterPlain = function _setterPlain(target, property, value) {\n  return target[property] = value;\n},\n    _setterFunc = function _setterFunc(target, property, value) {\n  return target[property](value);\n},\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n  return target[property](data.fp, value);\n},\n    _setterAttribute = function _setterAttribute(target, property, value) {\n  return target.setAttribute(property, value);\n},\n    _getSetter = function _getSetter(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n},\n    _renderPlain = function _renderPlain(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data);\n},\n    _renderBoolean = function _renderBoolean(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n},\n    _renderComplexString = function _renderComplexString(ratio, data) {\n  var pt = data._pt,\n      s = "";\n\n  if (!ratio && data.b) {\n    //b = beginning string\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    //e = ending string\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n\n      pt = pt._next;\n    }\n\n    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.\n  }\n\n  data.set(data.t, data.p, s, data);\n},\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\n  var pt = data._pt;\n\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n},\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n  var pt = this._pt,\n      next;\n\n  while (pt) {\n    next = pt._next;\n    pt.p === property && pt.modifier(modifier, tween, target);\n    pt = next;\n  }\n},\n    _killPropTweensOf = function _killPropTweensOf(property) {\n  var pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, "_pt");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n\n    pt = next;\n  }\n\n  return !hasNonDependentRemaining;\n},\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n},\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n  var pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n\n    pt = next;\n  }\n\n  parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it\'s different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\n\n\nvar PropTween = /*#__PURE__*/function () {\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n\n    if (next) {\n      next._prev = this;\n    }\n  }\n\n  var _proto4 = PropTween.prototype;\n\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n\n    this.tween = tween;\n  };\n\n  return PropTween;\n}(); //Initialization tasks\n\n_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {\n  return _reservedProps[name] = 1;\n});\n\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: "root",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\n\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args.forEach(function (config) {\n      return _createPlugin(config);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n\n    var getter = _getCache(target || {}).get,\n        format = unit ? _passThrough : _numericIfPossible;\n\n    unit === "native" && (unit = "");\n    return !target ? target : !property ? function (property, unit, uncache) {\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n\n    if (target.length > 1) {\n      var setters = target.map(function (t) {\n        return gsap.quickSetter(t, property, unit);\n      }),\n          l = setters.length;\n      return function (value) {\n        var i = l;\n\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n\n    target = target[0] || {};\n\n    var Plugin = _plugins[property],\n        cache = _getCache(target),\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\n        // in case it\'s an alias, like "rotate" for "rotation".\n    setter = Plugin ? function (value) {\n      var p = new Plugin();\n      _quickTween._pt = 0;\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p.render(1, p);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n\n    return Plugin ? setter : function (value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref2) {\n    var name = _ref2.name,\n        effect = _ref2.effect,\n        plugins = _ref2.plugins,\n        defaults = _ref2.defaults,\n        extendTimeline = _ref2.extendTimeline;\n    (plugins || "").split(",").forEach(function (pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");\n    });\n\n    _effects[name] = function (targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    };\n\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    var tl = new Timeline(vars),\n        child,\n        next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n    _globalTimeline.remove(tl);\n\n    tl._dp = 0; //otherwise it\'ll get re-activated when adding children and be re-introduced into _globalTimeline\'s linked list (then added to itself).\n\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n\n    while (child) {\n      next = child._next;\n\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n\n      child = next;\n    }\n\n    _addToTimeline(_globalTimeline, tl, 0);\n\n    return tl;\n  },\n  utils: {\n    wrap: wrap,\n    wrapYoyo: wrapYoyo,\n    distribute: distribute,\n    random: random,\n    snap: snap,\n    normalize: normalize,\n    getUnit: getUnit,\n    clamp: clamp,\n    splitColor: splitColor,\n    toArray: toArray,\n    mapRange: mapRange,\n    pipe: pipe,\n    unitize: unitize,\n    interpolate: interpolate,\n    shuffle: shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween: PropTween,\n    globals: _addGlobal,\n    Tween: Tween,\n    Timeline: Timeline,\n    Animation: Animation,\n    getCache: _getCache,\n    _removeLinkedListItem: _removeLinkedListItem,\n    suppressOverwrites: function suppressOverwrites(value) {\n      return _suppressOverwrites = value;\n    }\n  }\n};\n\n_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {\n  return _gsap[name] = Tween[name];\n});\n\n_ticker.add(Timeline.updateRoot);\n\n_quickTween = _gsap.to({}, {\n  duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\n\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n  var pt = plugin._pt;\n\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n\n  return pt;\n},\n    _addModifiers = function _addModifiers(tween, modifiers) {\n  var targets = tween._targets,\n      p,\n      i,\n      pt;\n\n  for (p in modifiers) {\n    i = targets.length;\n\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          // is a plugin\n          pt = _getPluginPropTween(pt, p);\n        }\n\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n},\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n  return {\n    name: name,\n    rawVars: 1,\n    //don\'t pre-process function-based values or "random()" strings.\n    init: function init(target, vars, tween) {\n      tween._onInit = function (tween) {\n        var temp, p;\n\n        if (_isString(vars)) {\n          temp = {};\n\n          _forEachName(vars, function (name) {\n            return temp[name] = 1;\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.\n\n\n          vars = temp;\n        }\n\n        if (modifier) {\n          temp = {};\n\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n\n          vars = temp;\n        }\n\n        _addModifiers(tween, vars);\n      };\n    }\n  };\n}; //register core plugins\n\n\nvar gsap = _gsap.registerPlugin({\n  name: "attr",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt;\n\n    for (p in vars) {\n      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);\n      pt && (pt.op = p);\n\n      this._props.push(p);\n    }\n  }\n}, {\n  name: "endArray",\n  init: function init(target, value) {\n    var i = value.length;\n\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i]);\n    }\n  }\n}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = "3.6.1";\n_coreReady = 1;\n\nif (_windowExists()) {\n  _wake();\n}\n\nvar Power0 = _easeMap.Power0,\n    Power1 = _easeMap.Power1,\n    Power2 = _easeMap.Power2,\n    Power3 = _easeMap.Power3,\n    Power4 = _easeMap.Power4,\n    Linear = _easeMap.Linear,\n    Quad = _easeMap.Quad,\n    Cubic = _easeMap.Cubic,\n    Quart = _easeMap.Quart,\n    Quint = _easeMap.Quint,\n    Strong = _easeMap.Strong,\n    Elastic = _easeMap.Elastic,\n    Back = _easeMap.Back,\n    SteppedEase = _easeMap.SteppedEase,\n    Bounce = _easeMap.Bounce,\n    Sine = _easeMap.Sine,\n    Expo = _easeMap.Expo,\n    Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzP2QyZDkiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfY29uZmlnIiwiYXV0b1NsZWVwIiwiZm9yY2UzRCIsIm51bGxUYXJnZXRXYXJuIiwidW5pdHMiLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwiZHVyYXRpb24iLCJvdmVyd3JpdGUiLCJkZWxheSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfYmlnTnVtIiwiX3RpbnlOdW0iLCJfMlBJIiwiTWF0aCIsIlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0Iiwic3FydCIsIl9jb3MiLCJjb3MiLCJfc2luIiwic2luIiwiX2lzU3RyaW5nIiwidmFsdWUiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1VuZGVmaW5lZCIsIl9pc09iamVjdCIsIl9pc05vdEZhbHNlIiwiX3dpbmRvd0V4aXN0cyIsIndpbmRvdyIsIl9pc0Z1bmNPclN0cmluZyIsIl9pc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX3N0cmljdE51bUV4cCIsIl9udW1FeHAiLCJfbnVtV2l0aFVuaXRFeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9yZWxFeHAiLCJfZGVsaW1pdGVkVmFsdWVFeHAiLCJfdW5pdEV4cCIsIl9nbG9iYWxUaW1lbGluZSIsIl93aW4iLCJfY29yZUluaXR0ZWQiLCJfZG9jIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJnc2FwIiwiX21pc3NpbmdQbHVnaW4iLCJwcm9wZXJ0eSIsImNvbnNvbGUiLCJ3YXJuIiwiX3dhcm4iLCJtZXNzYWdlIiwic3VwcHJlc3MiLCJfYWRkR2xvYmFsIiwibmFtZSIsIm9iaiIsIl9lbXB0eUZ1bmMiLCJfcmVzZXJ2ZWRQcm9wcyIsIl9sYXp5VHdlZW5zIiwiX2xhenlMb29rdXAiLCJfbGFzdFJlbmRlcmVkRnJhbWUiLCJfcGx1Z2lucyIsIl9lZmZlY3RzIiwiX25leHRHQ0ZyYW1lIiwiX2hhcm5lc3NQbHVnaW5zIiwiX2NhbGxiYWNrTmFtZXMiLCJfaGFybmVzcyIsInRhcmdldHMiLCJ0YXJnZXQiLCJoYXJuZXNzUGx1Z2luIiwiaSIsIl9nc2FwIiwiaGFybmVzcyIsImxlbmd0aCIsInRhcmdldFRlc3QiLCJHU0NhY2hlIiwic3BsaWNlIiwiX2dldENhY2hlIiwidG9BcnJheSIsIl9nZXRQcm9wZXJ0eSIsInYiLCJnZXRBdHRyaWJ1dGUiLCJfZm9yRWFjaE5hbWUiLCJuYW1lcyIsImZ1bmMiLCJzcGxpdCIsImZvckVhY2giLCJfcm91bmQiLCJyb3VuZCIsIl9hcnJheUNvbnRhaW5zQW55IiwidG9TZWFyY2giLCJ0b0ZpbmQiLCJsIiwiaW5kZXhPZiIsIl9wYXJzZVZhcnMiLCJwYXJhbXMiLCJ0eXBlIiwicGFyZW50IiwiaXNMZWdhY3kiLCJ2YXJzSW5kZXgiLCJ2YXJzIiwiaXJWYXJzIiwiZGVmYXVsdHMiLCJpbmhlcml0IiwiaW1tZWRpYXRlUmVuZGVyIiwicnVuQmFja3dhcmRzIiwic3RhcnRBdCIsIl9sYXp5UmVuZGVyIiwiYSIsInNsaWNlIiwidHdlZW4iLCJfbGF6eSIsInJlbmRlciIsIl9sYXp5U2FmZVJlbmRlciIsImFuaW1hdGlvbiIsInRpbWUiLCJzdXBwcmVzc0V2ZW50cyIsImZvcmNlIiwiX251bWVyaWNJZlBvc3NpYmxlIiwibiIsInBhcnNlRmxvYXQiLCJtYXRjaCIsInRyaW0iLCJfcGFzc1Rocm91Z2giLCJwIiwiX3NldERlZmF1bHRzIiwiX3NldEtleWZyYW1lRGVmYXVsdHMiLCJiYXNlIiwidG9NZXJnZSIsIl9tZXJnZURlZXAiLCJfY29weUV4Y2x1ZGluZyIsImV4Y2x1ZGluZyIsImNvcHkiLCJfaW5oZXJpdERlZmF1bHRzIiwia2V5ZnJhbWVzIiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJwcmV2IiwidCIsIl9wcmV2IiwiX25leHQiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJuZXh0IiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwicmVtb3ZlIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9kdXIiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJhYnMiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJ0b3RhbFRpbWUiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl90aW1lIiwiX3Bvc3RBZGRDaGVja3MiLCJ0aW1lbGluZSIsIl9pbml0dGVkIiwicmF3VGltZSIsIl9jbGFtcCIsIl96VGltZSIsIl9hZGRUb1RpbWVsaW5lIiwicG9zaXRpb24iLCJza2lwQ2hlY2tzIiwiX2RlbGF5IiwidGltZVNjYWxlIiwiX3NvcnQiLCJfcmVjZW50IiwiX3Njcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwiU2Nyb2xsVHJpZ2dlciIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsIl9wdCIsImxhenkiLCJfdGlja2VyIiwiZnJhbWUiLCJwdXNoIiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9yZWYiLCJfbG9jayIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJhdGlvIiwiZGF0YSIsInJlcGVhdERlbGF5IiwicHQiLCJpdGVyYXRpb24iLCJwcmV2SXRlcmF0aW9uIiwiX3lveW8iLCJyZXBlYXRSZWZyZXNoIiwiaW52YWxpZGF0ZSIsIl9mcm9tIiwiciIsImQiLCJfc3RhcnRBdCIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsIl9wcm9tIiwiX2ZpbmROZXh0UGF1c2VUd2VlbiIsInByZXZUaW1lIiwiX2ZpcnN0IiwiX2xhc3QiLCJfc2V0RHVyYXRpb24iLCJza2lwVW5jYWNoZSIsImxlYXZlUGxheWhlYWQiLCJyZXBlYXQiLCJkdXIiLCJ0b3RhbFByb2dyZXNzIiwiX29uVXBkYXRlVG90YWxEdXJhdGlvbiIsIlRpbWVsaW5lIiwiX3plcm9Qb3NpdGlvbiIsImVuZFRpbWUiLCJfcGFyc2VQb3NpdGlvbiIsImxhYmVscyIsInJlY2VudCIsImNsaXBwZWREdXJhdGlvbiIsIm9mZnNldCIsImlzTmFOIiwiY2hhckF0Iiwic3Vic3RyIiwiX2NvbmRpdGlvbmFsUmV0dXJuIiwibWluIiwibWF4IiwiZ2V0VW5pdCIsImV4ZWMiLCJpbmRleCIsImNsYW1wIiwiX3NsaWNlIiwiX2lzQXJyYXlMaWtlIiwibm9uRW1wdHkiLCJub2RlVHlwZSIsIl9mbGF0dGVuIiwiYXIiLCJsZWF2ZVN0cmluZ3MiLCJhY2N1bXVsYXRvciIsIl9hY2N1bXVsYXRvciIsImFwcGx5IiwiX3dha2UiLCJjYWxsIiwicXVlcnlTZWxlY3RvckFsbCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsImVhY2giLCJlYXNlIiwiX3BhcnNlRWFzZSIsImZyb20iLCJjYWNoZSIsImlzRGVjaW1hbCIsInJhdGlvcyIsImF4aXMiLCJyYXRpb1giLCJyYXRpb1kiLCJjZW50ZXIiLCJlZGdlcyIsImVuZCIsImRpc3RhbmNlcyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwieCIsInkiLCJqIiwid3JhcEF0IiwiZ3JpZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJhbW91bnQiLCJiIiwidSIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJwb3ciLCJyYXciLCJzbmFwIiwic25hcFRvIiwicmFkaXVzIiwiaXMyRCIsInZhbHVlcyIsImluY3JlbWVudCIsImNsb3Nlc3QiLCJkeCIsImR5Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiYXJndW1lbnRzIiwiZnVuY3Rpb25zIiwiX2tleSIsInJlZHVjZSIsImYiLCJ1bml0aXplIiwidW5pdCIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXBwZXIiLCJ3cmFwIiwicmFuZ2UiLCJ3cmFwWW95byIsInRvdGFsIiwiX3JlcGxhY2VSYW5kb20iLCJzIiwibnVtcyIsImluTWluIiwiaW5NYXgiLCJvdXRNaW4iLCJvdXRNYXgiLCJpblJhbmdlIiwib3V0UmFuZ2UiLCJpbnRlcnBvbGF0ZSIsInN0YXJ0IiwicHJvZ3Jlc3MiLCJtdXRhdGUiLCJpc1N0cmluZyIsIm1hc3RlciIsImludGVycG9sYXRvcnMiLCJpbCIsIl9hZGRQcm9wVHdlZW4iLCJfcmVuZGVyUHJvcFR3ZWVucyIsIl9nZXRMYWJlbEluRGlyZWN0aW9uIiwiZnJvbVRpbWUiLCJiYWNrd2FyZCIsImRpc3RhbmNlIiwibGFiZWwiLCJleGVjdXRlTGF6eUZpcnN0IiwiY2FsbGJhY2siLCJjYWxsYmFja1Njb3BlIiwiX2ludGVycnVwdCIsInNjcm9sbFRyaWdnZXIiLCJraWxsIiwiX3F1aWNrVHdlZW4iLCJfY3JlYXRlUGx1Z2luIiwiY29uZmlnIiwiaXNGdW5jIiwiUGx1Z2luIiwiaW5pdCIsIl9wcm9wcyIsImluc3RhbmNlRGVmYXVsdHMiLCJhZGQiLCJfa2lsbFByb3BUd2VlbnNPZiIsIm1vZGlmaWVyIiwiX2FkZFBsdWdpbk1vZGlmaWVyIiwicmF3VmFycyIsInN0YXRpY3MiLCJnZXQiLCJnZXRTZXR0ZXIiLCJfZ2V0U2V0dGVyIiwiYWxpYXNlcyIsInJlZ2lzdGVyIiwicHJvcCIsInRvVXBwZXJDYXNlIiwiUHJvcFR3ZWVuIiwiXzI1NSIsIl9jb2xvckxvb2t1cCIsImFxdWEiLCJsaW1lIiwic2lsdmVyIiwiYmxhY2siLCJtYXJvb24iLCJ0ZWFsIiwiYmx1ZSIsIm5hdnkiLCJ3aGl0ZSIsIm9saXZlIiwieWVsbG93Iiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsImdyZWVuIiwicmVkIiwicGluayIsImN5YW4iLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJoIiwibTEiLCJtMiIsInNwbGl0Q29sb3IiLCJ0b0hTTCIsImZvcmNlQWxwaGEiLCJnIiwid2FzSFNMIiwicGFyc2VJbnQiLCJtYXAiLCJOdW1iZXIiLCJfY29sb3JPcmRlckRhdGEiLCJjIiwiX2NvbG9yRXhwIiwiX2Zvcm1hdENvbG9ycyIsIm9yZGVyTWF0Y2hEYXRhIiwicmVzdWx0IiwiY29sb3JzIiwic2hlbGwiLCJjb2xvciIsImpvaW4iLCJyZXBsYWNlIiwic2hpZnQiLCJSZWdFeHAiLCJfaHNsRXhwIiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiY29tYmluZWQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiX3RpY2tlckFjdGl2ZSIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2xpc3RlbmVycyIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImRvY3VtZW50IiwiZ3NhcFZlcnNpb25zIiwidmVyc2lvbiIsIkdyZWVuU29ja0dsb2JhbHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbGVlcCIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsInRocmVzaG9sZCIsImFkanVzdGVkTGFnIiwiX2ZwcyIsIl9lYXNlTWFwIiwiX2N1c3RvbUVhc2VFeHAiLCJfcXVvdGVzRXhwIiwiX3BhcnNlT2JqZWN0SW5TdHJpbmciLCJrZXkiLCJ2YWwiLCJwYXJzZWRWYWwiLCJsYXN0SW5kZXhPZiIsIl92YWx1ZUluUGFyZW50aGVzZXMiLCJvcGVuIiwiY2xvc2UiLCJuZXN0ZWQiLCJzdWJzdHJpbmciLCJfY29uZmlnRWFzZUZyb21TdHJpbmciLCJfQ0UiLCJfcHJvcGFnYXRlWW95b0Vhc2UiLCJpc1lveW8iLCJ5b3lvRWFzZSIsIl9lYXNlIiwiX3lFYXNlIiwiZGVmYXVsdEVhc2UiLCJfaW5zZXJ0RWFzZSIsImVhc2VJbiIsImVhc2VPdXQiLCJlYXNlSW5PdXQiLCJsb3dlcmNhc2VOYW1lIiwidG9Mb3dlckNhc2UiLCJfZWFzZUluT3V0RnJvbU91dCIsIl9jb25maWdFbGFzdGljIiwiYW1wbGl0dWRlIiwicGVyaW9kIiwicDEiLCJwMiIsInAzIiwiYXNpbiIsIl9jb25maWdCYWNrIiwib3ZlcnNob290IiwicG93ZXIiLCJMaW5lYXIiLCJlYXNlTm9uZSIsIm5vbmUiLCJuMSIsIm4yIiwibjMiLCJTdGVwcGVkRWFzZSIsInN0ZXBzIiwiaW1tZWRpYXRlU3RhcnQiLCJpZCIsInNldCIsIkFuaW1hdGlvbiIsIkluZmluaXR5IiwieW95byIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlZCIsIl9wcm90byIsInN0YXJ0VGltZSIsIl90b3RhbFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwiZ2xvYmFsVGltZSIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfcmVzb2x2ZSIsIl90aGVuIiwiX0FuaW1hdGlvbiIsIl90aGlzIiwic29ydENoaWxkcmVuIiwiX3Byb3RvMiIsInRvIiwiVHdlZW4iLCJmcm9tVG8iLCJmcm9tVmFycyIsInRvVmFycyIsImRlbGF5ZWRDYWxsIiwic3RhZ2dlclRvIiwic3RhZ2dlciIsIm9uQ29tcGxldGVBbGwiLCJvbkNvbXBsZXRlQWxsUGFyYW1zIiwib25Db21wbGV0ZSIsIm9uQ29tcGxldGVQYXJhbXMiLCJzdGFnZ2VyRnJvbSIsInN0YWdnZXJGcm9tVG8iLCJ0RHVyIiwiY3Jvc3NpbmdTdGFydCIsInByZXZQYXVzZWQiLCJwYXVzZVR3ZWVuIiwicHJldlN0YXJ0IiwicmV3aW5kaW5nIiwiZG9lc1dyYXAiLCJvblJlcGVhdCIsIl9oYXNQYXVzZSIsIl9mb3JjaW5nIiwib25VcGRhdGUiLCJhZGp1c3RlZFRpbWUiLCJfdGhpczIiLCJhZGRMYWJlbCIsImdldENoaWxkcmVuIiwidHdlZW5zIiwidGltZWxpbmVzIiwiaWdub3JlQmVmb3JlVGltZSIsImdldEJ5SWQiLCJhbmltYXRpb25zIiwicmVtb3ZlTGFiZWwiLCJraWxsVHdlZW5zT2YiLCJfdG90YWxUaW1lMiIsImFkZFBhdXNlIiwicmVtb3ZlUGF1c2UiLCJwcm9wcyIsIm9ubHlBY3RpdmUiLCJnZXRUd2VlbnNPZiIsIl9vdmVyd3JpdGluZ1R3ZWVuIiwicGFyc2VkVGFyZ2V0cyIsImlzR2xvYmFsVGltZSIsImNoaWxkcmVuIiwiX3RhcmdldHMiLCJ0d2VlblRvIiwidGwiLCJfdmFycyIsIl9vblN0YXJ0Iiwib25TdGFydCIsIm9uU3RhcnRQYXJhbXMiLCJ0d2VlbkZyb21UbyIsImZyb21Qb3NpdGlvbiIsInRvUG9zaXRpb24iLCJuZXh0TGFiZWwiLCJhZnRlclRpbWUiLCJwcmV2aW91c0xhYmVsIiwiYmVmb3JlVGltZSIsImN1cnJlbnRMYWJlbCIsInNoaWZ0Q2hpbGRyZW4iLCJhZGp1c3RMYWJlbHMiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIm1hdGNoSW5kZXgiLCJzdGFydE51bXMiLCJlbmROdW0iLCJjaHVuayIsInN0YXJ0TnVtIiwiaGFzUmFuZG9tIiwiZSIsIm0iLCJmcCIsImN1cnJlbnRWYWx1ZSIsInBhcnNlZFN0YXJ0IiwiX3NldHRlclBsYWluIiwiX3NldHRlckZ1bmNXaXRoUGFyYW0iLCJfc2V0dGVyRnVuYyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwic3R5bGUiLCJfY2hlY2tQbHVnaW4iLCJwbHVnaW4iLCJwdExvb2t1cCIsInByaW9yaXR5Iiwib25VcGRhdGVQYXJhbXMiLCJhdXRvUmV2ZXJ0IiwicHJldlN0YXJ0QXQiLCJmdWxsVGFyZ2V0cyIsImF1dG9PdmVyd3JpdGUiLCJfb3ZlcndyaXRlIiwiY2xlYW5WYXJzIiwiaGFzUHJpb3JpdHkiLCJnc0RhdGEiLCJoYXJuZXNzVmFycyIsIm92ZXJ3cml0dGVuIiwiX29wIiwiX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSIsIl9vbkluaXQiLCJfYWRkQWxpYXNlc1RvVmFycyIsInByb3BlcnR5QWxpYXNlcyIsIl9zdGFnZ2VyVHdlZW5Qcm9wcyIsIl9zdGFnZ2VyUHJvcHNUb1NraXAiLCJfQW5pbWF0aW9uMiIsInNraXBJbmhlcml0IiwiX3RoaXMzIiwiX3RoaXMzJHZhcnMiLCJjdXJUYXJnZXQiLCJzdGFnZ2VyRnVuYyIsInN0YWdnZXJWYXJzVG9NZXJnZSIsIl9wcm90bzMiLCJraWxsaW5nVGFyZ2V0cyIsInByb3BUd2Vlbkxvb2t1cCIsImZpcnN0UFQiLCJvdmVyd3JpdHRlblByb3BzIiwiY3VyTG9va3VwIiwiY3VyT3ZlcndyaXRlUHJvcHMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwiX3NldHRlckF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImhhc05vbkRlcGVuZGVudFJlbWFpbmluZyIsIm9wIiwiZGVwIiwiX3NldHRlcldpdGhNb2RpZmllciIsIm1TZXQiLCJtdCIsInB0MiIsImZpcnN0IiwibGFzdCIsInByIiwiY2hhbmdlIiwicmVuZGVyZXIiLCJfcHJvdG80IiwiVHdlZW5NYXgiLCJUd2VlbkxpdGUiLCJUaW1lbGluZUxpdGUiLCJUaW1lbGluZU1heCIsInJlZ2lzdGVyUGx1Z2luIiwiX2xlbjIiLCJhcmdzIiwiX2tleTIiLCJnZXRQcm9wZXJ0eSIsInVuY2FjaGUiLCJnZXR0ZXIiLCJmb3JtYXQiLCJxdWlja1NldHRlciIsInNldHRlcnMiLCJpc1R3ZWVuaW5nIiwicmVnaXN0ZXJFZmZlY3QiLCJfcmVmMiIsImVmZmVjdCIsInBsdWdpbnMiLCJleHRlbmRUaW1lbGluZSIsInBsdWdpbk5hbWUiLCJyZWdpc3RlckVhc2UiLCJwYXJzZUVhc2UiLCJleHBvcnRSb290IiwiaW5jbHVkZURlbGF5ZWRDYWxscyIsInV0aWxzIiwiaW5zdGFsbCIsImVmZmVjdHMiLCJ0aWNrZXIiLCJnbG9iYWxUaW1lbGluZSIsImNvcmUiLCJnbG9iYWxzIiwiZ2V0Q2FjaGUiLCJzdXBwcmVzc092ZXJ3cml0ZXMiLCJfZ2V0UGx1Z2luUHJvcFR3ZWVuIiwiX2FkZE1vZGlmaWVycyIsIm1vZGlmaWVycyIsIl9idWlsZE1vZGlmaWVyUGx1Z2luIiwidGVtcCIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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QyxNQUFNLEdBQUcxUSxRQUFRLENBQUMwUSxNQUR0QjtBQUFBLElBRUlDLE1BQU0sR0FBRzNRLFFBQVEsQ0FBQzJRLE1BRnRCO0FBQUEsSUFHSUMsTUFBTSxHQUFHNVEsUUFBUSxDQUFDNFEsTUFIdEI7QUFBQSxJQUlJQyxNQUFNLEdBQUc3USxRQUFRLENBQUM2USxNQUp0QjtBQUFBLElBS0l2TyxNQUFNLEdBQUd0QyxRQUFRLENBQUNzQyxNQUx0QjtBQUFBLElBTUl3TyxJQUFJLEdBQUc5USxRQUFRLENBQUM4USxJQU5wQjtBQUFBLElBT0lDLEtBQUssR0FBRy9RLFFBQVEsQ0FBQytRLEtBUHJCO0FBQUEsSUFRSUMsS0FBSyxHQUFHaFIsUUFBUSxDQUFDZ1IsS0FSckI7QUFBQSxJQVNJQyxLQUFLLEdBQUdqUixRQUFRLENBQUNpUixLQVRyQjtBQUFBLElBVUlDLE1BQU0sR0FBR2xSLFFBQVEsQ0FBQ2tSLE1BVnRCO0FBQUEsSUFXSUMsT0FBTyxHQUFHblIsUUFBUSxDQUFDbVIsT0FYdkI7QUFBQSxJQVlJQyxJQUFJLEdBQUdwUixRQUFRLENBQUNvUixJQVpwQjtBQUFBLElBYUl4TyxXQUFXLEdBQUc1QyxRQUFRLENBQUM0QyxXQWIzQjtBQUFBLElBY0l5TyxNQUFNLEdBQUdyUixRQUFRLENBQUNxUixNQWR0QjtBQUFBLElBZUlDLElBQUksR0FBR3RSLFFBQVEsQ0FBQ3NSLElBZnBCO0FBQUEsSUFnQklDLElBQUksR0FBR3ZSLFFBQVEsQ0FBQ3VSLElBaEJwQjtBQUFBLElBaUJJQyxJQUFJLEdBQUd4UixRQUFRLENBQUN3UixJQWpCcEI7QUFrQkE7Q0FDK1AiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIEdTQVAgMy42LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgIF8yUEkgPSBNYXRoLlBJICogMixcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxuICAgIF9nc0lEID0gMCxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzTm90RmFsc2UgPSBmdW5jdGlvbiBfaXNOb3RGYWxzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc0Z1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9pc0Z1bmNPclN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XG59LFxuICAgIF9pc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgLy8gbm90ZTogSUUxMCBoYXMgQXJyYXlCdWZmZXIsIGJ1dCBOT1QgQXJyYXlCdWZmZXIuaXNWaWV3KCkuXG5faXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX3N0cmljdE51bUV4cCA9IC8oPzotP1xcLj9cXGR8XFwuKSsvZ2ksXG4gICAgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2csXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgX2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCtcXC4/XFxkKig/OmUtfGVcXCspP1xcZCovZ2ksXG4gICAgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cbl9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgIF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bI1xcLSsuXSpcXGJbYS16XFxkLT0rJS5dKy9naSxcbiAgICBfdW5pdEV4cCA9IC9bXFxkLitcXC09XSsoPzplWy0rXVxcZCopKi9pLFxuICAgIF9nbG9iYWxUaW1lbGluZSxcbiAgICBfd2luLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZG9jLFxuICAgIF9nbG9iYWxzID0ge30sXG4gICAgX2luc3RhbGxTY29wZSA9IHt9LFxuICAgIF9jb3JlUmVhZHksXG4gICAgX2luc3RhbGwgPSBmdW5jdGlvbiBfaW5zdGFsbChzY29wZSkge1xuICByZXR1cm4gKF9pbnN0YWxsU2NvcGUgPSBfbWVyZ2Uoc2NvcGUsIF9nbG9iYWxzKSkgJiYgZ3NhcDtcbn0sXG4gICAgX21pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiBfbWlzc2luZ1BsdWdpbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvcGVydHlcIiwgcHJvcGVydHksIFwic2V0IHRvXCIsIHZhbHVlLCBcIk1pc3NpbmcgcGx1Z2luPyBnc2FwLnJlZ2lzdGVyUGx1Z2luKClcIik7XG59LFxuICAgIF93YXJuID0gZnVuY3Rpb24gX3dhcm4obWVzc2FnZSwgc3VwcHJlc3MpIHtcbiAgcmV0dXJuICFzdXBwcmVzcyAmJiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9hZGRHbG9iYWwgPSBmdW5jdGlvbiBfYWRkR2xvYmFsKG5hbWUsIG9iaikge1xuICByZXR1cm4gbmFtZSAmJiAoX2dsb2JhbHNbbmFtZV0gPSBvYmopICYmIF9pbnN0YWxsU2NvcGUgJiYgKF9pbnN0YWxsU2NvcGVbbmFtZV0gPSBvYmopIHx8IF9nbG9iYWxzO1xufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgcmV0dXJuIDA7XG59LFxuICAgIF9yZXNlcnZlZFByb3BzID0ge30sXG4gICAgX2xhenlUd2VlbnMgPSBbXSxcbiAgICBfbGF6eUxvb2t1cCA9IHt9LFxuICAgIF9sYXN0UmVuZGVyZWRGcmFtZSxcbiAgICBfcGx1Z2lucyA9IHt9LFxuICAgIF9lZmZlY3RzID0ge30sXG4gICAgX25leHRHQ0ZyYW1lID0gMzAsXG4gICAgX2hhcm5lc3NQbHVnaW5zID0gW10sXG4gICAgX2NhbGxiYWNrTmFtZXMgPSBcIlwiLFxuICAgIF9oYXJuZXNzID0gZnVuY3Rpb24gX2hhcm5lc3ModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXSxcbiAgICAgIGhhcm5lc3NQbHVnaW4sXG4gICAgICBpO1xuICBfaXNPYmplY3QodGFyZ2V0KSB8fCBfaXNGdW5jdGlvbih0YXJnZXQpIHx8ICh0YXJnZXRzID0gW3RhcmdldHNdKTtcblxuICBpZiAoIShoYXJuZXNzUGx1Z2luID0gKHRhcmdldC5fZ3NhcCB8fCB7fSkuaGFybmVzcykpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBhIGhhcm5lc3MuIFdlIGFzc3VtZSB0YXJnZXRzIHBhc3NlZCBpbnRvIGFuIGFuaW1hdGlvbiB3aWxsIGJlIG9mIHNpbWlsYXIgdHlwZSwgbWVhbmluZyB0aGUgc2FtZSBraW5kIG9mIGhhcm5lc3MgY2FuIGJlIHVzZWQgZm9yIHRoZW0gYWxsIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgaSA9IF9oYXJuZXNzUGx1Z2lucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tICYmICFfaGFybmVzc1BsdWdpbnNbaV0udGFyZ2V0VGVzdCh0YXJnZXQpKSB7fVxuXG4gICAgaGFybmVzc1BsdWdpbiA9IF9oYXJuZXNzUGx1Z2luc1tpXTtcbiAgfVxuXG4gIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdGFyZ2V0c1tpXSAmJiAodGFyZ2V0c1tpXS5fZ3NhcCB8fCAodGFyZ2V0c1tpXS5fZ3NhcCA9IG5ldyBHU0NhY2hlKHRhcmdldHNbaV0sIGhhcm5lc3NQbHVnaW4pKSkgfHwgdGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0cztcbn0sXG4gICAgX2dldENhY2hlID0gZnVuY3Rpb24gX2dldENhY2hlKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRvQXJyYXkodGFyZ2V0KSlbMF0uX2dzYXA7XG59LFxuICAgIF9nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2KSB7XG4gIHJldHVybiAodiA9IHRhcmdldFtwcm9wZXJ0eV0pICYmIF9pc0Z1bmN0aW9uKHYpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgdjtcbn0sXG4gICAgX2ZvckVhY2hOYW1lID0gZnVuY3Rpb24gX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jKSB7XG4gIHJldHVybiAobmFtZXMgPSBuYW1lcy5zcGxpdChcIixcIikpLmZvckVhY2goZnVuYykgfHwgbmFtZXM7XG59LFxuICAgIC8vc3BsaXQgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBuYW1lcyBpbnRvIGFuIGFycmF5LCB0aGVuIHJ1biBhIGZvckVhY2goKSBmdW5jdGlvbiBhbmQgcmV0dXJuIHRoZSBzcGxpdCBhcnJheSAodGhpcyBpcyBqdXN0IGEgd2F5IHRvIGNvbnNvbGlkYXRlL3Nob3J0ZW4gc29tZSBjb2RlKS5cbl9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9wYXJzZVZhcnMgPSBmdW5jdGlvbiBfcGFyc2VWYXJzKHBhcmFtcywgdHlwZSwgcGFyZW50KSB7XG4gIC8vcmVhZHMgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gb25lIG9mIHRoZSBrZXkgbWV0aG9kcyBhbmQgZmlndXJlcyBvdXQgaWYgdGhlIHVzZXIgaXMgZGVmaW5pbmcgdGhpbmdzIHdpdGggdGhlIE9MRC9sZWdhY3kgc3ludGF4IHdoZXJlIHRoZSBkdXJhdGlvbiBpcyB0aGUgMm5kIHBhcmFtZXRlciwgYW5kIHRoZW4gaXQgYWRqdXN0cyB0aGluZ3MgYWNjb3JkaW5nbHkgYW5kIHNwaXRzIGJhY2sgdGhlIGNvcnJlY3RlZCB2YXJzIG9iamVjdCAod2l0aCB0aGUgZHVyYXRpb24gYWRkZWQgaWYgbmVjZXNzYXJ5LCBhcyB3ZWxsIGFzIHJ1bkJhY2t3YXJkcyBvciBzdGFydEF0IG9yIGltbWVkaWF0ZVJlbmRlcikuIHR5cGUgMCA9IHRvKCkvc3RhZ2dlclRvKCksIDEgPSBmcm9tKCkvc3RhZ2dlckZyb20oKSwgMiA9IGZyb21UbygpL3N0YWdnZXJGcm9tVG8oKVxuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycztcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IHAgPT09IFwiZHVyYXRpb25cIiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG59LFxuICAgIF9tZXJnZSA9IGZ1bmN0aW9uIF9tZXJnZShiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIGJhc2VbcF0gPSB0b01lcmdlW3BdO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59LFxuICAgIF9tZXJnZURlZXAgPSBmdW5jdGlvbiBfbWVyZ2VEZWVwKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgcCAhPT0gXCJfX3Byb3RvX19cIiAmJiBwICE9PSBcImNvbnN0cnVjdG9yXCIgJiYgcCAhPT0gXCJwcm90b3R5cGVcIiAmJiAoYmFzZVtwXSA9IF9pc09iamVjdCh0b01lcmdlW3BdKSA/IF9tZXJnZURlZXAoYmFzZVtwXSB8fCAoYmFzZVtwXSA9IHt9KSwgdG9NZXJnZVtwXSkgOiB0b01lcmdlW3BdKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfY29weUV4Y2x1ZGluZyA9IGZ1bmN0aW9uIF9jb3B5RXhjbHVkaW5nKG9iaiwgZXhjbHVkaW5nKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2luaGVyaXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9pbmhlcml0RGVmYXVsdHModmFycykge1xuICB2YXIgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xufSxcbiAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xuXG4gICAgX3NldEVuZChhbmltYXRpb24pO1xuXG4gICAgcGFyZW50Ll9kaXJ0eSB8fCBfdW5jYWNoZShwYXJlbnQsIGFuaW1hdGlvbik7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCBjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikge1xuICAgIC8vaW4gY2FzZSwgZm9yIGV4YW1wbGUsIHRoZSBfc3RhcnQgaXMgbW92ZWQgb24gYSB0d2VlbiB0aGF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG4gICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xuICAgICAgdCA9IHRpbWVsaW5lO1xuXG4gICAgICB3aGlsZSAodC5fZHApIHtcbiAgICAgICAgdC5yYXdUaW1lKCkgPj0gMCAmJiB0LnRvdGFsVGltZSh0Ll90VGltZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LiBJZiBpdCdzIGN1cnJlbnRseSB6ZXJvLCB0aG91Z2gsIGl0IG1heSBub3QgYmUgc2NoZWR1bGVkIHRvIHJlbmRlciB1bnRpbCBsYXRlciBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgaXQgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBwbGF5aGVhZCBwb3NpdGlvbi4gT25seSBtb3ZlIHRvIGNhdGNoIHVwIHdpdGggdGhlIHBsYXloZWFkLlxuXG4gICAgICAgIHQgPSB0Ll9kcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07IC8vIGhlbHBzIGVuc3VyZSB0aGF0IHRoZSBuZXh0IHJlbmRlcigpIHdpbGwgYmUgZm9yY2VkIChjcm9zc2luZ1N0YXJ0ID0gdHJ1ZSBpbiByZW5kZXIoKSksIGV2ZW4gaWYgdGhlIGR1cmF0aW9uIGhhc24ndCBjaGFuZ2VkICh3ZSdyZSBhZGRpbmcgYSBjaGlsZCB3aGljaCB3b3VsZCBuZWVkIHRvIGdldCByZW5kZXJlZCkuIERlZmluaXRlbHkgYW4gZWRnZSBjYXNlLiBOb3RlOiB3ZSBNVVNUIGRvIHRoaXMgQUZURVIgdGhlIGxvb3AgYWJvdmUgd2hlcmUgdGhlIHRvdGFsVGltZSgpIG1pZ2h0IHRyaWdnZXIgYSByZW5kZXIoKSBiZWNhdXNlIHRoaXMgX2FkZFRvVGltZWxpbmUoKSBtZXRob2QgZ2V0cyBjYWxsZWQgZnJvbSB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBCRUZPUkUgdHdlZW5zIGV2ZW4gcmVjb3JkIHRoZWlyIHRhcmdldHMsIGV0Yy4gc28gd2Ugd291bGRuJ3Qgd2FudCB0aGluZ3MgdG8gZ2V0IHRyaWdnZXJlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuXG4gIH1cbn0sXG4gICAgX2FkZFRvVGltZWxpbmUgPSBmdW5jdGlvbiBfYWRkVG9UaW1lbGluZSh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSB7XG4gIGNoaWxkLnBhcmVudCAmJiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gIGNoaWxkLl9zdGFydCA9IF9yb3VuZChwb3NpdGlvbiArIGNoaWxkLl9kZWxheSk7XG4gIGNoaWxkLl9lbmQgPSBfcm91bmQoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICB0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQ7XG4gIHNraXBDaGVja3MgfHwgX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKTtcbiAgcmV0dXJuIHRpbWVsaW5lO1xufSxcbiAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICByZXR1cm4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pO1xufSxcbiAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykge1xuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUpO1xuXG4gIGlmICghdHdlZW4uX2luaXR0ZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmICghZm9yY2UgJiYgdHdlZW4uX3B0ICYmICh0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSAhPT0gZmFsc2UgfHwgIXR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5KSAmJiBfbGFzdFJlbmRlcmVkRnJhbWUgIT09IF90aWNrZXIuZnJhbWUpIHtcbiAgICBfbGF6eVR3ZWVucy5wdXNoKHR3ZWVuKTtcblxuICAgIHR3ZWVuLl9sYXp5ID0gW3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHNdO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSk7XG59LFxuICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5fcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgIHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAhdG90YWxUaW1lICYmICghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pIHx8ICh0d2Vlbi5fdHMgPCAwIHx8IHR3ZWVuLl9kcC5fdHMgPCAwKSAmJiB0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIgJiYgdHdlZW4uZGF0YSAhPT0gXCJpc1N0YXJ0XCIpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSk7XG4gICAgdHdlZW4uX3lveW8gJiYgaXRlcmF0aW9uICYgMSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuXG4gICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgcHJldlJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgdHdlZW4udmFycy5yZXBlYXRSZWZyZXNoICYmIHR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmF0aW8gIT09IHByZXZSYXRpbyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAvLyBpZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcbiAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTsgLy8gd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICBzdXBwcmVzc0V2ZW50cyB8fCAoc3VwcHJlc3NFdmVudHMgPSB0b3RhbFRpbWUgJiYgIXByZXZJdGVyYXRpb24pOyAvLyBpZiBpdCB3YXMgcmVuZGVyZWQgcHJldmlvdXNseSBhdCBleGFjdGx5IDAgKF96VGltZSkgYW5kIG5vdyB0aGUgcGxheWhlYWQgaXMgbW92aW5nIGF3YXksIERPTidUIGZpcmUgY2FsbGJhY2tzIG90aGVyd2lzZSB0aGV5J2xsIHNlZW0gbGlrZSBkdXBsaWNhdGVzLlxuXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcbiAgICB0d2Vlbi5fZnJvbSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuICAgIHR3ZWVuLl90aW1lID0gMDtcbiAgICB0d2Vlbi5fdFRpbWUgPSB0VGltZTtcbiAgICBwdCA9IHR3ZWVuLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHR3ZWVuLl9zdGFydEF0ICYmIHRvdGFsVGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZChkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kKGR1ciAqIChyZXBlYXQgKyAxKSArIGFuaW1hdGlvbi5fckRlbGF5ICogcmVwZWF0KTtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCA/IF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpIDogYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBpID0gcG9zaXRpb24uY2hhckF0KDApO1xuXG4gICAgaWYgKGkgPT09IFwiPFwiIHx8IGkgPT09IFwiPlwiKSB7XG4gICAgICByZXR1cm4gKGkgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCk7XG4gICAgfVxuXG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBwb3NpdGlvbiBpbiBsYWJlbHMgfHwgKGxhYmVsc1twb3NpdGlvbl0gPSBjbGlwcGVkRHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGxhYmVsc1twb3NpdGlvbl07XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gKyhwb3NpdGlvbi5jaGFyQXQoaSAtIDEpICsgcG9zaXRpb24uc3Vic3RyKGkgKyAxKSk7XG4gICAgcmV0dXJuIGkgPiAxID8gX3BhcnNlUG9zaXRpb24oYW5pbWF0aW9uLCBwb3NpdGlvbi5zdWJzdHIoMCwgaSAtIDEpKSArIG9mZnNldCA6IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldDtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbiA9PSBudWxsID8gY2xpcHBlZER1cmF0aW9uIDogK3Bvc2l0aW9uO1xufSxcbiAgICBfY29uZGl0aW9uYWxSZXR1cm4gPSBmdW5jdGlvbiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmMpIHtcbiAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gZnVuYyh2YWx1ZSkgOiBmdW5jO1xufSxcbiAgICBfY2xhbXAgPSBmdW5jdGlvbiBfY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG59LFxuICAgIGdldFVuaXQgPSBmdW5jdGlvbiBnZXRVbml0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHZhciB2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSk7XG5cbiAgcmV0dXJuIHYgPyB2YWx1ZS5zdWJzdHIodi5pbmRleCArIHZbMF0ubGVuZ3RoKSA6IFwiXCI7XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgbGVhdmVTdHJpbmdzKSB7XG4gIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbChfZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gIH0pO1xufSxcbiAgICAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKSwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG4vL2ZvciBkaXN0cmlidXRpbmcgdmFsdWVzIGFjcm9zcyBhbiBhcnJheS4gQ2FuIGFjY2VwdCBhIG51bWJlciwgYSBmdW5jdGlvbiBvciAobW9zdCBjb21tb25seSkgYSBmdW5jdGlvbiB3aGljaCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHtiYXNlLCBhbW91bnQsIGZyb20sIGVhc2UsIGdyaWQsIGF4aXMsIGxlbmd0aCwgZWFjaH0uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBpbmRleCwgdGFyZ2V0LCBhcnJheS4gUmVjb2duaXplcyB0aGUgZm9sbG93aW5nXG5kaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XG4gIGlmIChfaXNGdW5jdGlvbih2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdmFyIHZhcnMgPSBfaXNPYmplY3QodikgPyB2IDoge1xuICAgIGVhY2g6IHZcbiAgfSxcbiAgICAgIC8vbjoxIGlzIGp1c3QgdG8gaW5kaWNhdGUgdiB3YXMgYSBudW1iZXI7IHdlIGxldmVyYWdlIHRoYXQgbGF0ZXIgdG8gc2V0IHYgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggd2UgZ2V0LiBJZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sIHdlIHRyZWF0IGl0IGxpa2UgdGhlIG9sZCBzdGFnZ2VyIHZhbHVlIHdoZXJlIDAuMSwgZm9yIGV4YW1wbGUsIHdvdWxkIG1lYW4gdGhhdCB0aGluZ3Mgd291bGQgYmUgZGlzdHJpYnV0ZWQgd2l0aCAwLjEgYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHJhdGhlciB0aGFuIGEgdG90YWwgXCJhbW91bnRcIiB0aGF0J3MgY2h1bmtlZCBvdXQgYW1vbmcgdGhlbSBhbGwuXG4gIGVhc2UgPSBfcGFyc2VFYXNlKHZhcnMuZWFzZSksXG4gICAgICBmcm9tID0gdmFycy5mcm9tIHx8IDAsXG4gICAgICBiYXNlID0gcGFyc2VGbG9hdCh2YXJzLmJhc2UpIHx8IDAsXG4gICAgICBjYWNoZSA9IHt9LFxuICAgICAgaXNEZWNpbWFsID0gZnJvbSA+IDAgJiYgZnJvbSA8IDEsXG4gICAgICByYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG4gICAgICBheGlzID0gdmFycy5heGlzLFxuICAgICAgcmF0aW9YID0gZnJvbSxcbiAgICAgIHJhdGlvWSA9IGZyb207XG5cbiAgaWYgKF9pc1N0cmluZyhmcm9tKSkge1xuICAgIHJhdGlvWCA9IHJhdGlvWSA9IHtcbiAgICAgIGNlbnRlcjogLjUsXG4gICAgICBlZGdlczogLjUsXG4gICAgICBlbmQ6IDFcbiAgICB9W2Zyb21dIHx8IDA7XG4gIH0gZWxzZSBpZiAoIWlzRGVjaW1hbCAmJiByYXRpb3MpIHtcbiAgICByYXRpb1ggPSBmcm9tWzBdO1xuICAgIHJhdGlvWSA9IGZyb21bMV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xuICAgIHZhciBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuICAgICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSxcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZCxcbiAgICAgICAgaixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIHdyYXBBdDtcblxuICAgIGlmICghZGlzdGFuY2VzKSB7XG4gICAgICB3cmFwQXQgPSB2YXJzLmdyaWQgPT09IFwiYXV0b1wiID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblxuICAgICAgaWYgKCF3cmFwQXQpIHtcbiAgICAgICAgbWF4ID0gLV9iaWdOdW07XG5cbiAgICAgICAgd2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7fVxuXG4gICAgICAgIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogZnJvbSAvIHdyYXBBdCB8IDA7XG4gICAgICBtYXggPSAwO1xuICAgICAgbWluID0gX2JpZ051bTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgIHkgPSBvcmlnaW5ZIC0gKGogLyB3cmFwQXQgfCAwKTtcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcbiAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgIGQgPCBtaW4gJiYgKG1pbiA9IGQpO1xuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZChkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcDtcbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcGFyYW1zLFxuICAgICAgc2NvcGU7XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdO1xuICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gIGV4ZWN1dGVMYXp5Rmlyc3QgJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXG4gIHJldHVybiBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKGZhbHNlKTtcbiAgYW5pbWF0aW9uLnByb2dyZXNzKCkgPCAxICYmIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9xdWlja1R3ZWVuLFxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xuICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7IC8vVU1EIHBhY2thZ2luZyB3cmFwcyB0aGluZ3Mgb2RkbHksIHNvIGZvciBleGFtcGxlIE1vdGlvblBhdGhIZWxwZXIgYmVjb21lcyB7TW90aW9uUGF0aEhlbHBlcjpNb3Rpb25QYXRoSGVscGVyLCBkZWZhdWx0Ok1vdGlvblBhdGhIZWxwZXJ9LlxuXG4gIHZhciBuYW1lID0gY29uZmlnLm5hbWUsXG4gICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuICAgICAgUGx1Z2luID0gbmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0ID8gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3BzID0gW107XG4gIH0gOiBjb25maWcsXG4gICAgICAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuICBpbnN0YW5jZURlZmF1bHRzID0ge1xuICAgIGluaXQ6IF9lbXB0eUZ1bmMsXG4gICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICBhZGQ6IF9hZGRQcm9wVHdlZW4sXG4gICAga2lsbDogX2tpbGxQcm9wVHdlZW5zT2YsXG4gICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICByYXdWYXJzOiAwXG4gIH0sXG4gICAgICBzdGF0aWNzID0ge1xuICAgIHRhcmdldFRlc3Q6IDAsXG4gICAgZ2V0OiAwLFxuICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICBhbGlhc2VzOiB7fSxcbiAgICByZWdpc3RlcjogMFxuICB9O1xuXG4gIF93YWtlKCk7XG5cbiAgaWYgKGNvbmZpZyAhPT0gUGx1Z2luKSB7XG4gICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXG5cbiAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXG5cblxuICAgIF9wbHVnaW5zW1BsdWdpbi5wcm9wID0gbmFtZV0gPSBQbHVnaW47XG5cbiAgICBpZiAoY29uZmlnLnRhcmdldFRlc3QpIHtcbiAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbiAgICB9XG5cbiAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG4gIH1cblxuICBfYWRkR2xvYmFsKG5hbWUsIFBsdWdpbik7XG5cbiAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIF9odWUgPSBmdW5jdGlvbiBfaHVlKGgsIG0xLCBtMikge1xuICBoID0gaCA8IDAgPyBoICsgMSA6IGggPiAxID8gaCAtIDEgOiBoO1xuICByZXR1cm4gKGggKiA2IDwgMSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiBoIDwgLjUgPyBtMiA6IGggKiAzIDwgMiA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogXzI1NSArIC41IHwgMDtcbn0sXG4gICAgc3BsaXRDb2xvciA9IGZ1bmN0aW9uIHNwbGl0Q29sb3IodiwgdG9IU0wsIGZvcmNlQWxwaGEpIHtcbiAgdmFyIGEgPSAhdiA/IF9jb2xvckxvb2t1cC5ibGFjayA6IF9pc051bWJlcih2KSA/IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV0gOiAwLFxuICAgICAgcixcbiAgICAgIGcsXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIHMsXG4gICAgICBsLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgZCxcbiAgICAgIHdhc0hTTDtcblxuICBpZiAoIWEpIHtcbiAgICBpZiAodi5zdWJzdHIoLTEpID09PSBcIixcIikge1xuICAgICAgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cbiAgICAgIHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChfY29sb3JMb29rdXBbdl0pIHtcbiAgICAgIGEgPSBfY29sb3JMb29rdXBbdl07XG4gICAgfSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh2Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgLy9mb3Igc2hvcnRoYW5kIGxpa2UgIzlGMCBvciAjOUYwRiAoY291bGQgaGF2ZSBhbHBoYSlcbiAgICAgICAgciA9IHYuY2hhckF0KDEpO1xuICAgICAgICBnID0gdi5jaGFyQXQoMik7XG4gICAgICAgIGIgPSB2LmNoYXJBdCgzKTtcbiAgICAgICAgdiA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiICsgKHYubGVuZ3RoID09PSA1ID8gdi5jaGFyQXQoNCkgKyB2LmNoYXJBdCg0KSA6IFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgLy8gaGV4IHdpdGggYWxwaGEsIGxpa2UgI2ZkNWU1M2ZmXG4gICAgICAgIGEgPSBwYXJzZUludCh2LnN1YnN0cigxLCA2KSwgMTYpO1xuICAgICAgICByZXR1cm4gW2EgPj4gMTYsIGEgPj4gOCAmIF8yNTUsIGEgJiBfMjU1LCBwYXJzZUludCh2LnN1YnN0cig3KSwgMTYpIC8gMjU1XTtcbiAgICAgIH1cblxuICAgICAgdiA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG4gICAgICBhID0gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XTtcbiAgICB9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG4gICAgICBhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcblxuICAgICAgaWYgKCF0b0hTTCkge1xuICAgICAgICBoID0gK2FbMF0gJSAzNjAgLyAzNjA7XG4gICAgICAgIHMgPSArYVsxXSAvIDEwMDtcbiAgICAgICAgbCA9ICthWzJdIC8gMTAwO1xuICAgICAgICBnID0gbCA8PSAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgciA9IGwgKiAyIC0gZztcbiAgICAgICAgYS5sZW5ndGggPiAzICYmIChhWzNdICo9IDEpOyAvL2Nhc3QgYXMgbnVtYmVyXG5cbiAgICAgICAgYVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcbiAgICAgICAgYVsxXSA9IF9odWUoaCwgciwgZyk7XG4gICAgICAgIGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG4gICAgICB9IGVsc2UgaWYgKH52LmluZGV4T2YoXCI9XCIpKSB7XG4gICAgICAgIC8vaWYgcmVsYXRpdmUgdmFsdWVzIGFyZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHJhdyBzdHJpbmdzIHdpdGggdGhlIHJlbGF0aXZlIHByZWZpeGVzIGluIHBsYWNlLlxuICAgICAgICBhID0gdi5tYXRjaChfbnVtRXhwKTtcbiAgICAgICAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApIHx8IF9jb2xvckxvb2t1cC50cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICBhID0gYS5tYXAoTnVtYmVyKTtcbiAgfVxuXG4gIGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG4gICAgciA9IGFbMF0gLyBfMjU1O1xuICAgIGcgPSBhWzFdIC8gXzI1NTtcbiAgICBiID0gYVsyXSAvIF8yNTU7XG4gICAgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgaCA9IHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbWF4IC0gbWluO1xuICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgaCA9IG1heCA9PT0gciA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09PSBnID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9XG5cbiAgICBhWzBdID0gfn4oaCArIC41KTtcbiAgICBhWzFdID0gfn4ocyAqIDEwMCArIC41KTtcbiAgICBhWzJdID0gfn4obCAqIDEwMCArIC41KTtcbiAgfVxuXG4gIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gIHJldHVybiBhO1xufSxcbiAgICBfY29sb3JPcmRlckRhdGEgPSBmdW5jdGlvbiBfY29sb3JPcmRlckRhdGEodikge1xuICAvLyBzdHJpcHMgb3V0IHRoZSBjb2xvcnMgZnJvbSB0aGUgc3RyaW5nLCBmaW5kcyBhbGwgdGhlIG51bWVyaWMgc2xvdHMgKHdpdGggdW5pdHMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRob3NlLiBUaGUgQXJyYXkgYWxzbyBoYXMgYSBcImNcIiBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheSBvZiB0aGUgaW5kZXggdmFsdWVzIHdoZXJlIHRoZSBjb2xvcnMgYmVsb25nLiBUaGlzIGlzIHRvIGhlbHAgd29yayBhcm91bmQgaXNzdWVzIHdoZXJlIHRoZXJlJ3MgYSBtaXMtbWF0Y2hlZCBvcmRlciBvZiBjb2xvci9udW1lcmljIGRhdGEgbGlrZSBkcm9wLXNoYWRvdygjZjAwIDBweCAxcHggMnB4KSBhbmQgZHJvcC1zaGFkb3coMHggMXB4IDJweCAjZjAwKS4gVGhpcyBpcyBiYXNpY2FsbHkgYSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBfZm9ybWF0Q29sb3JzKClcbiAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgYyA9IFtdLFxuICAgICAgaSA9IC0xO1xuICB2LnNwbGl0KF9jb2xvckV4cCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIHZhciBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgYSk7XG4gICAgYy5wdXNoKGkgKz0gYS5sZW5ndGggKyAxKTtcbiAgfSk7XG4gIHZhbHVlcy5jID0gYztcbiAgcmV0dXJuIHZhbHVlcztcbn0sXG4gICAgX2Zvcm1hdENvbG9ycyA9IGZ1bmN0aW9uIF9mb3JtYXRDb2xvcnMocywgdG9IU0wsIG9yZGVyTWF0Y2hEYXRhKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgY29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXG4gICAgICB0eXBlID0gdG9IU0wgPyBcImhzbGEoXCIgOiBcInJnYmEoXCIsXG4gICAgICBpID0gMCxcbiAgICAgIGMsXG4gICAgICBzaGVsbCxcbiAgICAgIGQsXG4gICAgICBsO1xuXG4gIGlmICghY29sb3JzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiAoY29sb3IgPSBzcGxpdENvbG9yKGNvbG9yLCB0b0hTTCwgMSkpICYmIHR5cGUgKyAodG9IU0wgPyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG4gIH0pO1xuXG4gIGlmIChvcmRlck1hdGNoRGF0YSkge1xuICAgIGQgPSBfY29sb3JPcmRlckRhdGEocyk7XG4gICAgYyA9IG9yZGVyTWF0Y2hEYXRhLmM7XG5cbiAgICBpZiAoYy5qb2luKHJlc3VsdCkgIT09IGQuYy5qb2luKHJlc3VsdCkpIHtcbiAgICAgIHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XG4gICAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgKH5jLmluZGV4T2YoaSkgPyBjb2xvcnMuc2hpZnQoKSB8fCB0eXBlICsgXCIwLDAsMCwwKVwiIDogKGQubGVuZ3RoID8gZCA6IGNvbG9ycy5sZW5ndGggPyBjb2xvcnMgOiBvcmRlck1hdGNoRGF0YSkuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaGVsbCkge1xuICAgIHNoZWxsID0gcy5zcGxpdChfY29sb3JFeHApO1xuICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArIGNvbG9yc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc2hlbGxbbF07XG59LFxuICAgIF9jb2xvckV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHMgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17Myw0fSl7MSwyfVxcXFxiXCIsXG4gICAgICAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuLFxuICBwO1xuXG4gIGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcbiAgICBzICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHMgKyBcIilcIiwgXCJnaVwiKTtcbn0oKSxcbiAgICBfaHNsRXhwID0gL2hzbFthXT9cXCgvLFxuICAgIF9jb2xvclN0cmluZ0ZpbHRlciA9IGZ1bmN0aW9uIF9jb2xvclN0cmluZ0ZpbHRlcihhKSB7XG4gIHZhciBjb21iaW5lZCA9IGEuam9pbihcIiBcIiksXG4gICAgICB0b0hTTDtcbiAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgaWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuICAgIHRvSFNMID0gX2hzbEV4cC50ZXN0KGNvbWJpbmVkKTtcbiAgICBhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG4gICAgYVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wsIF9jb2xvck9yZGVyRGF0YShhWzFdKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3JkZXIgb2YgbnVtYmVycy9jb2xvcnMgbWF0Y2ggd2l0aCB0aGUgRU5EIHZhbHVlLlxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElDS0VSXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fdGlja2VyQWN0aXZlLFxuICAgIF90aWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgICAgX2xhZ1RocmVzaG9sZCA9IDUwMCxcbiAgICAgIF9hZGp1c3RlZExhZyA9IDMzLFxuICAgICAgX3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBfbGFzdFVwZGF0ZSA9IF9zdGFydFRpbWUsXG4gICAgICBfZ2FwID0gMTAwMCAvIDI0MCxcbiAgICAgIF9uZXh0VGltZSA9IF9nYXAsXG4gICAgICBfbGlzdGVuZXJzID0gW10sXG4gICAgICBfaWQsXG4gICAgICBfcmVxLFxuICAgICAgX3JhZixcbiAgICAgIF9zZWxmLFxuICAgICAgX2RlbHRhLFxuICAgICAgX2ksXG4gICAgICBfdGljayA9IGZ1bmN0aW9uIF90aWNrKHYpIHtcbiAgICB2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcbiAgICAgICAgbWFudWFsID0gdiA9PT0gdHJ1ZSxcbiAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGZyYW1lO1xuXG4gICAgZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQgJiYgKF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZyk7XG4gICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICB0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xuICAgIG92ZXJsYXAgPSB0aW1lIC0gX25leHRUaW1lO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgZnJhbWUgPSArK19zZWxmLmZyYW1lO1xuICAgICAgX2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcbiAgICAgIF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG4gICAgICBkaXNwYXRjaCA9IDE7XG4gICAgfVxuXG4gICAgbWFudWFsIHx8IChfaWQgPSBfcmVxKF90aWNrKSk7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cbiAgICAgICAgX2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgZGVsdGFSYXRpbzogZnVuY3Rpb24gZGVsdGFSYXRpbyhmcHMpIHtcbiAgICAgIHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcbiAgICB9LFxuICAgIHdha2U6IGZ1bmN0aW9uIHdha2UoKSB7XG4gICAgICBpZiAoX2NvcmVSZWFkeSkge1xuICAgICAgICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcbiAgICAgICAgICBfd2luID0gX2NvcmVJbml0dGVkID0gd2luZG93O1xuICAgICAgICAgIF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuICAgICAgICAgIF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuICAgICAgICAgIChfd2luLmdzYXBWZXJzaW9ucyB8fCAoX3dpbi5nc2FwVmVyc2lvbnMgPSBbXSkpLnB1c2goZ3NhcC52ZXJzaW9uKTtcblxuICAgICAgICAgIF9pbnN0YWxsKF9pbnN0YWxsU2NvcGUgfHwgX3dpbi5HcmVlblNvY2tHbG9iYWxzIHx8ICFfd2luLmdzYXAgJiYgX3dpbiB8fCB7fSk7XG5cbiAgICAgICAgICBfcmFmID0gX3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIH1cblxuICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICBfcmVxID0gX3JhZiB8fCBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIF9uZXh0VGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwICsgMSB8IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aWNrZXJBY3RpdmUgPSAxO1xuXG4gICAgICAgIF90aWNrKDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2xlZXA6IGZ1bmN0aW9uIHNsZWVwKCkge1xuICAgICAgKF9yYWYgPyBfd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIDogY2xlYXJUaW1lb3V0KShfaWQpO1xuICAgICAgX3RpY2tlckFjdGl2ZSA9IDA7XG4gICAgICBfcmVxID0gX2VtcHR5RnVuYztcbiAgICB9LFxuICAgIGxhZ1Ntb290aGluZzogZnVuY3Rpb24gbGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMSAvIF90aW55TnVtOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblxuICAgICAgX2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuICAgIH0sXG4gICAgZnBzOiBmdW5jdGlvbiBmcHMoX2Zwcykge1xuICAgICAgX2dhcCA9IDEwMDAgLyAoX2ZwcyB8fCAyNDApO1xuICAgICAgX25leHRUaW1lID0gX3NlbGYudGltZSAqIDEwMDAgKyBfZ2FwO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2spIHtcbiAgICAgIF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPCAwICYmIF9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIF93YWtlKCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaykge1xuICAgICAgdmFyIGk7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycywgdGltZSkge1xuICAgIHZhciBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmU7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICB0aGlzLl9kZWxheSA9ICt2YXJzLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAodGhpcy5fcmVwZWF0ID0gdmFycy5yZXBlYXQgPT09IEluZmluaXR5ID8gLTIgOiB2YXJzLnJlcGVhdCB8fCAwKSB7XG4gICAgICAvLyBUT0RPOiByZXBlYXQ6IEluZmluaXR5IG9uIGEgdGltZWxpbmUncyBjaGlsZHJlbiBtdXN0IGZsYWcgdGhhdCB0aW1lbGluZSBpbnRlcm5hbGx5IGFuZCBhZmZlY3QgaXRzIHRvdGFsRHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBzdG9wIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gd2hlbiByZWFjaGluZyB0aGUgc3RhcnQuXG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YXJzLnJlcGVhdERlbGF5IHx8IDA7XG4gICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgIH1cblxuICAgIHRoaXMuX3RzID0gMTtcblxuICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cbiAgICB0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICBwYXJlbnQgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB0aW1lIHx8IHRpbWUgPT09IDAgPyB0aW1lIDogcGFyZW50Ll90aW1lLCAxKTtcbiAgICB2YXJzLnJldmVyc2VkICYmIHRoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIHRoaXMucGF1c2VkKHRydWUpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICB0aGlzLl9kZWxheSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xuICB9O1xuXG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsRHVyYXRpb24odGhpcy5fcmVwZWF0ID4gMCA/IHZhbHVlICsgKHZhbHVlICsgdGhpcy5fckRlbGF5KSAqIHRoaXMuX3JlcGVhdCA6IHZhbHVlKSA6IHRoaXMudG90YWxEdXJhdGlvbigpICYmIHRoaXMuX2R1cjtcbiAgfTtcblxuICBfcHJvdG8udG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90RHVyO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcnR5ID0gMDtcbiAgICByZXR1cm4gX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX3JlcGVhdCA8IDAgPyB2YWx1ZSA6ICh2YWx1ZSAtIHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JEZWxheSkgLyAodGhpcy5fcmVwZWF0ICsgMSkpO1xuICB9O1xuXG4gIF9wcm90by50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBfd2FrZSgpO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX2RwO1xuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5fdHMpIHtcbiAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIF90b3RhbFRpbWUpO1xuXG4gICAgICAhcGFyZW50Ll9kcCB8fCBwYXJlbnQucGFyZW50IHx8IF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgdGhpcyk7IC8vIGVkZ2UgY2FzZTogaWYgdGhpcyBpcyBhIGNoaWxkIG9mIGEgdGltZWxpbmUgdGhhdCBhbHJlYWR5IGNvbXBsZXRlZCwgZm9yIGV4YW1wbGUsIHdlIG11c3QgcmUtYWN0aXZhdGUgdGhlIHBhcmVudC5cbiAgICAgIC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydCBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlIHRoaXMuX2R1ciB8fCAodmFsdWUgPyB0aGlzLl9kdXIgOiAwKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fdGltZTsgLy8gbm90ZTogaWYgdGhlIG1vZHVsdXMgcmVzdWx0cyBpbiAwLCB0aGUgcGxheWhlYWQgY291bGQgYmUgZXhhY3RseSBhdCB0aGUgZW5kIG9yIHRoZSBiZWdpbm5pbmcsIGFuZCB3ZSBhbHdheXMgZGVmZXIgdG8gdGhlIEVORCB3aXRoIGEgbm9uLXplcm8gdmFsdWUsIG90aGVyd2lzZSBpZiB5b3Ugc2V0IHRoZSB0aW1lKCkgdG8gdGhlIHZlcnkgZW5kIChkdXJhdGlvbigpKSwgaXQgd291bGQgcmVuZGVyIGF0IHRoZSBTVEFSVCFcbiAgfTtcblxuICBfcHJvdG8udG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHRvdGFsUHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5wcm9ncmVzcyA9IGZ1bmN0aW9uIHByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXRpbztcbiAgfTtcblxuICBfcHJvdG8uaXRlcmF0aW9uID0gZnVuY3Rpb24gaXRlcmF0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHZhciBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xuXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lICsgKHZhbHVlIC0gMSkgKiBjeWNsZUR1cmF0aW9uLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pICsgMSA6IDE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBhZGRpdGlvbjpcbiAgLy8gaXNQbGF5aW5nQmFja3dhcmRzKCkge1xuICAvLyBcdGxldCBhbmltYXRpb24gPSB0aGlzLFxuICAvLyBcdFx0b3JpZW50YXRpb24gPSAxOyAvLyAxID0gZm9yd2FyZCwgLTEgPSBiYWNrd2FyZFxuICAvLyBcdHdoaWxlIChhbmltYXRpb24pIHtcbiAgLy8gXHRcdG9yaWVudGF0aW9uICo9IGFuaW1hdGlvbi5yZXZlcnNlZCgpIHx8IChhbmltYXRpb24ucmVwZWF0KCkgJiYgIShhbmltYXRpb24uaXRlcmF0aW9uKCkgJiAxKSkgPyAtMSA6IDE7XG4gIC8vIFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24ucGFyZW50O1xuICAvLyBcdH1cbiAgLy8gXHRyZXR1cm4gb3JpZW50YXRpb24gPCAwO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8udGltZVNjYWxlID0gZnVuY3Rpb24gdGltZVNjYWxlKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnRzID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyByZWNvcmRlZCB0aW1lU2NhbGUuIFNwZWNpYWwgY2FzZTogaWYgc29tZW9uZSBjYWxscyByZXZlcnNlKCkgb24gYW4gYW5pbWF0aW9uIHdpdGggdGltZVNjYWxlIG9mIDAsIHdlIGFzc2lnbiBpdCAtX3RpbnlOdW0gdG8gcmVtZW1iZXIgaXQncyByZXZlcnNlZC5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcnRzID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHRUaW1lID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5fdHMgPyBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aGlzLnBhcmVudC5fdGltZSwgdGhpcykgOiB0aGlzLl90VGltZTsgLy8gbWFrZSBzdXJlIHRvIGRvIHRoZSBwYXJlbnRUb0NoaWxkVG90YWxUaW1lKCkgQkVGT1JFIHNldHRpbmcgdGhlIG5ldyBfdHMgYmVjYXVzZSB0aGUgb2xkIG9uZSBtdXN0IGJlIHVzZWQgaW4gdGhhdCBjYWxjdWxhdGlvbi5cbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIHJldHVybiBfcmVjYWNoZUFuY2VzdG9ycyh0aGlzLnRvdGFsVGltZShfY2xhbXAoLXRoaXMuX2RlbGF5LCB0aGlzLl90RHVyLCB0VGltZSksIHRydWUpKTtcbiAgfTtcblxuICBfcHJvdG8ucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BzICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fcHMgPSB2YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BUaW1lID0gdGhpcy5fdFRpbWUgfHwgTWF0aC5tYXgoLXRoaXMuX2RlbGF5LCB0aGlzLnJhd1RpbWUoKSk7IC8vIGlmIHRoZSBwYXVzZSBvY2N1cnMgZHVyaW5nIHRoZSBkZWxheSBwaGFzZSwgbWFrZSBzdXJlIHRoYXQncyBmYWN0b3JlZCBpbiB3aGVuIHJlc3VtaW5nLlxuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fYWN0ID0gMDsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSwgc28gYSBwYXVzZWQgdHdlZW4gd291bGQgZWZmZWN0aXZlbHkgaGF2ZSBhIHRpbWVTY2FsZSBvZiAwLiBXZSByZWNvcmQgdGhlIFwicmVhbFwiIHRpbWVTY2FsZSBhcyBfcnRzIChyZWNvcmRlZCB0aW1lIHNjYWxlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3dha2UoKTtcblxuICAgICAgICB0aGlzLl90cyA9IHRoaXMuX3J0czsgLy9vbmx5IGRlZmVyIHRvIF9wVGltZSAocGF1c2VUaW1lKSBpZiB0VGltZSBpcyB6ZXJvLiBSZW1lbWJlciwgc29tZW9uZSBjb3VsZCBwYXVzZSgpIGFuIGFuaW1hdGlvbiwgdGhlbiBzY3J1YiB0aGUgcGxheWhlYWQgYW5kIHJlc3VtZSgpLiBJZiB0aGUgcGFyZW50IGRvZXNuJ3QgaGF2ZSBzbW9vdGhDaGlsZFRpbWluZywgd2UgcmVuZGVyIGF0IHRoZSByYXdUaW1lKCkgYmVjYXVzZSB0aGUgc3RhcnRUaW1lIHdvbid0IGdldCB1cGRhdGVkLlxuXG4gICAgICAgIHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsIHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSAmJiAodGhpcy5fdFRpbWUgLT0gX3RpbnlOdW0pICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0pOyAvLyBlZGdlIGNhc2U6IGFuaW1hdGlvbi5wcm9ncmVzcygxKS5wYXVzZSgpLnBsYXkoKSB3b3VsZG4ndCByZW5kZXIgYWdhaW4gYmVjYXVzZSB0aGUgcGxheWhlYWQgaXMgYWxyZWFkeSBhdCB0aGUgZW5kLCBidXQgdGhlIGNhbGwgdG8gdG90YWxUaW1lKCkgYmVsb3cgd2lsbCBhZGQgaXQgYmFjayB0byBpdHMgcGFyZW50Li4uYW5kIG5vdCByZW1vdmUgaXQgYWdhaW4gKHNpbmNlIHJlbW92aW5nIG9ubHkgaGFwcGVucyB1cG9uIHJlbmRlcmluZyBhdCBhIG5ldyB0aW1lKS4gT2Zmc2V0dGluZyB0aGUgX3RUaW1lIHNsaWdodGx5IGlzIGRvbmUgc2ltcGx5IHRvIGNhdXNlIHRoZSBmaW5hbCByZW5kZXIgaW4gdG90YWxUaW1lKCkgdGhhdCdsbCBwb3AgaXQgb2ZmIGl0cyB0aW1lbGluZSAoaWYgYXV0b1JlbW92ZUNoaWxkcmVuIGlzIHRydWUsIG9mIGNvdXJzZSkuIENoZWNrIHRvIG1ha2Ugc3VyZSBfelRpbWUgaXNuJ3QgLV90aW55TnVtIHRvIGF2b2lkIGFuIGVkZ2UgY2FzZSB3aGVyZSB0aGUgcGxheWhlYWQgaXMgcHVzaGVkIHRvIHRoZSBlbmQgYnV0IElOU0lERSBhIHR3ZWVuL2NhbGxiYWNrLCB0aGUgdGltZWxpbmUgaXRzZWxmIGlzIHBhdXNlZCB0aHVzIGhhbHRpbmcgcmVuZGVyaW5nIGFuZCBsZWF2aW5nIGEgZmV3IHVucmVuZGVyZWQuIFdoZW4gcmVzdW1pbmcsIGl0IHdvdWxkbid0IHJlbmRlciB0aG9zZSBvdGhlcndpc2UuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0VGltZSA9IGZ1bmN0aW9uIHN0YXJ0VGltZSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwO1xuICAgICAgcGFyZW50ICYmIChwYXJlbnQuX3NvcnQgfHwgIXRoaXMucGFyZW50KSAmJiBfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICB9O1xuXG4gIF9wcm90by5lbmRUaW1lID0gZnVuY3Rpb24gZW5kVGltZShpbmNsdWRlUmVwZWF0cykge1xuICAgIHJldHVybiB0aGlzLl9zdGFydCArIChfaXNOb3RGYWxzZShpbmNsdWRlUmVwZWF0cykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyBNYXRoLmFicyh0aGlzLl90cyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhd1RpbWUgPSBmdW5jdGlvbiByYXdUaW1lKHdyYXBSZXBlYXRzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwOyAvLyBfZHAgPSBkZXRhdGNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKGFuaW1hdGlvbi5fdHMgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gcmVwZWF0RGVsYXkodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fckRlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICB9O1xuXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5feW95bztcbiAgfTtcblxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAhIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkgJiYgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyc1t0eXBlXTtcbiAgfTtcblxuICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgIF9yZXNvbHZlID0gZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgc2VsZi50aGVuID0gbnVsbDsgLy8gdGVtcG9yYXJpbHkgbnVsbCB0aGUgdGhlbigpIG1ldGhvZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zMjIpXG5cbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XG4gICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKTtcblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgX3RpbWU6IDAsXG4gIF9zdGFydDogMCxcbiAgX2VuZDogMCxcbiAgX3RUaW1lOiAwLFxuICBfdER1cjogMCxcbiAgX2RpcnR5OiAwLFxuICBfcmVwZWF0OiAwLFxuICBfeW95bzogZmFsc2UsXG4gIHBhcmVudDogbnVsbCxcbiAgX2luaXR0ZWQ6IGZhbHNlLFxuICBfckRlbGF5OiAwLFxuICBfdHM6IDEsXG4gIF9kcDogMCxcbiAgcmF0aW86IDAsXG4gIF96VGltZTogLV90aW55TnVtLFxuICBfcHJvbTogMCxcbiAgX3BzOiBmYWxzZSxcbiAgX3J0czogMVxufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVGltZWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHRpbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQW5pbWF0aW9uLmNhbGwodGhpcywgdmFycywgdGltZSkgfHwgdGhpcztcbiAgICBfdGhpcy5sYWJlbHMgPSB7fTtcbiAgICBfdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICEhdmFycy5zbW9vdGhDaGlsZFRpbWluZztcbiAgICBfdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAhIXZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuO1xuICAgIF90aGlzLl9zb3J0ID0gX2lzTm90RmFsc2UodmFycy5zb3J0Q2hpbGRyZW4pO1xuICAgIF90aGlzLnBhcmVudCAmJiBfcG9zdEFkZENoZWNrcyhfdGhpcy5wYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAwLCB0aGlzKSwgX3BhcnNlUG9zaXRpb24odGhpcywgX2lzTnVtYmVyKHZhcnMpID8gYXJndW1lbnRzWzNdIDogcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAxLCB0aGlzKSwgX3BhcnNlUG9zaXRpb24odGhpcywgX2lzTnVtYmVyKHZhcnMpID8gYXJndW1lbnRzWzNdIDogcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMiwgdGhpcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIF9pc051bWJlcihmcm9tVmFycykgPyBhcmd1bWVudHNbNF0gOiBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSAhIXZhcnMuaW1tZWRpYXRlUmVuZGVyO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gIH0gLy9PTkxZIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ISBNYXliZSBkZWxldGU/XG4gIDtcblxuICBfcHJvdG8yLnN0YWdnZXJUbyA9IGZ1bmN0aW9uIHN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdmFycy5zdGFnZ2VyID0gdmFycy5zdGFnZ2VyIHx8IHN0YWdnZXI7XG4gICAgdmFycy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZUFsbDtcbiAgICB2YXJzLm9uQ29tcGxldGVQYXJhbXMgPSBvbkNvbXBsZXRlQWxsUGFyYW1zO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24gc3RhZ2dlckZyb20odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tVG8odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHRvVmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodG9WYXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl9kaXJ0eSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5fdER1cixcbiAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICB0VGltZSA9IHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDAgPyB0RHVyIDogdG90YWxUaW1lIDwgX3RpbnlOdW0gPyAwIDogdG90YWxUaW1lLFxuICAgICAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxuICAgICAgICB0aW1lLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2UGF1c2VkLFxuICAgICAgICBwYXVzZVR3ZWVuLFxuICAgICAgICB0aW1lU2NhbGUsXG4gICAgICAgIHByZXZTdGFydCxcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgeW95byxcbiAgICAgICAgaXNZb3lvO1xuXG4gICAgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCBmb3JjZSB8fCBjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgZHVyKSB7XG4gICAgICAgIC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cbiAgICAgICAgdFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgICB0b3RhbFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICBwcmV2U3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgIHRpbWVTY2FsZSA9IHRoaXMuX3RzO1xuICAgICAgcHJldlBhdXNlZCA9ICF0aW1lU2NhbGU7XG5cbiAgICAgIGlmIChjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICAgIGR1ciB8fCAocHJldlRpbWUgPSB0aGlzLl96VGltZSk7IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUsIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICAgICAgKHRvdGFsVGltZSB8fCAhc3VwcHJlc3NFdmVudHMpICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIHlveW8gPSB0aGlzLl95b3lvO1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG4gICAgICAgICFwcmV2VGltZSAmJiB0aGlzLl90VGltZSAmJiBwcmV2SXRlcmF0aW9uICE9PSBpdGVyYXRpb24gJiYgKHByZXZJdGVyYXRpb24gPSBpdGVyYXRpb24pOyAvLyBlZGdlIGNhc2UgLSBpZiBzb21lb25lIGRvZXMgYWRkUGF1c2UoKSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSByZXBlYXRpbmcgdGltZWxpbmUsIHRoYXQgcGF1c2UgaXMgdGVjaG5pY2FsbHkgYXQgdGhlIHNhbWUgc3BvdCBhcyB0aGUgZW5kIHdoaWNoIGNhdXNlcyB0aGlzLl90aW1lIHRvIGdldCBzZXQgdG8gMCB3aGVuIHRoZSB0b3RhbFRpbWUgd291bGQgbm9ybWFsbHkgcGxhY2UgdGhlIHBsYXloZWFkIGF0IHRoZSBlbmQuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzODIzLWNsb3NpbmctbmF2LWFuaW1hdGlvbi1ub3Qtd29ya2luZy1vbi1pZS1hbmQtaXBob25lLTYtbWF5YmUtb3RoZXItb2xkZXItYnJvd3Nlci8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTEzMDA1XG5cbiAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICAgIGlzWW95byA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgbWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgYSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcbiAgICAgICAgd291bGQgZ2V0IHRyYW5zbGF0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG4gICAgICAgIGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuICAgICAgICB3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG4gICAgICAgIGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lIHdvcmsuXG4gICAgICAgICovXG5cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XG4gICAgICAgICAgdmFyIHJld2luZGluZyA9IHlveW8gJiYgcHJldkl0ZXJhdGlvbiAmIDEsXG4gICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcbiAgICAgICAgICBpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uICYmIChyZXdpbmRpbmcgPSAhcmV3aW5kaW5nKTtcbiAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IDAgOiBkdXI7XG4gICAgICAgICAgdGhpcy5fbG9jayA9IDE7XG4gICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmQoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcbiAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICh0aGlzLmludmFsaWRhdGUoKS5fbG9jayA9IDEpO1xuXG4gICAgICAgICAgaWYgKHByZXZUaW1lICYmIHByZXZUaW1lICE9PSB0aGlzLl90aW1lIHx8IHByZXZQYXVzZWQgIT09ICF0aGlzLl90cyB8fCB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXRoaXMucGFyZW50ICYmICF0aGlzLl9hY3QpIHtcbiAgICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGlzIDAgYW5kIHdlIHJlbmRlciBhdCB0aGUgdmVyeSBlbmQsIF90aW1lIHdpbGwgYmUgdGhlIGVuZCwgdGh1cyB3b24ndCBtYXRjaC4gU28gaW4gdGhpcyBlZGdlIGNhc2UsIHByZXZUaW1lIHdvbid0IG1hdGNoIF90aW1lIGJ1dCB0aGF0J3Mgb2theS4gSWYgaXQgZ2V0cyBraWxsZWQgaW4gdGhlIG9uUmVwZWF0LCBlamVjdCBhcyB3ZWxsLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZHVyID0gdGhpcy5fZHVyOyAvLyBpbiBjYXNlIHRoZSBkdXJhdGlvbiBjaGFuZ2VkIGluIHRoZSBvblJlcGVhdFxuXG4gICAgICAgICAgdER1ciA9IHRoaXMuX3REdXI7XG5cbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgOiAtMC4wMDAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmQocHJldlRpbWUpLCBfcm91bmQodGltZSkpO1xuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XG4gICAgICAgICAgdFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG4gICAgICAgIHRoaXMuX2luaXR0ZWQgPSAxO1xuICAgICAgICB0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcbiAgICAgICAgcHJldlRpbWUgPSAwOyAvLyB1cG9uIGluaXQsIHRoZSBwbGF5aGVhZCBzaG91bGQgYWx3YXlzIGdvIGZvcndhcmQ7IHNvbWVvbmUgY291bGQgaW52YWxpZGF0ZSgpIGEgY29tcGxldGVkIHRpbWVsaW5lIGFuZCB0aGVuIGlmIHRoZXkgcmVzdGFydCgpLCB0aGF0IHdvdWxkIG1ha2UgY2hpbGQgdHdlZW5zIHJlbmRlciBpbiByZXZlcnNlIG9yZGVyIHdoaWNoIGNvdWxkIGxvY2sgaW4gdGhlIHdyb25nIHN0YXJ0aW5nIHZhbHVlcyBpZiB0aGV5IGJ1aWxkIG9uIGVhY2ggb3RoZXIsIGxpa2UgdGwudG8ob2JqLCB7eDogMTAwfSkudG8ob2JqLCB7eDogMH0pLlxuICAgICAgfVxuXG4gICAgICAhcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGZsYWcgelRpbWUgYXMgbmVnYXRpdmUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTsgLy93aGVuIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhpcyB0aW1lbGluZSwgd2UgbXVzdCBwYXNzIHRoYXQgaW5mb3JtYXRpb24gZG93biB0byB0aGUgY2hpbGQgYW5pbWF0aW9ucyBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGtub3cgd2hldGhlciB0byByZW5kZXIgdGhlaXIgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlcy5cblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX3ByZXY7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IGFkanVzdGVkVGltZSA/IC1fdGlueU51bSA6IF90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdXNlVHdlZW4gJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgcGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RzKSB7XG4gICAgICAgICAgLy90aGUgY2FsbGJhY2sgcmVzdW1lZCBwbGF5YmFjayEgU28gc2luY2Ugd2UgbWF5IGhhdmUgaGVsZCBiYWNrIHRoZSBwbGF5aGVhZCBkdWUgdG8gd2hlcmUgdGhlIHBhdXNlIGlzIHBvc2l0aW9uZWQsIGdvIGFoZWFkIGFuZCBqdW1wIHRvIHdoZXJlIGl0J3MgU1VQUE9TRUQgdG8gYmUgKGlmIG5vIHBhdXNlIGhhcHBlbmVkKS5cbiAgICAgICAgICB0aGlzLl9zdGFydCA9IHByZXZTdGFydDsgLy9pZiB0aGUgcGF1c2Ugd2FzIGF0IGFuIGVhcmxpZXIgdGltZSBhbmQgdGhlIHVzZXIgcmVzdW1lZCBpbiB0aGUgY2FsbGJhY2ssIGl0IGNvdWxkIHJlcG9zaXRpb24gdGhlIHRpbWVsaW5lIChjaGFuZ2luZyBpdHMgc3RhcnRUaW1lKSwgdGhyb3dpbmcgdGhpbmdzIG9mZiBzbGlnaHRseSwgc28gd2UgbWFrZSBzdXJlIHRoZSBfc3RhcnQgZG9lc24ndCBzaGlmdC5cblxuICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiLCB0cnVlKTtcbiAgICAgIGlmICh0VGltZSA9PT0gdER1ciAmJiB0RHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSkpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZChjaGlsZCwgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9pc051bWJlcihwb3NpdGlvbikgfHwgKHBvc2l0aW9uID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZChvYmosIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcbiAgfTtcblxuICBfcHJvdG8yLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcbiAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEJ5SWQgPSBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICB0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcbiAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG4gICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZChfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0O1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIHRsLl90aW1lKSAvIHRsLnRpbWVTY2FsZSgpKTtcbiAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgX29uU3RhcnQgJiYgX29uU3RhcnQuYXBwbHkodHdlZW4sIG9uU3RhcnRQYXJhbXMgfHwgW10pOyAvL2luIGNhc2UgdGhlIHVzZXIgaGFkIGFuIG9uU3RhcnQgaW4gdGhlIHZhcnMgLSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBpdC5cbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG5cbiAgICByZXR1cm4gaW1tZWRpYXRlUmVuZGVyID8gdHdlZW4ucmVuZGVyKDApIDogdHdlZW47XG4gIH07XG5cbiAgX3Byb3RvMi50d2VlbkZyb21UbyA9IGZ1bmN0aW9uIHR3ZWVuRnJvbVRvKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuICAgIHJldHVybiB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgX3NldERlZmF1bHRzKHtcbiAgICAgIHN0YXJ0QXQ6IHtcbiAgICAgICAgdGltZTogX3BhcnNlUG9zaXRpb24odGhpcywgZnJvbVBvc2l0aW9uKVxuICAgICAgfVxuICAgIH0sIHZhcnMpKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlY2VudCA9IGZ1bmN0aW9uIHJlY2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjZW50O1xuICB9O1xuXG4gIF9wcm90bzIubmV4dExhYmVsID0gZnVuY3Rpb24gbmV4dExhYmVsKGFmdGVyVGltZSkge1xuICAgIGlmIChhZnRlclRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgYWZ0ZXJUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYWZ0ZXJUaW1lKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5wcmV2aW91c0xhYmVsID0gZnVuY3Rpb24gcHJldmlvdXNMYWJlbChiZWZvcmVUaW1lKSB7XG4gICAgaWYgKGJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgYmVmb3JlVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGJlZm9yZVRpbWUpLCAxKTtcbiAgfTtcblxuICBfcHJvdG8yLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uIGN1cnJlbnRMYWJlbCh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zZWVrKHZhbHVlLCB0cnVlKSA6IHRoaXMucHJldmlvdXNMYWJlbCh0aGlzLl90aW1lICsgX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90bzIuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uIHNoaWZ0Q2hpbGRyZW4oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZ25vcmVCZWZvcmVUaW1lID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgbGFiZWxzID0gdGhpcy5sYWJlbHMsXG4gICAgICAgIHA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBjaGlsZC5fc3RhcnQgKz0gYW1vdW50O1xuICAgICAgICBjaGlsZC5fZW5kICs9IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAoYWRqdXN0TGFiZWxzKSB7XG4gICAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgICAgIGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICAgIGxhYmVsc1twXSArPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgY2hpbGQuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gX0FuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgaWYgKGluY2x1ZGVMYWJlbHMgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZUxhYmVscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIG5leHQ7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9kcCAmJiAodGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gdGhpcy5fcFRpbWUgPSAwKTtcbiAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIHZhciBtYXggPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICBwcmV2U3RhcnQgPSBfYmlnTnVtLFxuICAgICAgICBwcmV2LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLl9kaXJ0eSkge1xuICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBwcmV2ID0gY2hpbGQuX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblxuICAgICAgICBjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLl9lbmQgPiBtYXggJiYgY2hpbGQuX3RzICYmIChtYXggPSBjaGlsZC5fZW5kKTtcbiAgICAgICAgY2hpbGQgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICBfc2V0RHVyYXRpb24oc2VsZiwgc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXggPyBzZWxmLl90aW1lIDogbWF4LCAxLCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KGVuZE51bS5zdWJzdHIoMikpICogKGVuZE51bS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgZW5kID0gcGFyc2VGbG9hdChwYXJzZWRTdGFydCkgKyBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpICogKGVuZC5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkU3RhcnQgIT09IGVuZCkge1xuICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpKSB7XG4gICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICB9XG5cbiAgICAhY3VycmVudFZhbHVlICYmICEocHJvcCBpbiB0YXJnZXQpICYmIF9taXNzaW5nUGx1Z2luKHByb3AsIGVuZCk7XG4gICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgfVxufSxcbiAgICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gIF9pc0Z1bmN0aW9uKHZhcnMpICYmICh2YXJzID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gIH1cblxuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgdmFyIHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXG4gIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICBpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG4gICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldOyAvL25vdGU6IHdlIGNhbid0IHVzZSB0d2Vlbi5fcHRMb29rdXBbaW5kZXhdIGJlY2F1c2UgZm9yIHN0YWdnZXJlZCB0d2VlbnMsIHRoZSBpbmRleCBmcm9tIHRoZSBmdWxsVGFyZ2V0cyBhcnJheSB3b24ndCBtYXRjaCB3aGF0IGl0IGlzIGluIGVhY2ggaW5kaXZpZHVhbCB0d2VlbiB0aGF0IHNwYXducyBmcm9tIHRoZSBzdGFnZ2VyLlxuXG4gICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSxcbiAgICBfb3ZlcndyaXRpbmdUd2VlbixcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXG5faW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSkge1xuICB2YXIgdmFycyA9IHR3ZWVuLnZhcnMsXG4gICAgICBlYXNlID0gdmFycy5lYXNlLFxuICAgICAgc3RhcnRBdCA9IHZhcnMuc3RhcnRBdCxcbiAgICAgIGltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgbGF6eSA9IHZhcnMubGF6eSxcbiAgICAgIG9uVXBkYXRlID0gdmFycy5vblVwZGF0ZSxcbiAgICAgIG9uVXBkYXRlUGFyYW1zID0gdmFycy5vblVwZGF0ZVBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGUgPSB2YXJzLmNhbGxiYWNrU2NvcGUsXG4gICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgIHlveW9FYXNlID0gdmFycy55b3lvRWFzZSxcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgIGR1ciA9IHR3ZWVuLl9kdXIsXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcGFyZW50ID0gdHdlZW4ucGFyZW50LFxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQucGFyZW50Ll90YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIiAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIHRsID0gdHdlZW4udGltZWxpbmUsXG4gICAgICBjbGVhblZhcnMsXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHB0LFxuICAgICAgdGFyZ2V0LFxuICAgICAgaGFzUHJpb3JpdHksXG4gICAgICBnc0RhdGEsXG4gICAgICBoYXJuZXNzLFxuICAgICAgcGx1Z2luLFxuICAgICAgcHRMb29rdXAsXG4gICAgICBpbmRleCxcbiAgICAgIGhhcm5lc3NWYXJzLFxuICAgICAgb3ZlcndyaXR0ZW47XG4gIHRsICYmICgha2V5ZnJhbWVzIHx8ICFlYXNlKSAmJiAoZWFzZSA9IFwibm9uZVwiKTtcbiAgdHdlZW4uX2Vhc2UgPSBfcGFyc2VFYXNlKGVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcbiAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblxuICBpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cbiAgICB5b3lvRWFzZSA9IHR3ZWVuLl95RWFzZTtcbiAgICB0d2Vlbi5feUVhc2UgPSB0d2Vlbi5fZWFzZTtcbiAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuICB9XG5cbiAgaWYgKCF0bCkge1xuICAgIC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxuICAgIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuICAgIGhhcm5lc3NWYXJzID0gaGFybmVzcyAmJiB2YXJzW2hhcm5lc3MucHJvcF07IC8vc29tZW9uZSBtYXkgbmVlZCB0byBzcGVjaWZ5IENTUy1zcGVjaWZpYyB2YWx1ZXMgQU5EIG5vbi1DU1MgdmFsdWVzLCBsaWtlIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBcInhcIiBwcm9wZXJ0eSBwbHVzIGl0J3MgYSBzdGFuZGFyZCBET00gZWxlbWVudC4gV2UgYWxsb3cgcGVvcGxlIHRvIGRpc3Rpbmd1aXNoIGJ5IHdyYXBwaW5nIHBsdWdpbi1zcGVjaWZpYyBzdHVmZiBpbiBhIGNzczp7fSBvYmplY3QgZm9yIGV4YW1wbGUuXG5cbiAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG4gICAgcHJldlN0YXJ0QXQgJiYgcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKS5raWxsKCk7XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6IF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGU6IGNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHN0YWdnZXI6IDBcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblxuXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgICAgIGF1dG9SZXZlcnQgfHwgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICAgICAgICB9IGVsc2UgaWYgKGR1ciAmJiAhKHRpbWUgPCAwICYmIHByZXZTdGFydEF0KSkge1xuICAgICAgICAgIHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuICAgICAgICAgIHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdXRvUmV2ZXJ0ID09PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fc3RhcnRBdCA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XG4gICAgICAvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG4gICAgICBpZiAocHJldlN0YXJ0QXQpIHtcbiAgICAgICAgIWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lICYmIChpbW1lZGlhdGVSZW5kZXIgPSBmYWxzZSk7IC8vaW4gcmFyZSBjYXNlcyAobGlrZSBpZiBhIGZyb20oKSB0d2VlbiBydW5zIGFuZCB0aGVuIGlzIGludmFsaWRhdGUoKS1lZCksIGltbWVkaWF0ZVJlbmRlciBjb3VsZCBiZSB0cnVlIGJ1dCB0aGUgaW5pdGlhbCBmb3JjZWQtcmVuZGVyIGdldHMgc2tpcHBlZCwgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIHRoZSByZW5kZXIgaW4gdGhpcyBjb250ZXh0IHdoZW4gdGhlIF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwXG5cbiAgICAgICAgcCA9IF9zZXREZWZhdWx0cyh7XG4gICAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgICBkYXRhOiBcImlzRnJvbVN0YXJ0XCIsXG4gICAgICAgICAgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG4gICAgICAgICAgbGF6eTogaW1tZWRpYXRlUmVuZGVyICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlcjogaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICAgIC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcbiAgICAgICAgICBzdGFnZ2VyOiAwLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50IC8vZW5zdXJlcyB0aGF0IG5lc3RlZCB0d2VlbnMgdGhhdCBoYWQgYSBzdGFnZ2VyIGFyZSBoYW5kbGVkIHByb3Blcmx5LCBsaWtlIGdzYXAuZnJvbShcIi5jbGFzc1wiLCB7eTpnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSl9KVxuXG4gICAgICAgIH0sIGNsZWFuVmFycyk7XG4gICAgICAgIGhhcm5lc3NWYXJzICYmIChwW2hhcm5lc3MucHJvcF0gPSBoYXJuZXNzVmFycyk7IC8vIGluIGNhc2Ugc29tZW9uZSBkb2VzIHNvbWV0aGluZyBsaWtlIC5mcm9tKC4uLiwge2Nzczp7fX0pXG5cbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgcCkpO1xuXG4gICAgICAgIGlmICghaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgICAgX2luaXRUd2Vlbih0d2Vlbi5fc3RhcnRBdCwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLl9wdCA9IDA7XG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG4gICAgICBfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXG4gICAgICBpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm5lc3MgfHwgaGFybmVzc1ZhcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGNsZWFuVmFycykge1xuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXG4gICAgICBpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldCwgcHRMb29rdXAsIHR3ZWVuLmdsb2JhbFRpbWUoMCkpOyAvL0Fsc28gbWFrZSBzdXJlIHRoZSBvdmVyd3JpdGluZyBkb2Vzbid0IG92ZXJ3cml0ZSBUSElTIHR3ZWVuISEhXG5cblxuICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcbiAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pOyAvL3BsdWdpbnMgbGlrZSBSb3VuZFByb3BzIG11c3Qgd2FpdCB1bnRpbCBBTEwgb2YgdGhlIFByb3BUd2VlbnMgYXJlIGluc3RhbnRpYXRlZC4gSW4gdGhlIHBsdWdpbidzIGluaXQoKSBmdW5jdGlvbiwgaXQgc2V0cyB0aGUgX29uSW5pdCBvbiB0aGUgdHdlZW4gaW5zdGFuY2UuIE1heSBub3QgYmUgcHJldHR5L2ludHVpdGl2ZSwgYnV0IGl0J3MgZmFzdCBhbmQga2VlcHMgZmlsZSBzaXplIGRvd24uXG4gIH1cblxuICB0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblxuICB0d2Vlbi5fb25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgdHdlZW4uX2luaXR0ZWQgPSAoIXR3ZWVuLl9vcCB8fCB0d2Vlbi5fcHQpICYmICFvdmVyd3JpdHRlbjsgLy8gaWYgb3ZlcndyaXR0ZW5Qcm9wcyByZXN1bHRlZCBpbiB0aGUgZW50aXJlIHR3ZWVuIGJlaW5nIGtpbGxlZCwgZG8gTk9UIGZsYWcgaXQgYXMgaW5pdHRlZCBvciBlbHNlIGl0IG1heSByZW5kZXIgZm9yIG9uZSB0aWNrLlxufSxcbiAgICBfYWRkQWxpYXNlc1RvVmFycyA9IGZ1bmN0aW9uIF9hZGRBbGlhc2VzVG9WYXJzKHRhcmdldHMsIHZhcnMpIHtcbiAgdmFyIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwLFxuICAgICAgcHJvcGVydHlBbGlhc2VzID0gaGFybmVzcyAmJiBoYXJuZXNzLmFsaWFzZXMsXG4gICAgICBjb3B5LFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBhbGlhc2VzO1xuXG4gIGlmICghcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgcmV0dXJuIHZhcnM7XG4gIH1cblxuICBjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcblxuICBmb3IgKHAgaW4gcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgaWYgKHAgaW4gY29weSkge1xuICAgICAgYWxpYXNlcyA9IHByb3BlcnR5QWxpYXNlc1twXS5zcGxpdChcIixcIik7XG4gICAgICBpID0gYWxpYXNlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29weVthbGlhc2VzW2ldXSA9IGNvcHlbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlXCIsXG4gICAgX3N0YWdnZXJQcm9wc1RvU2tpcCA9IChfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIpLnNwbGl0KFwiLFwiKTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uMikge1xuICBfaW5oZXJpdHNMb29zZShUd2VlbiwgX0FuaW1hdGlvbjIpO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHRpbWUsIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGltZS5kdXJhdGlvbiA9IHZhcnM7XG4gICAgICB2YXJzID0gdGltZTtcbiAgICAgIHRpbWUgPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSwgdGltZSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSBfdGhpczMucGFyZW50LFxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgdGwsXG4gICAgICAgIGksXG4gICAgICAgIGNvcHksXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGN1clRhcmdldCxcbiAgICAgICAgc3RhZ2dlckZ1bmMsXG4gICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblxuICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgdmFycyA9IF90aGlzMy52YXJzO1xuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMgfHwge31cbiAgICAgIH0pO1xuICAgICAgdGwua2lsbCgpO1xuICAgICAgdGwucGFyZW50ID0gdGwuX2RwID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuICAgICAgdGwuX3N0YXJ0ID0gMDtcblxuICAgICAgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfc2V0RGVmYXVsdHModGwudmFycy5kZWZhdWx0cywge1xuICAgICAgICAgIGVhc2U6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgIHJldHVybiB0bC50byhwYXJzZWRUYXJnZXRzLCBmcmFtZSwgXCI+XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcbiAgICAgICAgc3RhZ2dlckZ1bmMgPSBzdGFnZ2VyID8gZGlzdHJpYnV0ZShzdGFnZ2VyKSA6IF9lbXB0eUZ1bmM7XG5cbiAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xuICAgICAgICAgIC8vdXNlcnMgY2FuIHBhc3MgaW4gY2FsbGJhY2tzIGxpa2Ugb25TdGFydC9vbkNvbXBsZXRlIGluIHRoZSBzdGFnZ2VyIG9iamVjdC4gVGhlc2Ugc2hvdWxkIGZpcmUgd2l0aCBlYWNoIGluZGl2aWR1YWwgdHdlZW4uXG4gICAgICAgICAgZm9yIChwIGluIHN0YWdnZXIpIHtcbiAgICAgICAgICAgIGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvcHkgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICBpZiAoX3N0YWdnZXJQcm9wc1RvU2tpcC5pbmRleE9mKHApIDwgMCkge1xuICAgICAgICAgICAgICBjb3B5W3BdID0gdmFyc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xuICAgICAgICAgIHlveW9FYXNlICYmIChjb3B5LnlveW9FYXNlID0geW95b0Vhc2UpO1xuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldOyAvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXG5cbiAgICAgICAgICBjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpO1xuICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcblxuICAgICAgICAgIGlmICghc3RhZ2dlciAmJiBsID09PSAxICYmIGNvcHkuZGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxuICAgICAgICAgICAgX3RoaXMzLl9kZWxheSA9IGRlbGF5ID0gY29weS5kZWxheTtcbiAgICAgICAgICAgIF90aGlzMy5fc3RhcnQgKz0gZGVsYXk7XG4gICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jKGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9XG5cbiAgICAgIGR1cmF0aW9uIHx8IF90aGlzMy5kdXJhdGlvbihkdXJhdGlvbiA9IHRsLmR1cmF0aW9uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpczMudGltZWxpbmUgPSAwOyAvL3NwZWVkIG9wdGltaXphdGlvbiwgZmFzdGVyIGxvb2t1cHMgKG5vIGdvaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4pXG4gICAgfVxuXG4gICAgaWYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcykge1xuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG5cbiAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YocGFyc2VkVGFyZ2V0cyk7XG5cbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICB9XG5cbiAgICBwYXJlbnQgJiYgX3Bvc3RBZGRDaGVja3MocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmQocGFyZW50Ll90aW1lKSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblxuICAgICAgX3RoaXMzLnJlbmRlcihNYXRoLm1heCgwLCAtZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDAgPyB0RHVyIDogdG90YWxUaW1lIDwgX3RpbnlOdW0gPyAwIDogdG90YWxUaW1lLFxuICAgICAgICB0aW1lLFxuICAgICAgICBwdCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICBpc1lveW8sXG4gICAgICAgIHJhdGlvLFxuICAgICAgICB0aW1lbGluZSxcbiAgICAgICAgeW95b0Vhc2U7XG5cbiAgICBpZiAoIWR1cikge1xuICAgICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICB9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICF0aGlzLl9pbml0dGVkICYmIHRoaXMuX3RUaW1lIHx8IHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAvL3RoaXMgc2Vuc2VzIGlmIHdlJ3JlIGNyb3NzaW5nIG92ZXIgdGhlIHN0YXJ0IHRpbWUsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdCByZWNvcmQgX3pUaW1lIGFuZCBmb3JjZSB0aGUgcmVuZGVyLCBidXQgd2UgZG8gaXQgaW4gdGhpcyBsZW5ndGh5IGNvbmRpdGlvbmFsIHdheSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAodXN1YWxseSB3ZSBjYW4gc2tpcCB0aGUgY2FsY3VsYXRpb25zKTogdGhpcy5faW5pdHRlZCAmJiAodGhpcy5felRpbWUgPCAwKSAhPT0gKHRvdGFsVGltZSA8IDApXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmQodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBpc1lveW8gPSB0aGlzLl95b3lvICYmIGl0ZXJhdGlvbiAmIDE7XG5cbiAgICAgICAgaWYgKGlzWW95bykge1xuICAgICAgICAgIHlveW9FYXNlID0gdGhpcy5feUVhc2U7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAodGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlICYmIHRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgICAvL2NvdWxkIGJlIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgcGFydC4gTm8gbmVlZCB0byByZW5kZXIgYW5kIGZpcmUgY2FsbGJhY2tzLlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgIHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTsgLy9yZXBlYXRSZWZyZXNoIGZ1bmN0aW9uYWxpdHlcblxuICAgICAgICAgIGlmICh0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICF0aGlzLl9sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gZm9yY2UgPSAxOyAvL2ZvcmNlLCBvdGhlcndpc2UgaWYgbGF6eSBpcyB0cnVlLCB0aGUgX2F0dGVtcHRJbml0VHdlZW4oKSB3aWxsIHJldHVybiBhbmQgd2UnbGwganVtcCBvdXQgYW5kIGdldCBjYXVnaHQgYm91bmNpbmcgb24gZWFjaCB0aWNrLlxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcihfcm91bmQoY3ljbGVEdXJhdGlvbiAqIGl0ZXJhdGlvbiksIHRydWUpLmludmFsaWRhdGUoKS5fbG9jayA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICBpZiAoX2F0dGVtcHRJbml0VHdlZW4odGhpcywgdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IDA7IC8vIGluIGNvbnN0cnVjdG9yIGlmIGltbWVkaWF0ZVJlbmRlciBpcyB0cnVlLCB3ZSBzZXQgX3RUaW1lIHRvIC1fdGlueU51bSB0byBoYXZlIHRoZSBwbGF5aGVhZCBjcm9zcyB0aGUgc3RhcnRpbmcgcG9pbnQgYnV0IHdlIGNhbid0IGxlYXZlIF90VGltZSBhcyBhIG5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgLy8gd2hpbGUgaW5pdHRpbmcsIGEgcGx1Z2luIGxpa2UgSW5lcnRpYVBsdWdpbiBtaWdodCBhbHRlciB0aGUgZHVyYXRpb24sIHNvIHJlcnVuIGZyb20gdGhlIHN0YXJ0IHRvIGVuc3VyZSBldmVyeXRoaW5nIHJlbmRlcnMgYXMgaXQgc2hvdWxkLlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICBpZiAoIXRoaXMuX2FjdCAmJiB0aGlzLl90cykge1xuICAgICAgICB0aGlzLl9hY3QgPSAxOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xuXG4gICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB9XG5cbiAgICAgIHRpbWUgJiYgIXByZXZUaW1lICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuICAgICAgcHQgPSB0aGlzLl9wdDtcblxuICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5yZW5kZXIodG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6ICF0aW1lICYmIGlzWW95byA/IC1fdGlueU51bSA6IHRpbWVsaW5lLl9kdXIgKiByYXRpbywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB8fCB0aGlzLl9zdGFydEF0ICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG5cbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdGhpcy5fdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB3ZSdyZSByZW5kZXJpbmcgYXQgZXhhY3RseSBhIHRpbWUgb2YgMCwgYXMgdGhlcmUgY291bGQgYmUgYXV0b1JldmVydCB2YWx1ZXMgdGhhdCBzaG91bGQgZ2V0IHNldCBvbiB0aGUgbmV4dCB0aWNrIChpZiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0VGltZSwgbmVnYXRpdmUgdG90YWxUaW1lKS4gRG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUpKSB7XG4gICAgICAgICAgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMy50YXJnZXRzID0gZnVuY3Rpb24gdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgfTtcblxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG4gICAgdGhpcy5fcHRMb29rdXAgPSBbXTtcbiAgICB0aGlzLnRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICBwID0ge307XG5cbiAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXJzID0gcDtcbiAgICAgIH1cblxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgIH1cblxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICBjdXJMb29rdXAgPSBwcm9wVHdlZW5Mb29rdXBbaV07XG5cbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICBwcm9wcyA9IGN1ckxvb2t1cDtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAoIShcImtpbGxcIiBpbiBwdC5kKSB8fCBwdC5kLmtpbGwocCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGN1ckxvb2t1cFtwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7XG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvblJldmVyc2VDb21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICBvbkNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZTogc2NvcGVcbiAgICB9KTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDIpKTtcbiAgfTtcblxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgfTtcblxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFR3ZWVuO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gIF90YXJnZXRzOiBbXSxcbiAgX2xhenk6IDAsXG4gIF9zdGFydEF0OiAwLFxuICBfb3A6IDAsXG4gIF9vbkluaXQ6IDBcbn0pOyAvL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gTGV2ZXJhZ2UgdGhlIHRpbWVsaW5lIGNhbGxzLlxuXG5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcbiAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gIH07XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG59LFxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckJvb2xlYW4gPSBmdW5jdGlvbiBfcmVuZGVyQm9vbGVhbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDb21wbGV4U3RyaW5nID0gZnVuY3Rpb24gX3JlbmRlckNvbXBsZXhTdHJpbmcocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICBzID0gXCJcIjtcblxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xuICAgIC8vYiA9IGJlZ2lubmluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5iO1xuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xuICAgIC8vZSA9IGVuZGluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5lO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChwdCkge1xuICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7IC8vd2UgdXNlIHRoZSBcInBcIiBwcm9wZXJ0eSBmb3IgdGhlIHRleHQgaW5iZXR3ZWVuIChsaWtlIGEgc3VmZml4KS4gQW5kIGluIHRoZSBjb250ZXh0IG9mIGEgY29tcGxleCBzdHJpbmcsIHRoZSBtb2RpZmllciAobSkgaXMgdHlwaWNhbGx5IGp1c3QgTWF0aC5yb3VuZCgpLCBsaWtlIGZvciBSR0IgY29sb3JzLlxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cbiAgfVxuXG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG59LFxuICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG4gICAgcHQgPSBuZXh0O1xuICB9XG59LFxuICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3AgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG4gICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgIH0gZWxzZSBpZiAoIXB0LmRlcCkge1xuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gIWhhc05vbkRlcGVuZGVudFJlbWFpbmluZztcbn0sXG4gICAgX3NldHRlcldpdGhNb2RpZmllciA9IGZ1bmN0aW9uIF9zZXR0ZXJXaXRoTW9kaWZpZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgZGF0YS5tU2V0KHRhcmdldCwgcHJvcGVydHksIGRhdGEubS5jYWxsKGRhdGEudHdlZW4sIHZhbHVlLCBkYXRhLm10KSwgZGF0YSk7XG59LFxuICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBmdW5jdGlvbiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHBhcmVudCkge1xuICB2YXIgcHQgPSBwYXJlbnQuX3B0LFxuICAgICAgbmV4dCxcbiAgICAgIHB0MixcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdDsgLy9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQyID0gZmlyc3Q7XG5cbiAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG4gICAgICBwdDIgPSBwdDIuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkge1xuICAgICAgcHQuX3ByZXYuX25leHQgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3QgPSBwdDtcbiAgICB9XG5cbiAgICBpZiAocHQuX25leHQgPSBwdDIpIHtcbiAgICAgIHB0Mi5fcHJldiA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gcHQ7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcGFyZW50Ll9wdCA9IGZpcnN0O1xufTsgLy9Qcm9wVHdlZW4ga2V5OiB0ID0gdGFyZ2V0LCBwID0gcHJvcCwgciA9IHJlbmRlcmVyLCBkID0gZGF0YSwgcyA9IHN0YXJ0LCBjID0gY2hhbmdlLCBvcCA9IG92ZXJ3cml0ZVByb3BlcnR5IChPTkxZIHBvcHVsYXRlZCB3aGVuIGl0J3MgZGlmZmVyZW50IHRoYW4gcCksIHByID0gcHJpb3JpdHksIF9uZXh0L19wcmV2IGZvciB0aGUgbGlua2VkIGxpc3Qgc2libGluZ3MsIHNldCA9IHNldHRlciwgbSA9IG1vZGlmaWVyLCBtU2V0ID0gbW9kaWZpZXJTZXR0ZXIgKHRoZSBvcmlnaW5hbCBzZXR0ZXIsIGJlZm9yZSBhIG1vZGlmaWVyIHdhcyBhZGRlZClcblxuXG5leHBvcnQgdmFyIFByb3BUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BUd2VlbihuZXh0LCB0YXJnZXQsIHByb3AsIHN0YXJ0LCBjaGFuZ2UsIHJlbmRlcmVyLCBkYXRhLCBzZXR0ZXIsIHByaW9yaXR5KSB7XG4gICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgIHRoaXMucyA9IHN0YXJ0O1xuICAgIHRoaXMuYyA9IGNoYW5nZTtcbiAgICB0aGlzLnAgPSBwcm9wO1xuICAgIHRoaXMuciA9IHJlbmRlcmVyIHx8IF9yZW5kZXJQbGFpbjtcbiAgICB0aGlzLmQgPSBkYXRhIHx8IHRoaXM7XG4gICAgdGhpcy5zZXQgPSBzZXR0ZXIgfHwgX3NldHRlclBsYWluO1xuICAgIHRoaXMucHIgPSBwcmlvcml0eSB8fCAwO1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gUHJvcFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG80Lm1vZGlmaWVyID0gZnVuY3Rpb24gbW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xuICAgIHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDsgLy9pbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHNldCAoYSBQcm9wVHdlZW4gY2FuIG9ubHkgaGF2ZSBvbmUgbW9kaWZpZXIpXG5cbiAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XG4gICAgdGhpcy5tID0gZnVuYztcbiAgICB0aGlzLm10ID0gdGFyZ2V0OyAvL21vZGlmaWVyIHRhcmdldFxuXG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuICB9O1xuXG4gIHJldHVybiBQcm9wVHdlZW47XG59KCk7IC8vSW5pdGlhbGl6YXRpb24gdGFza3NcblxuX2ZvckVhY2hOYW1lKF9jYWxsYmFja05hbWVzICsgXCJwYXJlbnQsZHVyYXRpb24sZWFzZSxkZWxheSxvdmVyd3JpdGUscnVuQmFja3dhcmRzLHN0YXJ0QXQseW95byxpbW1lZGlhdGVSZW5kZXIscmVwZWF0LHJlcGVhdERlbGF5LGRhdGEscGF1c2VkLHJldmVyc2VkLGxhenksY2FsbGJhY2tTY29wZSxzdHJpbmdGaWx0ZXIsaWQseW95b0Vhc2Usc3RhZ2dlcixpbmhlcml0LHJlcGVhdFJlZnJlc2gsa2V5ZnJhbWVzLGF1dG9SZXZlcnQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xufSk7XG5cbl9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuX2dsb2JhbFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgc29ydENoaWxkcmVuOiBmYWxzZSxcbiAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcbiAgYXV0b1JlbW92ZUNoaWxkcmVuOiB0cnVlLFxuICBpZDogXCJyb290XCIsXG4gIHNtb290aENoaWxkVGltaW5nOiB0cnVlXG59KTtcbl9jb25maWcuc3RyaW5nRmlsdGVyID0gX2NvbG9yU3RyaW5nRmlsdGVyO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBHU0FQXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBfZ3NhcCA9IHtcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xuICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gIH0sXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgfSxcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxuICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuICAgIHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gZnVuY3Rpb24gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgfSxcbiAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCk7XG4gICAgICB9KSxcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gbDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgc2V0dGVyc1tpXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgcCA9IGNhY2hlLmhhcm5lc3MgJiYgKGNhY2hlLmhhcm5lc3MuYWxpYXNlcyB8fCB7fSlbcHJvcGVydHldIHx8IHByb3BlcnR5LFxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcbiAgICB9O1xuICB9LFxuICBpc1R3ZWVuaW5nOiBmdW5jdGlvbiBpc1R3ZWVuaW5nKHRhcmdldHMpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIHRydWUpLmxlbmd0aCA+IDA7XG4gIH0sXG4gIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh2YWx1ZSkge1xuICAgIHZhbHVlICYmIHZhbHVlLmVhc2UgJiYgKHZhbHVlLmVhc2UgPSBfcGFyc2VFYXNlKHZhbHVlLmVhc2UsIF9kZWZhdWx0cy5lYXNlKSk7XG4gICAgcmV0dXJuIF9tZXJnZURlZXAoX2RlZmF1bHRzLCB2YWx1ZSB8fCB7fSk7XG4gIH0sXG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9tZXJnZURlZXAoX2NvbmZpZywgdmFsdWUgfHwge30pO1xuICB9LFxuICByZWdpc3RlckVmZmVjdDogZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoX3JlZjIpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWUsXG4gICAgICAgIGVmZmVjdCA9IF9yZWYyLmVmZmVjdCxcbiAgICAgICAgcGx1Z2lucyA9IF9yZWYyLnBsdWdpbnMsXG4gICAgICAgIGRlZmF1bHRzID0gX3JlZjIuZGVmYXVsdHMsXG4gICAgICAgIGV4dGVuZFRpbWVsaW5lID0gX3JlZjIuZXh0ZW5kVGltZWxpbmU7XG4gICAgKHBsdWdpbnMgfHwgXCJcIikuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgICAgIHJldHVybiBwbHVnaW5OYW1lICYmICFfcGx1Z2luc1twbHVnaW5OYW1lXSAmJiAhX2dsb2JhbHNbcGx1Z2luTmFtZV0gJiYgX3dhcm4obmFtZSArIFwiIGVmZmVjdCByZXF1aXJlcyBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW4uXCIpO1xuICAgIH0pO1xuXG4gICAgX2VmZmVjdHNbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgdGwpIHtcbiAgICAgIHJldHVybiBlZmZlY3QodG9BcnJheSh0YXJnZXRzKSwgX3NldERlZmF1bHRzKHZhcnMgfHwge30sIGRlZmF1bHRzKSwgdGwpO1xuICAgIH07XG5cbiAgICBpZiAoZXh0ZW5kVGltZWxpbmUpIHtcbiAgICAgIFRpbWVsaW5lLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoX2VmZmVjdHNbbmFtZV0odGFyZ2V0cywgX2lzT2JqZWN0KHZhcnMpID8gdmFycyA6IChwb3NpdGlvbiA9IHZhcnMpICYmIHt9LCB0aGlzKSwgcG9zaXRpb24pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHJlZ2lzdGVyRWFzZTogZnVuY3Rpb24gcmVnaXN0ZXJFYXNlKG5hbWUsIGVhc2UpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9wYXJzZUVhc2UoZWFzZSk7XG4gIH0sXG4gIHBhcnNlRWFzZTogZnVuY3Rpb24gcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSA6IF9lYXNlTWFwO1xuICB9LFxuICBnZXRCeUlkOiBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRCeUlkKGlkKTtcbiAgfSxcbiAgZXhwb3J0Um9vdDogZnVuY3Rpb24gZXhwb3J0Um9vdCh2YXJzLCBpbmNsdWRlRGVsYXllZENhbGxzKSB7XG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSh2YXJzKSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQ7XG4gICAgdGwuc21vb3RoQ2hpbGRUaW1pbmcgPSBfaXNOb3RGYWxzZSh2YXJzLnNtb290aENoaWxkVGltaW5nKTtcblxuICAgIF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xuXG4gICAgdGwuX2RwID0gMDsgLy9vdGhlcndpc2UgaXQnbGwgZ2V0IHJlLWFjdGl2YXRlZCB3aGVuIGFkZGluZyBjaGlsZHJlbiBhbmQgYmUgcmUtaW50cm9kdWNlZCBpbnRvIF9nbG9iYWxUaW1lbGluZSdzIGxpbmtlZCBsaXN0ICh0aGVuIGFkZGVkIHRvIGl0c2VsZikuXG5cbiAgICB0bC5fdGltZSA9IHRsLl90VGltZSA9IF9nbG9iYWxUaW1lbGluZS5fdGltZTtcbiAgICBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgaWYgKGluY2x1ZGVEZWxheWVkQ2FsbHMgfHwgISghY2hpbGQuX2R1ciAmJiBjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuICYmIGNoaWxkLnZhcnMub25Db21wbGV0ZSA9PT0gY2hpbGQuX3RhcmdldHNbMF0pKSB7XG4gICAgICAgIF9hZGRUb1RpbWVsaW5lKHRsLCBjaGlsZCwgY2hpbGQuX3N0YXJ0IC0gY2hpbGQuX2RlbGF5KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIF9hZGRUb1RpbWVsaW5lKF9nbG9iYWxUaW1lbGluZSwgdGwsIDApO1xuXG4gICAgcmV0dXJuIHRsO1xuICB9LFxuICB1dGlsczoge1xuICAgIHdyYXA6IHdyYXAsXG4gICAgd3JhcFlveW86IHdyYXBZb3lvLFxuICAgIGRpc3RyaWJ1dGU6IGRpc3RyaWJ1dGUsXG4gICAgcmFuZG9tOiByYW5kb20sXG4gICAgc25hcDogc25hcCxcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSxcbiAgICBnZXRVbml0OiBnZXRVbml0LFxuICAgIGNsYW1wOiBjbGFtcCxcbiAgICBzcGxpdENvbG9yOiBzcGxpdENvbG9yLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgbWFwUmFuZ2U6IG1hcFJhbmdlLFxuICAgIHBpcGU6IHBpcGUsXG4gICAgdW5pdGl6ZTogdW5pdGl6ZSxcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgc2h1ZmZsZTogc2h1ZmZsZVxuICB9LFxuICBpbnN0YWxsOiBfaW5zdGFsbCxcbiAgZWZmZWN0czogX2VmZmVjdHMsXG4gIHRpY2tlcjogX3RpY2tlcixcbiAgdXBkYXRlUm9vdDogVGltZWxpbmUudXBkYXRlUm9vdCxcbiAgcGx1Z2luczogX3BsdWdpbnMsXG4gIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG4gIGNvcmU6IHtcbiAgICBQcm9wVHdlZW46IFByb3BUd2VlbixcbiAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxuICAgIFR3ZWVuOiBUd2VlbixcbiAgICBUaW1lbGluZTogVGltZWxpbmUsXG4gICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgZ2V0Q2FjaGU6IF9nZXRDYWNoZSxcbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW06IF9yZW1vdmVMaW5rZWRMaXN0SXRlbSxcbiAgICBzdXBwcmVzc092ZXJ3cml0ZXM6IGZ1bmN0aW9uIHN1cHByZXNzT3ZlcndyaXRlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbl9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV07XG59KTtcblxuX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5cbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcbiAgZHVyYXRpb246IDBcbn0pOyAvLyAtLS0tIEVYVFJBIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIF9nZXRQbHVnaW5Qcm9wVHdlZW4gPSBmdW5jdGlvbiBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHBsdWdpbiwgcHJvcCkge1xuICB2YXIgcHQgPSBwbHVnaW4uX3B0O1xuXG4gIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZE1vZGlmaWVycyA9IGZ1bmN0aW9uIF9hZGRNb2RpZmllcnModHdlZW4sIG1vZGlmaWVycykge1xuICB2YXIgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcCxcbiAgICAgIGksXG4gICAgICBwdDtcblxuICBmb3IgKHAgaW4gbW9kaWZpZXJzKSB7XG4gICAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSB0d2Vlbi5fcHRMb29rdXBbaV1bcF07XG5cbiAgICAgIGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuICAgICAgICBpZiAocHQuX3B0KSB7XG4gICAgICAgICAgLy8gaXMgYSBwbHVnaW5cbiAgICAgICAgICBwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIF9idWlsZE1vZGlmaWVyUGx1Z2luID0gZnVuY3Rpb24gX2J1aWxkTW9kaWZpZXJQbHVnaW4obmFtZSwgbW9kaWZpZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhd1ZhcnM6IDEsXG4gICAgLy9kb24ndCBwcmUtcHJvY2VzcyBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgb3IgXCJyYW5kb20oKVwiIHN0cmluZ3MuXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG4gICAgICB0d2Vlbi5fb25Jbml0ID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIHZhciB0ZW1wLCBwO1xuXG4gICAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wW25hbWVdID0gMTtcbiAgICAgICAgICB9KTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXG5cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgIHRlbXBbcF0gPSBtb2RpZmllcih2YXJzW3BdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvL3JlZ2lzdGVyIGNvcmUgcGx1Z2luc1xuXG5cbmV4cG9ydCB2YXIgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcbiAgbmFtZTogXCJhdHRyXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcCwgcHQ7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgcHQgPSB0aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh0YXJnZXQuZ2V0QXR0cmlidXRlKHApIHx8IDApICsgXCJcIiwgdmFyc1twXSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgcHQgJiYgKHB0Lm9wID0gcCk7XG5cbiAgICAgIHRoaXMuX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6IFwiZW5kQXJyYXlcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSk7XG4gICAgfVxuICB9XG59LCBfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApKSB8fCBfZ3NhcDsgLy90byBwcmV2ZW50IHRoZSBjb3JlIHBsdWdpbnMgZnJvbSBiZWluZyBkcm9wcGVkIHZpYSBhZ2dyZXNzaXZlIHRyZWUgc2hha2luZywgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIHRoaXMgd2F5LlxuXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy42LjFcIjtcbl9jb3JlUmVhZHkgPSAxO1xuXG5pZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gIF93YWtlKCk7XG59XG5cbnZhciBQb3dlcjAgPSBfZWFzZU1hcC5Qb3dlcjAsXG4gICAgUG93ZXIxID0gX2Vhc2VNYXAuUG93ZXIxLFxuICAgIFBvd2VyMiA9IF9lYXNlTWFwLlBvd2VyMixcbiAgICBQb3dlcjMgPSBfZWFzZU1hcC5Qb3dlcjMsXG4gICAgUG93ZXI0ID0gX2Vhc2VNYXAuUG93ZXI0LFxuICAgIExpbmVhciA9IF9lYXNlTWFwLkxpbmVhcixcbiAgICBRdWFkID0gX2Vhc2VNYXAuUXVhZCxcbiAgICBDdWJpYyA9IF9lYXNlTWFwLkN1YmljLFxuICAgIFF1YXJ0ID0gX2Vhc2VNYXAuUXVhcnQsXG4gICAgUXVpbnQgPSBfZWFzZU1hcC5RdWludCxcbiAgICBTdHJvbmcgPSBfZWFzZU1hcC5TdHJvbmcsXG4gICAgRWxhc3RpYyA9IF9lYXNlTWFwLkVsYXN0aWMsXG4gICAgQmFjayA9IF9lYXNlTWFwLkJhY2ssXG4gICAgU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5TdGVwcGVkRWFzZSxcbiAgICBCb3VuY2UgPSBfZWFzZU1hcC5Cb3VuY2UsXG4gICAgU2luZSA9IF9lYXNlTWFwLlNpbmUsXG4gICAgRXhwbyA9IF9lYXNlTWFwLkV4cG8sXG4gICAgQ2lyYyA9IF9lYXNlTWFwLkNpcmM7XG5leHBvcnQgeyBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTtcbmV4cG9ydCB7IFR3ZWVuIGFzIFR3ZWVuTWF4LCBUd2VlbiBhcyBUd2VlbkxpdGUsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTWF4LCBUaW1lbGluZSBhcyBUaW1lbGluZUxpdGUsIGdzYXAgYXMgZGVmYXVsdCwgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgbWFwUmFuZ2UsIHBpcGUsIHVuaXRpemUsIGludGVycG9sYXRlLCBzaHVmZmxlIH07IC8vZXhwb3J0IHNvbWUgaW50ZXJuYWwgbWV0aG9kcy9vcm9qZWN0cyBmb3IgdXNlIGluIENTU1BsdWdpbiBzbyB0aGF0IHdlIGNhbiBleHRlcm5hbGl6ZSB0aGF0IGZpbGUgYW5kIGFsbG93IGN1c3RvbSBidWlsZHMgdGhhdCBleGNsdWRlIGl0LlxuXG5leHBvcnQgeyBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9yZXBsYWNlUmFuZG9tLCBfY2hlY2tQbHVnaW4sIF9wbHVnaW5zLCBfdGlja2VyLCBfY29uZmlnLCBfcm91bmRNb2RpZmllciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAgfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/gsap/gsap-core.js\n')},"../node_modules/gsap/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsapWithCSS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsapWithCSS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMaxWithCSS; });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "../node_modules/gsap/gsap-core.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineMax"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineLite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quad"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Cubic"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quart"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quint"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Strong"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Elastic"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Back"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["SteppedEase"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Bounce"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Sine"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Expo"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Circ"]; });\n\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "../node_modules/gsap/CSSPlugin.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]; });\n\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"],\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dzYXAvaW5kZXguanM/NWNlNiJdLCJuYW1lcyI6WyJnc2FwV2l0aENTUyIsImdzYXAiLCJyZWdpc3RlclBsdWdpbiIsIkNTU1BsdWdpbiIsIlR3ZWVuTWF4V2l0aENTUyIsImNvcmUiLCJUd2VlbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSxJQUFJQSxXQUFXLEdBQUdDLGtEQUFJLENBQUNDLGNBQUwsQ0FBb0JDLHVEQUFwQixLQUFrQ0Ysa0RBQXBEO0FBQUEsSUFDSTtBQUNKRyxlQUFlLEdBQUdKLFdBQVcsQ0FBQ0ssSUFBWixDQUFpQkMsS0FGbkMiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2dzYXAvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnc2FwLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMsIFR3ZWVuTGl0ZSwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCB9IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IHsgQ1NTUGx1Z2luIH0gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgQ1NTUGx1Z2luLCBUd2Vlbk1heFdpdGhDU1MgYXMgVHdlZW5NYXgsIFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/gsap/index.js\n')},"../node_modules/process/browser.js":function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9lNDhiIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLE9BQU8sR0FBR0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLEVBQS9CLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFFBQU0sSUFBSUMsS0FBSixDQUFV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QyxHQUFSLEdBQWNKLElBQWQ7QUFDQTNDLE9BQU8sQ0FBQ2dELGNBQVIsR0FBeUJMLElBQXpCO0FBQ0EzQyxPQUFPLENBQUNpRCxrQkFBUixHQUE2Qk4sSUFBN0I7QUFDQTNDLE9BQU8sQ0FBQ2tELElBQVIsR0FBZVAsSUFBZjtBQUNBM0MsT0FBTyxDQUFDbUQsZUFBUixHQUEwQlIsSUFBMUI7QUFDQTNDLE9BQU8sQ0FBQ29ELG1CQUFSLEdBQThCVCxJQUE5Qjs7QUFFQTNDLE9BQU8sQ0FBQ3FELFNBQVIsR0FBb0IsVUFBVUMsSUFBVixFQUFnQjtBQUFFLFNBQU8sRUFBUDtBQUFXLENBQWpEOztBQUVBdEQsT0FBTyxDQUFDdUQsT0FBUixHQUFrQixVQUFVRCxJQUFWLEVBQWdCO0FBQzlCLFFBQU0sSUFBSWhELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sT0FBTyxDQUFDd0QsR0FBUixHQUFjLFlBQVk7QUFBRSxTQUFPLEdBQVA7QUFBWSxDQUF4Qzs7QUFDQXhELE9BQU8sQ0FBQ3lELEtBQVIsR0FBZ0IsVUFBVUMsR0FBVixFQUFlO0FBQzNCLFFBQU0sSUFBSXBELEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFHQU4sT0FBTyxDQUFDMkQsS0FBUixHQUFnQixZQUFXO0FBQUUsU0FBTyxDQUFQO0FBQVcsQ0FBeEMiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/process/browser.js\n")},"../node_modules/setimmediate/setImmediate.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  "use strict";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== "function") {\n      callback = new Function("" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n    // So if we\'re currently running a task, we\'ll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // "too much recursion" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function (handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage("", "*");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = "setImmediate$" + Math.random() + "$";\n\n    var onGlobalMessage = function (event) {\n      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener("message", onGlobalMessage, false);\n    } else {\n      global.attachEvent("onmessage", onGlobalMessage);\n    }\n\n    registerImmediate = function (handle) {\n      global.postMessage(messagePrefix + handle, "*");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function (handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function (handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n      var script = doc.createElement("script");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function (handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don\'t get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === "[object process]") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n    // For IE 68\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../node_modules/process/browser.js")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/ODVlNSJdLCJuYW1lcyI6WyJnbG9iYWwiLCJ1bmRlZmluZWQiLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsImRvY3VtZW50IiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJjYWxsYmFjayIsIkZ1bmN0aW9uIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1biIsImFwcGx5IiwicnVuSWZQcmVzZW50Iiwic2V0VGltZW91dCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwiTWF0aCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImV2ZW50Iiwic291cmNlIiwiZGF0YSIsImluZGV4T2YiLCJzbGljZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInRvU3RyaW5nIiwiY2FsbCIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFDLGtFQUFVQSxNQUFWLEVBQWtCQyxTQUFsQixFQUE2QjtBQUMxQjs7QUFFQSxNQUFJRCxNQUFNLENBQUNFLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxNQUFJQyxVQUFVLEdBQUcsQ0FBakIsQ0FQMEIsQ0FPTjs7QUFDcEIsTUFBSUMsYUFBYSxHQUFHLEVBQXBCO0FBQ0EsTUFBSUMscUJBQXFCLEdBQUcsS0FBNUI7QUFDQSxNQUFJQyxHQUFHLEdBQUdOLE1BQU0sQ0FBQ08sUUFBakI7QUFDQSxNQUFJQyxpQkFBSjs7QUFFQSxXQUFTTixZQUFULENBQXNCTyxRQUF0QixFQUFnQztBQUM5QjtBQUNBLFFBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0EsY0FBUSxHQUFHLElBQUlDLFFBQUosQ0FBYSxLQUFLRCxRQUFsQixDQUFYO0FBQ0QsS0FKNkIsQ0FLOUI7OztBQUNBLFFBQUlFLElBQUksR0FBRyxJQUFJQyxLQUFKLENBQVVDLFNBQVMsQ0FBQ0MsTUFBVixHQUFtQixDQUE3QixDQUFYOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osSUFBSSxDQUFDRyxNQUF6QixFQUFpQ0MsQ0FBQyxFQUFsQyxFQUFzQztBQUNsQ0osVUFBSSxDQUFDSSxDQUFELENBQUosR0FBVUYsU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBTCxDQUFuQjtBQUNILEtBVDZCLENBVTlCOzs7QUFDQSxRQUFJQyxJQUFJLEdBQUc7QUFBRVAsY0FBUSxFQUFFQSxRQUFaO0FBQXNCRSxVQUFJLEVBQUVBO0FBQTVCLEtBQVg7QUFDQVAsaUJBQWEsQ0FBQ0QsVUFBRCxDQUFiLEdBQTRCYSxJQUE1QjtBQUNBUixxQkFBaUIsQ0FBQ0wsVUFBRCxDQUFqQjtBQUNBLFdBQU9BLFVB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QXlMQyxPQUFPOEMsSUFBUCxLQUFnQixXQUFoQixHQUE4QixPQUFPL0QsTUFBUCxLQUFrQixXQUFsQixHQUFnQyxJQUFoQyxHQUF1Q0EsTUFBckUsR0FBOEUrRCxJQXpML0UsQ0FBRCxDIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/setimmediate/setImmediate.js\n')},"../node_modules/timers-browserify/main.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ "../node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YTBmNSJdLCJuYW1lcyI6WyJzY29wZSIsImdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJhcHBseSIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiZXhwb3J0cyIsInNldFRpbWVvdXQiLCJUaW1lb3V0IiwiY2FsbCIsImFyZ3VtZW50cyIsImNsZWFyVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVvdXQiLCJjbG9zZSIsImlkIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJpdGVtIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSJdLCJtYXBwaW5ncyI6IkFBQUEsa0RBQUlBLEtBQUssR0FBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFsQyxJQUNDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBRGhDLElBRUFDLE1BRlo7QUFHQSxJQUFJQyxLQUFLLEdBQUdDLFFBQVEsQ0FBQ0MsU0FBVCxDQUFtQkYsS0FBL0IsQyxDQUVBOztBQUVBRyxPQUFPLENBQUNDLFVBQVIsR0FBcUIsWUFBVztBQUM5QixTQUFPLElBQUlDLE9BQUosQ0FBWUwsS0FBSyxDQUFDTSxJQUFOLENBQVdGLFVBQVgsRUFBdUJSLEtBQXZCLEVBQThCVyxTQUE5QixDQUFaLEVBQXNEQyxZQUF0RCxDQUFQO0FBQ0QsQ0FGRDs7QUFHQUwsT0FBTyxDQUFDTSxXQUFSLEdBQXNCLFlBQVc7QUFDL0IsU0FBTyxJQUFJSixPQUFKLENBQVlMLEtBQUssQ0FBQ00sSUFBTixDQUFXRyxXQUFYLEVBQXdCYixLQUF4QixFQUErQlcsU0FBL0IsQ0FBWixFQUF1REcsYUFBdkQsQ0FBUDtBQUNELENBRkQ7O0FBR0FQLE9BQU8sQ0FBQ0ssWUFBUixHQUNBTCxPQUFPLENBQUNPLGFBQVIsR0FBd0IsVUFBU0MsT0FBVCxFQUFrQjtBQUN4QyxNQUFJQSxPQUFKLEVBQWE7QUFDWEEsV0FBTyxDQUFDQyxLQUFSO0FBQ0Q7QUFDRixDQUxEOztBQU9BLFNBQVNQLE9BQVQsQ0FBaUJRLEVBQWpCLEVBQXFCQyxPQUFyQixFQUE4QjtBQUM1QixPQUFLQyxHQUFMLEdBQVdGLEVBQVg7QUFDQSxPQUFLRyxRQUFMLEdBQWdCRixPQUFoQjtBQUNEOztBQUNEVCxPQUFPLENBQUNILFNBQVIsQ0FBa0JlLEtBQWxCLEdBQTBCWixPQUFPLENBQUNILFNBQVIsQ0FBa0JnQixHQUFsQixHQUF3QixZQUFXLENBQUUsQ0FBL0Q7O0FBQ0FiLE9BQU8sQ0FBQ0gsU0FBUixDQUFrQlUsS0FBbEIsR0FBMEIsWUFBVztBQUNuQyxPQUFLSSxRQUFMLENBQWNWLElBQWQsQ0FBbUJWLEtBQW5CLEVBQTBCLEtBQUttQixHQUEvQjtBQUNELENBRkQsQyxDQUlBOzs7QUFDQVosT0FBTyxDQUFDZ0IsTUFBUixHQUFpQixVQUFTQyxJQUFULEVBQWVDLEtBQWYsRUFBc0I7QUFDckNiLGNBQVksQ0FBQ1ksSUFBSSxDQUFDRSxjQUFOLENBQVo7QUFDQUYsTUFBSSxDQUFDRyxZQUFMLEdBQW9CRixLQUFwQjtBQUNELENBSEQ7O0FBS0FsQixPQUFPLENBQUNxQixRQUFSLEdBQW1CLFVBQVNKLElBQVQsRUFBZTtBQUNoQ1osY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUNBRixNQUFJLENBQUNHLFlBQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNELENBSEQ7O0FBS0FwQixPQUFPLENBQUNzQixZQUFSLEdBQXVCdEIsT0FBTyxDQUFDdUIsTUFBUixHQUFpQixVQUFTTixJQUFULEVBQWU7QUFDckRaLGNBQVksQ0FBQ1ksSUFBSSxDQUFDRSxjQUFOLENBQVo7QUFFQSxNQUFJRCxLQUFLLEdBQUdELElBQUksQ0FBQ0csWUFBakI7O0FBQ0EsTUFBSUYsS0FBSyxJQUFJLENBQWIsRUFBZ0I7QUFDZEQsUUFBSSxDQUFDRSxjQUFMLEdBQXNCbEIsVUFBVSxDQUFDLFNBQVN1QixTQUFULEdBQXFCO0FBQ3BELFVBQUlQLElBQUksQ0FBQ1EsVUFBVCxFQUNFUixJQUFJLENBQUNRLFVBQUw7QUFDSCxLQUgrQixFQUc3QlAsS0FINkIsQ0FBaEM7QUFJRDtBQUNGLENBVkQsQyxDQVlBOzs7QUFDQVEsbUJBQU8sQ0FBQyxrRUFBRCxDQUFQLEMsQ0FDQTtBQUNBO0FBQ0E7OztBQUNBMUIsT0FBTyxDQUFDMkIsWUFBUixHQUF3QixPQUFPaEMsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFBSSxDQUFDZ0MsWUFBckMsSUFDQyxPQUFPakMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDaUMsWUFEekMsSUFFQyxRQUFRLEtBQUtBLFlBRnJDO0FBR0EzQixPQUFPLENBQUM0QixjQUFSLEdBQTBCLE9BQU9qQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxJQUFJLENBQUNpQyxjQUFyQyxJQUNDLE9BQU9sQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNrQyxjQUR6QyxJQUVDLFFBQVEsS0FBS0EsY0FGdkMsQyIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/timers-browserify/main.js\n')},"../node_modules/vue-multiple-progress/lib/progress.js":function(module,exports,__webpack_require__){eval('!function (A, s) {\n   true ? module.exports = s() : undefined;\n}(this, function () {\n  return function (A) {\n    function s(t) {\n      if (e[t]) return e[t].exports;\n      var r = e[t] = {\n        i: t,\n        l: !1,\n        exports: {}\n      };\n      return A[t].call(r.exports, r, r.exports, s), r.l = !0, r.exports;\n    }\n\n    var e = {};\n    return s.m = A, s.c = e, s.i = function (A) {\n      return A;\n    }, s.d = function (A, e, t) {\n      s.o(A, e) || Object.defineProperty(A, e, {\n        configurable: !1,\n        enumerable: !0,\n        get: t\n      });\n    }, s.n = function (A) {\n      var e = A && A.__esModule ? function () {\n        return A.default;\n      } : function () {\n        return A;\n      };\n      return s.d(e, "a", e), e;\n    }, s.o = function (A, s) {\n      return Object.prototype.hasOwnProperty.call(A, s);\n    }, s.p = "", s(s.s = 4);\n  }([function (A, s) {\n    A.exports = "data:application/vnd.ms-fontobject;base64,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";\n  }, function (A, s, e) {\n    var t = e(5);\n    "string" == typeof t && (t = [[A.i, t, ""]]);\n    var r = {};\n    r.transform = void 0;\n    e(8)(t, r);\n    t.locals && (A.exports = t.locals);\n  }, function (A, s, e) {\n    var t = e(12)(e(3), e(13), null, null, null);\n    t.options.__file = "/Users/gusaifei/Workspace/workspace-personal/progress/src/components/progress.vue", t.esModule && Object.keys(t.esModule).some(function (A) {\n      return "default" !== A && "__" !== A.substr(0, 2);\n    }) && console.error("named exports are not supported in *.vue files."), t.options.functional && console.error("[vue-loader] progress.vue: functional components are not supported with templates, they should use render functions."), A.exports = t.exports;\n  }, function (A, s, e) {\n    "use strict";\n\n    Object.defineProperty(s, "__esModule", {\n      value: !0\n    }), s.default = {\n      name: "VmProgress",\n      componentName: "VmProgress",\n      props: {\n        type: {\n          type: String,\n          default: "line",\n          validator: function (A) {\n            return ["line", "circle"].indexOf(A) > -1;\n          }\n        },\n        percentage: {\n          type: [Number, String],\n          default: 0,\n          required: !0,\n          validator: function (A) {\n            return A >= 0 && A <= 100;\n          }\n        },\n        strokeWidth: {\n          type: [Number, String],\n          default: 6\n        },\n        strokeLinecap: {\n          type: String,\n          default: "round",\n          validator: function (A) {\n            return ["butt", "square", "round"].indexOf(A) > -1;\n          }\n        },\n        strokeColor: {\n          type: String\n        },\n        trackColor: {\n          type: String,\n          default: function () {\n            return "line" === this.type ? "#e4e8f1" : "#e5e9f2";\n          }\n        },\n        textInside: {\n          type: Boolean,\n          default: !1\n        },\n        showText: {\n          type: Boolean,\n          default: !0\n        },\n        status: {\n          type: String,\n          validator: function (A) {\n            return ["success", "exception", "warning", "info"].indexOf(A) > -1;\n          }\n        },\n        width: {\n          type: Number,\n          default: 126\n        },\n        reverse: {\n          type: Boolean,\n          default: !1\n        },\n        striped: {\n          type: Boolean,\n          default: !1\n        },\n        linearClassName: String\n      },\n      data: function () {\n        return {\n          st: this.status\n        };\n      },\n      watch: {\n        percentage: function (A) {\n          this.$slots.default || (this.st = 100 === A ? "success" : this.status);\n        },\n        status: function (A) {\n          this.st = A;\n        }\n      },\n      computed: {\n        barStyle: function () {\n          var A = {};\n          return A.width = this.percentage + "%", this.strokeColor && (A.backgroundColor = this.strokeColor), A;\n        },\n        relativeStrokeWidth: function () {\n          return (this.strokeWidth / this.width * 100).toFixed(1);\n        },\n        trackPath: function () {\n          var A = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10),\n              s = this.reverse ? 0 : 1;\n          return "M 50 50 m 0 -" + A + " a " + A + " " + A + " 0 1 " + s + " 0 " + 2 * A + " a " + A + " " + A + " 0 1 " + s + " 0 -" + 2 * A;\n        },\n        perimeter: function () {\n          var A = 50 - parseFloat(this.relativeStrokeWidth) / 2;\n          return 2 * Math.PI * A;\n        },\n        circlePathStyle: function () {\n          var A = this.perimeter;\n          return {\n            strokeDasharray: A + "px," + A + "px",\n            strokeDashoffset: (1 - this.percentage / 100) * A + "px",\n            transition: "stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease"\n          };\n        },\n        stroke: function () {\n          var A = void 0;\n\n          switch (this.st) {\n            case "success":\n              A = "#13ce66";\n              break;\n\n            case "warning":\n              A = "#f7ba2a";\n              break;\n\n            case "info":\n              A = "#50bfff";\n              break;\n\n            case "exception":\n              A = "#ff4949";\n              break;\n\n            default:\n              A = this.strokeColor ? this.strokeColor : "#20a0ff";\n          }\n\n          return A;\n        },\n        iconClass: function () {\n          return "vm-progress-icon" + ("line" === this.type ? "-circle" : "") + "--" + ("exception" === this.st ? "error" : this.st);\n        },\n        progressTextSize: function () {\n          return "line" === this.type ? 12 + .4 * this.strokeWidth : .111111 * this.width + 2;\n        }\n      }\n    };\n  }, function (A, s, e) {\n    "use strict";\n\n    Object.defineProperty(s, "__esModule", {\n      value: !0\n    });\n    var t = e(2),\n        r = e.n(t),\n        n = e(1),\n        i = (e.n(n), function A(s) {\n      arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      A.installed || s.component("VmProgress", r.a);\n    });\n    "undefined" != typeof window && window.Vue && Vue.component("VmProgress", r.a), r.a.install = i, s.default = r.a;\n  }, function (A, s, e) {\n    s = A.exports = e(6)(void 0), s.push([A.i, \'@font-face {\\n  font-family: "iconfont";\\n  src: url(\' + e(0) + ");\\n  /* IE9*/\\n  src: url(" + e(0) + "#iefix) format(\'embedded-opentype\'),  url(" + e(11) + ") format(\'woff\'),  url(" + e(10) + ") format(\'truetype\'),  url(" + e(7) + \'#iconfont) format(\\\'svg\\\');\\n  /* iOS 4.1- */\\n}\\n[class^="vm-progress-icon"],\\n[class*=" vm-progress-icon"] {\\n  font-family: "iconfont" !important;\\n  font-size: 16px;\\n  font-style: normal;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n.vm-progress-icon-circle--success {\\n  color: #13ce66;\\n}\\n.vm-progress-icon-circle--success:before {\\n  content: "\\\\E8E4";\\n}\\n.vm-progress-icon--success {\\n  color: #13ce66;\\n}\\n.vm-progress-icon--success:before {\\n  content: "\\\\E8E5";\\n}\\n.vm-progress-icon-circle--error {\\n  color: #ff4949;\\n}\\n.vm-progress-icon-circle--error:before {\\n  content: "\\\\E8E7";\\n}\\n.vm-progress-icon--error {\\n  color: #ff4949;\\n}\\n.vm-progress-icon--error:before {\\n  content: "\\\\E8E8";\\n}\\n.vm-progress-icon-circle--info {\\n  color: #50bfff;\\n}\\n.vm-progress-icon-circle--info:before {\\n  content: "\\\\E8EA";\\n}\\n.vm-progress-icon--info {\\n  color: #50bfff;\\n}\\n.vm-progress-icon--info:before {\\n  content: "\\\\E8E9";\\n}\\n.vm-progress-icon-circle--warning {\\n  color: #f7ba2a;\\n}\\n.vm-progress-icon-circle--warning:before {\\n  content: "\\\\E8EC";\\n}\\n.vm-progress-icon--warning {\\n  color: #f7ba2a;\\n}\\n.vm-progress-icon--warning:before {\\n  content: "\\\\E8EE";\\n}\\n.vm-progress-icon--close:before {\\n  content: "\\\\E8E8";\\n}\\n.vm-progress {\\n  position: relative;\\n  line-height: 1;\\n}\\n.vm-progress__text {\\n  display: inline-block;\\n  vertical-align: middle;\\n  margin-left: 10px;\\n  font-size: 14px;\\n  color: #48576a;\\n  line-height: 1;\\n}\\n.vm-progress--circle {\\n  display: inline-block;\\n}\\n.vm-progress--circle .vm-progress__text {\\n  position: absolute;\\n  top: 50%;\\n  left: 0;\\n  width: 100%;\\n  margin: 0;\\n  text-align: center;\\n  transform: translate(0, -50%);\\n}\\n.vm-progress--circle .vm-progress__text i {\\n  display: inline-block;\\n  vertical-align: middle;\\n  font-size: 22px;\\n  font-weight: bold;\\n}\\n.vm-progress.is-success .vm-progress-bar__inner {\\n  background-color: #13ce66;\\n}\\n.vm-progress.is-success .vm-progress__text {\\n  color: #13ce66;\\n}\\n.vm-progress.is-exception .vm-progress-bar__inner {\\n  background-color: #ff4949;\\n}\\n.vm-progress.is-exception .vm-progress__text {\\n  color: #ff4949;\\n}\\n.vm-progress.is-warning .vm-progress-bar__inner {\\n  background-color: #f7ba2a;\\n}\\n.vm-progress.is-warning .vm-progress__text {\\n  color: #f7ba2a;\\n}\\n.vm-progress.is-info .vm-progress-bar__inner {\\n  background-color: #50bfff;\\n}\\n.vm-progress.is-info .vm-progress__text {\\n  color: #50bfff;\\n}\\n.vm-progress--without-text .vm-progress__text {\\n  display: none;\\n}\\n.vm-progress--without-text .vm-progress-bar {\\n  padding-right: 0;\\n  margin-right: 0;\\n  display: block;\\n}\\n.vm-progress--text-inside .vm-progress-bar {\\n  padding-right: 0;\\n  margin-right: 0;\\n}\\n.vm-progress-bar {\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: 100%;\\n  padding-right: 50px;\\n  margin-right: -55px;\\n  box-sizing: border-box;\\n}\\n.vm-progress-bar__outer {\\n  position: relative;\\n  height: 6px;\\n  background-color: #e4e8f1;\\n  border-radius: 100px;\\n  vertical-align: middle;\\n  overflow: hidden;\\n}\\n.vm-progress-bar__inner {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  height: 100%;\\n  line-height: 1;\\n  text-align: right;\\n  background-color: #20a0ff;\\n  border-radius: 100px;\\n}\\n.vm-progress-bar__innerText {\\n  display: inline-block;\\n  vertical-align: middle;\\n  color: #fff;\\n  font-size: 12px;\\n  margin: 0 5px;\\n  white-space: nowrap;\\n}\\n.vm-progress-bar__striped {\\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\\n  background-size: 40px 40px;\\n  animation: progress-bar-stripes 2s linear infinite;\\n}\\n@keyframes progress-bar-stripes {\\n  from {\\n    background-position: 40px 0;\\n  }\\n  to {\\n    background-position: 0 0;\\n  }\\n}\\n\', ""]);\n  }, function (A, s) {\n    function e(A, s) {\n      var e = A[1] || "",\n          r = A[3];\n      if (!r) return e;\n\n      if (s && "function" == typeof btoa) {\n        var n = t(r);\n        return [e].concat(r.sources.map(function (A) {\n          return "/*# sourceURL=" + r.sourceRoot + A + " */";\n        })).concat([n]).join("\\n");\n      }\n\n      return [e].join("\\n");\n    }\n\n    function t(A) {\n      return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(A)))) + " */";\n    }\n\n    A.exports = function (A) {\n      var s = [];\n      return s.toString = function () {\n        return this.map(function (s) {\n          var t = e(s, A);\n          return s[2] ? "@media " + s[2] + "{" + t + "}" : t;\n        }).join("");\n      }, s.i = function (A, e) {\n        "string" == typeof A && (A = [[null, A, ""]]);\n\n        for (var t = {}, r = 0; r < this.length; r++) {\n          var n = this[r][0];\n          "number" == typeof n && (t[n] = !0);\n        }\n\n        for (r = 0; r < A.length; r++) {\n          var i = A[r];\n          "number" == typeof i[0] && t[i[0]] || (e && !i[2] ? i[2] = e : e && (i[2] = "(" + i[2] + ") and (" + e + ")"), s.push(i));\n        }\n      }, s;\n    };\n  }, function (A, s, e) {\n    A.exports = e.p + "iconfont.svg?247a342cb02057a16940fcd318e2b91c";\n  }, function (A, s, e) {\n    function t(A, s) {\n      for (var e = 0; e < A.length; e++) {\n        var t = A[e],\n            r = a[t.id];\n\n        if (r) {\n          r.refs++;\n\n          for (var n = 0; n < r.parts.length; n++) r.parts[n](t.parts[n]);\n\n          for (; n < t.parts.length; n++) r.parts.push(C(t.parts[n], s));\n        } else {\n          for (var i = [], n = 0; n < t.parts.length; n++) i.push(C(t.parts[n], s));\n\n          a[t.id] = {\n            id: t.id,\n            refs: 1,\n            parts: i\n          };\n        }\n      }\n    }\n\n    function r(A, s) {\n      for (var e = [], t = {}, r = 0; r < A.length; r++) {\n        var n = A[r],\n            i = s.base ? n[0] + s.base : n[0],\n            o = n[1],\n            B = n[2],\n            g = n[3],\n            C = {\n          css: o,\n          media: B,\n          sourceMap: g\n        };\n        t[i] ? t[i].parts.push(C) : e.push(t[i] = {\n          id: i,\n          parts: [C]\n        });\n      }\n\n      return e;\n    }\n\n    function n(A, s) {\n      var e = y(A.insertInto);\n      if (!e) throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n      var t = u[u.length - 1];\n      if ("top" === A.insertAt) t ? t.nextSibling ? e.insertBefore(s, t.nextSibling) : e.appendChild(s) : e.insertBefore(s, e.firstChild), u.push(s);else {\n        if ("bottom" !== A.insertAt) throw new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n        e.appendChild(s);\n      }\n    }\n\n    function i(A) {\n      if (null === A.parentNode) return !1;\n      A.parentNode.removeChild(A);\n      var s = u.indexOf(A);\n      s >= 0 && u.splice(s, 1);\n    }\n\n    function o(A) {\n      var s = document.createElement("style");\n      return A.attrs.type = "text/css", g(s, A.attrs), n(A, s), s;\n    }\n\n    function B(A) {\n      var s = document.createElement("link");\n      return A.attrs.type = "text/css", A.attrs.rel = "stylesheet", g(s, A.attrs), n(A, s), s;\n    }\n\n    function g(A, s) {\n      Object.keys(s).forEach(function (e) {\n        A.setAttribute(e, s[e]);\n      });\n    }\n\n    function C(A, s) {\n      var e, t, r, n;\n\n      if (s.transform && A.css) {\n        if (!(n = s.transform(A.css))) return function () {};\n        A.css = n;\n      }\n\n      if (s.singleton) {\n        var g = l++;\n        e = I || (I = o(s)), t = Q.bind(null, e, g, !1), r = Q.bind(null, e, g, !0);\n      } else A.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (e = B(s), t = c.bind(null, e, s), r = function () {\n        i(e), e.href && URL.revokeObjectURL(e.href);\n      }) : (e = o(s), t = w.bind(null, e), r = function () {\n        i(e);\n      });\n\n      return t(A), function (s) {\n        if (s) {\n          if (s.css === A.css && s.media === A.media && s.sourceMap === A.sourceMap) return;\n          t(A = s);\n        } else r();\n      };\n    }\n\n    function Q(A, s, e, t) {\n      var r = e ? "" : t.css;\n      if (A.styleSheet) A.styleSheet.cssText = L(s, r);else {\n        var n = document.createTextNode(r),\n            i = A.childNodes;\n        i[s] && A.removeChild(i[s]), i.length ? A.insertBefore(n, i[s]) : A.appendChild(n);\n      }\n    }\n\n    function w(A, s) {\n      var e = s.css,\n          t = s.media;\n      if (t && A.setAttribute("media", t), A.styleSheet) A.styleSheet.cssText = e;else {\n        for (; A.firstChild;) A.removeChild(A.firstChild);\n\n        A.appendChild(document.createTextNode(e));\n      }\n    }\n\n    function c(A, s, e) {\n      var t = e.css,\n          r = e.sourceMap,\n          n = void 0 === s.convertToAbsoluteUrls && r;\n      (s.convertToAbsoluteUrls || n) && (t = p(t)), r && (t += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r)))) + " */");\n      var i = new Blob([t], {\n        type: "text/css"\n      }),\n          o = A.href;\n      A.href = URL.createObjectURL(i), o && URL.revokeObjectURL(o);\n    }\n\n    var a = {},\n        E = function (A) {\n      var s;\n      return function () {\n        return void 0 === s && (s = A.apply(this, arguments)), s;\n      };\n    }(function () {\n      return window && document && document.all && !window.atob;\n    }),\n        y = function (A) {\n      var s = {};\n      return function (e) {\n        return void 0 === s[e] && (s[e] = A.call(this, e)), s[e];\n      };\n    }(function (A) {\n      return document.querySelector(A);\n    }),\n        I = null,\n        l = 0,\n        u = [],\n        p = e(9);\n\n    A.exports = function (A, s) {\n      if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");\n      s = s || {}, s.attrs = "object" == typeof s.attrs ? s.attrs : {}, s.singleton || (s.singleton = E()), s.insertInto || (s.insertInto = "head"), s.insertAt || (s.insertAt = "bottom");\n      var e = r(A, s);\n      return t(e, s), function (A) {\n        for (var n = [], i = 0; i < e.length; i++) {\n          var o = e[i],\n              B = a[o.id];\n          B.refs--, n.push(B);\n        }\n\n        if (A) {\n          t(r(A, s), s);\n        }\n\n        for (var i = 0; i < n.length; i++) {\n          var B = n[i];\n\n          if (0 === B.refs) {\n            for (var g = 0; g < B.parts.length; g++) B.parts[g]();\n\n            delete a[B.id];\n          }\n        }\n      };\n    };\n\n    var L = function () {\n      var A = [];\n      return function (s, e) {\n        return A[s] = e, A.filter(Boolean).join("\\n");\n      };\n    }();\n  }, function (A, s) {\n    A.exports = function (A) {\n      var s = "undefined" != typeof window && window.location;\n      if (!s) throw new Error("fixUrls requires window.location");\n      if (!A || "string" != typeof A) return A;\n      var e = s.protocol + "//" + s.host,\n          t = e + s.pathname.replace(/\\/[^\\/]*$/, "/");\n      return A.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (A, s) {\n        var r = s.trim().replace(/^"(.*)"$/, function (A, s) {\n          return s;\n        }).replace(/^\'(.*)\'$/, function (A, s) {\n          return s;\n        });\n        if (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(r)) return A;\n        var n;\n        return n = 0 === r.indexOf("//") ? r : 0 === r.indexOf("/") ? e + r : t + r.replace(/^\\.\\//, ""), "url(" + JSON.stringify(n) + ")";\n      });\n    };\n  }, function (A, s) {\n    A.exports = "data:application/x-font-ttf;base64,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";\n  }, function (A, s) {\n    A.exports = "data:application/font-woff;base64,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";\n  }, function (A, s) {\n    A.exports = function (A, s, e, t, r) {\n      var n,\n          i = A = A || {},\n          o = typeof A.default;\n      "object" !== o && "function" !== o || (n = A, i = A.default);\n      var B = "function" == typeof i ? i.options : i;\n      s && (B.render = s.render, B.staticRenderFns = s.staticRenderFns), t && (B._scopeId = t);\n      var g;\n\n      if (r ? (g = function (A) {\n        A = A || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, A || "undefined" == typeof __VUE_SSR_CONTEXT__ || (A = __VUE_SSR_CONTEXT__), e && e.call(this, A), A && A._registeredComponents && A._registeredComponents.add(r);\n      }, B._ssrRegister = g) : e && (g = e), g) {\n        var C = B.functional,\n            Q = C ? B.render : B.beforeCreate;\n        C ? B.render = function (A, s) {\n          return g.call(s), Q(A, s);\n        } : B.beforeCreate = Q ? [].concat(Q, g) : [g];\n      }\n\n      return {\n        esModule: n,\n        exports: i,\n        options: B\n      };\n    };\n  }, function (A, s, e) {\n    A.exports = {\n      render: function () {\n        var A = this,\n            s = A.$createElement,\n            e = A._self._c || s;\n        return e("div", {\n          staticClass: "vm-progress",\n          class: ["vm-progress--" + A.type, A.status ? "is-" + A.status : "", {\n            "vm-progress--without-text": !A.showText,\n            "vm-progress--text-inside": A.textInside\n          }]\n        }, ["line" === A.type ? e("div", {\n          staticClass: "vm-progress-bar"\n        }, [e("div", {\n          staticClass: "vm-progress-bar__outer",\n          style: {\n            height: A.strokeWidth + "px",\n            backgroundColor: A.trackColor\n          }\n        }, [e("div", {\n          staticClass: "vm-progress-bar__inner",\n          class: [{\n            "vm-progress-bar__striped": A.striped\n          }, A.linearClassName],\n          style: A.barStyle\n        }, [A.showText && A.textInside ? e("div", {\n          staticClass: "vm-progress-bar__innerText"\n        }, [A._t("default", [A._v(A._s(A.percentage) + "%")])], 2) : A._e()])])]) : e("div", {\n          staticClass: "vm-progress-circle",\n          style: {\n            height: A.width + "px",\n            width: A.width + "px"\n          }\n        }, [e("svg", {\n          attrs: {\n            viewBox: "0 0 100 100"\n          }\n        }, [e("path", {\n          staticClass: "vm-progress-circle__track",\n          attrs: {\n            d: A.trackPath,\n            stroke: A.trackColor,\n            "stroke-width": A.relativeStrokeWidth,\n            fill: "none"\n          }\n        }), A._v(" "), e("path", {\n          staticClass: "vm-progress-circle__path",\n          style: A.circlePathStyle,\n          attrs: {\n            d: A.trackPath,\n            "stroke-linecap": A.strokeLinecap,\n            stroke: A.stroke,\n            "stroke-width": A.relativeStrokeWidth,\n            fill: "none"\n          }\n        })])]), A._v(" "), A.showText && !A.textInside ? e("div", {\n          ref: "progressText",\n          staticClass: "vm-progress__text",\n          style: {\n            fontSize: A.progressTextSize + "px"\n          }\n        }, [!A.st || A.strokeColor || A.$slots.default ? [A._t("default", [A._v(A._s(A.percentage) + "%")])] : e("i", {\n          class: A.iconClass\n        })], 2) : A._e()]);\n      },\n      staticRenderFns: []\n    }, A.exports.render._withStripped = !0;\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1tdWx0aXBsZS1wcm9ncmVzcy9saWIvcHJvZ3Jlc3MuanM/ZGJjMyJdLCJuYW1lcyI6WyJBIiwicyIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0IiwiZSIsInIiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwidHJhbnNmb3JtIiwibG9jYWxzIiwib3B0aW9ucyIsIl9fZmlsZSIsImVzTW9kdWxlIiwia2V5cyIsInNvbWUiLCJzdWJzdHIiLCJjb25zb2xlIiwiZXJyb3IiLCJmdW5jdGlvbmFsIiwidmFsdWUiLCJuYW1lIiwiY29tcG9uZW50TmFtZSIsInByb3BzIiwidHlwZSIsIlN0cmluZyIsInZhbGlkYXRvciIsImluZGV4T2YiLCJwZXJjZW50YWdlIiwiTnVtYmVyIiwicmVxdWlyZWQiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VDb2xvciIsInRyYWNrQ29sb3IiLCJ0ZXh0SW5zaWRlIiwiQm9vbGVhbiIsInNob3dUZXh0Iiwic3RhdHVzIiwid2lkdGgiLCJyZXZlcnNlIiwic3RyaXBlZCIsImxpbmVhckNsYXNzTmFtZSIsImRhdGEiLCJzdCIsIndhdGNoIiwiJHNsb3RzIiwiY29tcHV0ZWQiLCJiYXJTdHlsZSIsImJhY2tncm91bmRDb2xvciIsInJlbGF0aXZlU3Ryb2tlV2lkdGgiLCJ0b0ZpeGVkIiwidHJhY2tQYXRoIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0IiwicGVyaW1ldGVyIiwiTWF0aCIsIlBJIiwiY2lyY2xlUGF0aFN0eWxlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInRyYW5zaXRpb24iLCJzdHJva2UiLCJpY29uQ2xhc3MiLCJwcm9ncmVzc1RleHRTaXplIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaW5zdGFsbGVkIiwiY29tcG9uZW50IiwiYSIsIndpbmRvdyIsIlZ1ZSIsImluc3RhbGwiLCJwdXNoIiwiYnRvYSIsImNvbmNhdCIsInNvdXJjZXMiLCJtYXAiLCJzb3VyY2VSb290Iiwiam9pbiIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInRvU3RyaW5nIiwiaWQiLCJyZWZzIiwicGFydHMiLCJDIiwiYmFzZSIsIkIiLCJnIiwiY3NzIiwibWVkaWEiLCJzb3VyY2VNYXAiLCJ5IiwiaW5zZXJ0SW50byIsIkVycm9yIiwidSIsImluc2VydEF0IiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImZpcnN0Q2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzcGxpY2UiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhdHRycyIsInJlbCIsImZvckVhY2giLCJzZXRBdHRyaWJ1dGUiLCJzaW5nbGV0b24iLCJJIiwiUSIsImJpbmQiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJCbG9iIiwiaHJlZiIsInciLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsIkwiLCJjcmVhdGVUZXh0Tm9kZSIsImNoaWxkTm9kZXMiLCJjb252ZXJ0VG9BYnNvbHV0ZVVybHMiLCJFIiwiYXBwbHkiLCJhbGwiLCJhdG9iIiwicXVlcnlTZWxlY3RvciIsIkRFQlVHIiwiZmlsdGVyIiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3QiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJ0cmltIiwidGVzdCIsInJlbmRlciIsInN0YXRpY1JlbmRlckZucyIsIl9zY29wZUlkIiwiJHZub2RlIiwic3NyQ29udGV4dCIsInBhcmVudCIsIl9fVlVFX1NTUl9DT05URVhUX18iLCJfcmVnaXN0ZXJlZENvbXBvbmVudHMiLCJhZGQiLCJfc3NyUmVnaXN0ZXIiLCJiZWZvcmVDcmVhdGUiLCIkY3JlYXRlRWxlbWVudCIsIl9zZWxmIiwiX2MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwic3R5bGUiLCJoZWlnaHQiLCJfdCIsIl92IiwiX3MiLCJfZSIsInZpZXdCb3giLCJmaWxsIiwicmVmIiwiZm9udFNpemUiLCJfd2l0aFN0cmlwcGVkIl0sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFVBQVNBLENBQVQsRUFBV0MsQ0FBWCxFQUFhO0FBQUMsVUFBa0RDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFlRixDQUFDLEVBQWxFLEdBQXFFLFNBQXJFO0FBQXFMLENBQW5NLENBQW9NLElBQXBNLEVBQXlNLFlBQVU7QUFBQyxTQUFPLFVBQVNELENBQVQsRUFBVztBQUFDLGFBQVNDLENBQVQsQ0FBV0csQ0FBWCxFQUFhO0FBQUMsVUFBR0MsQ0FBQyxDQUFDRCxDQUFELENBQUosRUFBUSxPQUFPQyxDQUFDLENBQUNELENBQUQsQ0FBRCxDQUFLRCxPQUFaO0FBQW9CLFVBQUlHLENBQUMsR0FBQ0QsQ0FBQyxDQUFDRCxDQUFELENBQUQsR0FBSztBQUFDRyxTQUFDLEVBQUNILENBQUg7QUFBS0ksU0FBQyxFQUFDLENBQUMsQ0FBUjtBQUFVTCxlQUFPLEVBQUM7QUFBbEIsT0FBWDtBQUFpQyxhQUFPSCxDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLSyxJQUFMLENBQVVILENBQUMsQ0FBQ0gsT0FBWixFQUFvQkcsQ0FBcEIsRUFBc0JBLENBQUMsQ0FBQ0gsT0FBeEIsRUFBZ0NGLENBQWhDLEdBQW1DSyxDQUFDLENBQUNFLENBQUYsR0FBSSxDQUFDLENBQXhDLEVBQTBDRixDQUFDLENBQUNILE9BQW5EO0FBQTJEOztBQUFBLFFBQUlFLENBQUMsR0FBQyxFQUFOO0FBQVMsV0FBT0osQ0FBQyxDQUFDUyxDQUFGLEdBQUlWLENBQUosRUFBTUMsQ0FBQyxDQUFDVSxDQUFGLEdBQUlOLENBQVYsRUFBWUosQ0FBQyxDQUFDTSxDQUFGLEdBQUksVUFBU1AsQ0FBVCxFQUFXO0FBQUMsYUFBT0Es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ZXNzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKEEscyl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9cygpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10scyk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5wcm9ncmVzcz1zKCk6QS5wcm9ncmVzcz1zKCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oQSl7ZnVuY3Rpb24gcyh0KXtpZihlW3RdKXJldHVybiBlW3RdLmV4cG9ydHM7dmFyIHI9ZVt0XT17aTp0LGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIEFbdF0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMscyksci5sPSEwLHIuZXhwb3J0c312YXIgZT17fTtyZXR1cm4gcy5tPUEscy5jPWUscy5pPWZ1bmN0aW9uKEEpe3JldHVybiBBfSxzLmQ9ZnVuY3Rpb24oQSxlLHQpe3MubyhBLGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6dH0pfSxzLm49ZnVuY3Rpb24oQSl7dmFyIGU9QSYmQS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIEEuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gQX07cmV0dXJuIHMuZChlLFwiYVwiLGUpLGV9LHMubz1mdW5jdGlvbihBLHMpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxzKX0scy5wPVwiXCIscyhzLnM9NCl9KFtmdW5jdGlvbihBLHMpe0EuZXhwb3J0cz1cImRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LFFoZ0FBQ2dYQUFBQkFBSUFBQUFBQUFJQUJnTUFBQUFBQUFBQkFQUUJBQUFBQUV4UUFRQUFBQUFBQUJBQUFBQUFBQUFBQUFFQUFBQUFBQUFBY1NPcUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFhUUJqQUc4QWJnQm1BRzhBYmdCMEFBQUFEQUJOQUdVQVpBQnBBSFVBYlFBQUFJb0FWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QURzQUlBQjBBSFFBWmdCaEFIVUFkQUJ2QUdnQWFRQnVBSFFBSUFBb0FIWUFNQUF1QURrQU5BQXBBQ0FBTFFCc0FDQUFPQUFnQUMwQWNnQWdBRFVBTUFBZ0FDMEFSd0FnQURJQU1BQXdBQ0FBTFFCNEFDQUFNUUEwQUNBQUxRQjNBQ0FBSWdCSEFDSUFJQUF0QUdZQUlBQXRBSE1BQUFBUUFHa0FZd0J2QUc0QVpnQnZBRzRBZEFBQUFBQUFBQUVBQUFBUUFRQUFCQUFBUmtaVVRYZCt4L1lBQUFFTUFBQUFIRWRFUlVZQU9RQUdBQUFCS0FBQUFDQlBVeTh5VnhSYnZnQUFBVWdBQUFCV1kyMWhjTkw0Mkd3QUFBR2dBQUFCYW1OMmRDQU01ZjkwQUFBTTFBQUFBQ1JtY0dkdE1QZWVsUUFBRFBnQUFBbVdaMkZ6Y0FBQUFCQUFBQXpNQUFBQUNHZHNlV2F4THVWR0FBQUREQUFBQmhCb1pXRmtEa3hwSXdBQUNSd0FBQUEyYUdobFlRZGVBOFlBQUFsVUFBQUFKR2h0ZEhnUTVRSnNBQUFKZUFBQUFDSnNiMk5oQ2pZSUhnQUFDWndBQUFBYWJXRjRjQUV1Q2lzQUFBbTRBQUFBSUc1aGJXVVVMYzRWQUFBSjJBQUFBaXR3YjNOMHZpUS8xUUFBREFRQUFBREljSEpsY0tXNXZtWUFBQmFRQUFBQWxRQUFBQUVBQUFBQXpEMml6d0FBQUFEVm9KS1RBQUFBQU5XZ2twTUFBUUFBQUE0QUFBQVlBQUFBQUFBQ0FBRUFBd0FMQUFFQUJBQUFBQUlBQUFBQkEvMEI5QUFGQUFnQ21RTE1BQUFBandLWkFzd0FBQUhyQURNQkNRQUFBZ0FHQXdBQUFBQUFBQUFBQUFFUUFBQUFBQUFBQUFBQUFBQlFaa1ZrQUVBQWVPanVBNEQvZ0FCY0EwQUFRQUFBQUFFQUFBQUFBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQUFBQUFBWkFBREFBRUFBQUFjQUFRQVNBQUFBQTRBQ0FBQ0FBWUFBQUI0Nk9YbzZ1anM2TzcvL3dBQUFBQUFlT2prNk9mbzdPanUvLzhBQVArTEZ5QVhIeGNlRngwQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUJBZ0FBQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFMUC9oQTd3REdBQVdBREFBT2dCU0FGNEJkMHV3RTFCWVFFb0NBUUFORGcwQURtWUFBdzRCRGdOZUFBRUlDQUZjRUFFSkNBb0dDVjRSQVF3R0JBWU1YZ0FMQkF0cER3RUlBQVlNQ0FaWUFBb0hCUUlFQ3dvRVdSSUJEZzROVVFBTkRRb09RaHRMc0JkUVdFQkxBZ0VBRFE0TkFBNW1BQU1PQVE0RFhnQUJDQWdCWEJBQkNRZ0tDQWtLWmhFQkRBWUVCZ3hlQUFzRUMya1BBUWdBQmd3SUJsZ0FDZ2NGQWdRTENnUlpFZ0VPRGcxUkFBME5DZzVDRzB1d0dGQllRRXdDQVFBTkRnMEFEbVlBQXc0QkRnTmVBQUVJQ0FGY0VBRUpDQW9JQ1FwbUVRRU1CZ1FHREFSbUFBc0VDMmtQQVFnQUJnd0lCbGdBQ2djRkFnUUxDZ1JaRWdFT0RnMVJBQTBOQ2c1Q0cwQk9BZ0VBRFE0TkFBNW1BQU1PQVE0REFXWUFBUWdPQVFoa0VBRUpDQW9JQ1FwbUVRRU1CZ1FHREFSbUFBc0VDMmtQQVFnQUJnd0lCbGdBQ2djRkFnUUxDZ1JaRWdFT0RnMVJBQTBOQ2c1Q1dWbFpRQ2hUVXpzN01qRVhGMU5lVTE1YldEdFNPMUpMUXpjMU1Ub3lPaGN3RnpCUkVURVlFU2dWUUJNV0t3RUdLd0VpRGdJZEFTRTFOQ1kxTkM0Q0t3RVZJUVVWRkJZVURnSWpCaVlyQVNjaEJ5c0JJaWNpTGdJOUFSY2lCaFFXTXpJMk5DWVhCZ2NPQXg0Qk93WXlOaWN1QVNjbUp3RTFORDRDT3dFeUZoMEJBUmtiR2xNU0pSd1NBNUFCQ2hnbkhvWCtTZ0tpQVJVZkl3NE9IdzRnTGY1SkxCMGlGQmtaSUJNSWR3d1NFZ3dORWhLTUNBWUZDd1FDQkE4T0pVTlJVRUFrRnhZSkJRa0ZCUWIrcEFVUEdoVzhIeWtDSHdFTUdTY2FUQ2tRSEFRTklCc1NZWWcwRnpvNkpSY0pBUUdBZ0FFVEd5QU9wejhSR2hFUkdoRjhHaFlUSkE0UURRZ1lHZzBqRVJNVUFYZmtDeGdUREIwbTR3QUFBZ0JBLzhBRHdBTkFBQWNBRHdBaVFCOFBEZzBNQ3drR0FRQUJRQUFBQVFFQVRRQUFBQUZSQUFFQUFVVVRFQUlRS3dBZ0FCQUFJQUFRQVFjdkFUY1hBUmNDdWY2Ty92a0JCd0Z5QVFmOTdDNHRkQzExQVc4dUEwRCsrZjZPL3ZrQkJ3Rnkvbmt1TG5VdWRRRnZMUUFBQUFJQXJnQi9BMDBDZWdBREFBY0FDTFVHQkFJQUFpWXJFeGNISndFWEFTZmMwaTNTQW5FdC9qTXRBWC9TTGRJQktDNytOQzBBQUFBQUFnQkEvOEFEd0FOQUFBY0FFd0FvUUNVVEVoRVFEdzROREFzS0NRZ01BUUFCUUFBQUFRRUFUUUFBQUFGUkFBRUFBVVVURUFJUUt3QWdBQkFBSUFBUUF3Y25CeWMzSnpjWE54Y0hBcm4ranY3NUFRY0JjZ0VIMGkzQndpM0N3UzNCd2kzQkEwRCsrZjZPL3ZrQkJ3Rnkvb1V0d2NBdHdjSXR3c0V0d1FBQUFBQUJBTmtBV1FNbkFxY0FDd0FHc3djQkFTWXJBU2NISndjWEJ4YzNGemNuQXlZdCtma3QrZmt0K2ZrdCtBSjVMZm41TGZuNUxmajRMZmtBQUFBQ0FZQUFBQUtBQXdBQUF3QU9BRHRBT0FrSUJ3TURBZ0ZBQUFBQkFHZ0FBUUlCYUFBQ0F3Sm9CZ1VDQXdRRUEwc0dCUUlEQXdSUUFBUURCRVFFQkFRT0JBNFJGQklSRUFjVEt3RXpGU01URVNNSEZ6Y1JJeFVoTlFIZ1FFQkFJWDhSVDJBQkFBTUFRUDJBQWtBaVBoYitDa0JBQUFNQVFQL0FBOEFEUUFBSEFBc0FGZ0ErUURzU0VSQURCUVlCUUFjQkJRWUVCZ1VFWmdBQUFBSURBQUpYQUFNQUJnVURCbGNBQkFFQkJFc0FCQVFCVVFBQkJBRkZFUlFSRVJFVEV4QUlGaXNBSUFBUUFDQUFFQ1V6RlNNVElUVXpOUWNuTnpNUk13SzUvbzcrK1FFSEFYSUJCLzRnUUVDZy93QmdUeEYvSVdBRFFQNzUvbzcrK1FFSEFYSkhRUDVBUVBZV1BpTCt3QUFBQXdCQS84QUR3QU5BQUFjQUN3QVBBREZBTGdBQUFBUUZBQVJYQmdFRkFBTUNCUU5YQUFJQkFRSkxBQUlDQVZFQUFRSUJSUXdNREE4TUR4SVJFeE1RQnhNckFDQUFFQUFnQUJBQkl6VXpKeEV6RVFLNS9vNysrUUVIQVhJQkIvNWdRRUJBUUFOQS92bitqdjc1QVFjQmN2NUhRRUFCZ1A2QUFBQUFBQUlCNEFBQUFpQURBQUFEQUFjQWlVdXdDMUJZUUJzQUFRSUFBZ0ZlQUFBQVp3QURBZ0lEU3dBREF3SlBBQUlEQWtNYlM3QVVVRmhBRmdBQkFnQUNBVjRBQUFCbkFBSUNBMDhBQXdNS0FrSWJTN0FXVUZoQUZ3QUJBZ0FDQVFCbUFBQUFad0FDQWdOUEFBTURDZ0pDRzBBY0FBRUNBQUlCQUdZQUFBQm5BQU1DQWdOTEFBTURBazhBQWdNQ1ExbFpXYlVSRVJFUUJCSXJJU00xTXljekVTTUNJRUJBUUVCQVFFQUNnQUFCQUFBQUFRQUFBS29qY1Y4UFBQVUFDd1FBQUFBQUFOV2drcE1BQUFBQTFhQ1Nrd0FzLzhBRHdBTkFBQUFBQ0FBQ0FBQUFBQUFBQUFFQUFBTkEvOEFBWEFRQUFBQUFBQVBBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFGQkFBQUFBQUFBQUFCVlFBQUEra0FMQVFBQUVBQXJnQkFBTmtCZ0FCQUFFQUI0QUFBQUFBQUFBQUFBQUFCUEFGMEFaQUIwQUh1QWlnQ2RBS3lBd2dBQUFBQkFBQUFEQUJmQUFVQUFBQUFBQUlBSmdBMEFHd0FBQUNLQ1pZQUFBQUFBQUFBREFDV0FBRUFBQUFBQUFFQUNBQUFBQUVBQUFBQUFBSUFCZ0FJQUFFQUFBQUFBQU1BSkFBT0FBRUFBQUFBQUFRQUNBQXlBQUVBQUFBQUFBVUFSUUE2QUFFQUFBQUFBQVlBQ0FCL0FBTUFBUVFKQUFFQUVBQ0hBQU1BQVFRSkFBSUFEQUNYQUFNQUFRUUpBQU1BU0FDakFBTUFBUVFKQUFRQUVBRHJBQU1BQVFRSkFBVUFpZ0Q3QUFNQUFRUUpBQVlBRUFHRmFXTnZibVp2Ym5STlpXUnBkVzFHYjI1MFJtOXlaMlVnTWk0d0lEb2dhV052Ym1admJuUWdPaUF5T0MwM0xUSXdNVGRwWTI5dVptOXVkRlpsY25OcGIyNGdNUzR3T3lCMGRHWmhkWFJ2YUdsdWRDQW9kakF1T1RRcElDMXNJRGdnTFhJZ05UQWdMVWNnTWpBd0lDMTRJREUwSUMxM0lDSkhJaUF0WmlBdGMybGpiMjVtYjI1MEFHa0FZd0J2QUc0QVpnQnZBRzRBZEFCTkFHVUFaQUJwQUhVQWJRQkdBRzhBYmdCMEFFWUFid0J5QUdjQVpRQWdBRElBTGdBd0FDQUFPZ0FnQUdrQVl3QnZBRzRBWmdCdkFHNEFkQUFnQURvQUlBQXlBRGdBTFFBM0FDMEFNZ0F3QURFQU53QnBBR01BYndCdUFHWUFid0J1QUhRQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBRHNBSUFCMEFIUUFaZ0JoQUhVQWRBQnZBR2dBYVFCdUFIUUFJQUFvQUhZQU1BQXVBRGtBTkFBcEFDQUFMUUJzQUNBQU9BQWdBQzBBY2dBZ0FEVUFNQUFnQUMwQVJ3QWdBRElBTUFBd0FDQUFMUUI0QUNBQU1RQTBBQ0FBTFFCM0FDQUFJZ0JIQUNJQUlBQXRBR1lBSUFBdEFITUFhUUJqQUc4QWJnQm1BRzhBYmdCMEFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3QUFBQUJBQUlBV3dFQ0FRTUJCQUVGQVFZQkJ3RUlBUWthZW1obGJtZHhkV1YzWVc1amFHVnVaeTE1ZFdGdWEzVmhibWNRZW1obGJtZHhkV1YzWVc1amFHVnVaeHRqZFc5M2RXZDFZVzVpYVhGMWVHbGhieTE1ZFdGdWEzVmhibWNSWTNWdmQzVm5kV0Z1WW1seGRYaHBZVzhGZUdsdWVHa1BlR2x1ZUdrdGVYVmhibXQxWVc1bkUyZGhiblJoYm1oaGJ5MTVkV0Z1YTNWaGJtY0paMkZ1ZEdGdWFHRnZBQUVBQWYvL0FBOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFESUFNZ01ZLytFRFFQL0FBeGovNFFOQS84Q3dBQ3l3SUdCbUxiQUJMQ0JrSUxEQVVMQUVKbHF3QkVWYldDRWpJUnVLV0NDd1VGQllJYkJBV1JzZ3NEaFFXQ0d3T0ZsWklMQUtSV0Zrc0NoUVdDR3dDa1Vnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FBSzFsWkk3QUFVRmhsV1ZrdHNBSXNJRVVnc0FRbFlXUWdzQVZEVUZpd0JTTkNzQVlqUWhzaElWbXdBV0F0c0FNc0l5RWpJU0Jrc1FWaVFpQ3dCaU5Dc2dvQUFpb2hJTEFHUXlDS0lJcXdBQ3V4TUFVbGlsRllZRkFiWVZKWldDTlpJU0N3UUZOWXNBQXJHeUd3UUZranNBQlFXR1ZaTGJBRUxMQUlJMEt3QnlOQ3NBQWpRckFBUTdBSFExRllzQWhESzdJQUFRQkRZRUt3Rm1VY1dTMndCU3l3QUVNZ1JTQ3dBa1Zqc0FGRlltQkVMYkFHTExBQVF5QkZJTEFBS3lPeEJBUWxZQ0JGaWlOaElHUWdzQ0JRV0NHd0FCdXdNRkJZc0NBYnNFQlpXU093QUZCWVpWbXdBeVVqWVVSRUxiQUhMTEVGQlVXd0FXRkVMYkFJTExBQllDQWdzQXBEU3JBQVVGZ2dzQW9qUWxtd0MwTktzQUJTV0NDd0N5TkNXUzJ3Q1N3Z3VBUUFZaUM0QkFCamlpTmhzQXhEWUNDS1lDQ3dEQ05DSXkyd0NpeExWRml4QndGRVdTU3dEV1VqZUMyd0N5eExVVmhMVTFpeEJ3RkVXUnNoV1NTd0UyVWplQzJ3REN5eEFBMURWVml4RFExRHNBRmhRckFKSzFtd0FFT3dBaVZDc2dBQkFFTmdRckVLQWlWQ3NRc0NKVUt3QVJZaklMQURKVkJZc0FCRHNBUWxRb3FLSUlvalliQUlLaUVqc0FGaElJb2pZYkFJS2lFYnNBQkRzQUlsUXJBQ0pXR3dDQ29oV2JBS1EwZXdDME5IWUxDQVlpQ3dBa1Zqc0FGRlltQ3hBQUFUSTBTd0FVT3dBRDZ5QVFFQlEyQkNMYkFOTExFQUJVVlVXQUN3RFNOQ0lHQ3dBV0cxRGc0QkFBd0FRa0tLWUxFTUJDdXdheXNiSWxrdHNBNHNzUUFOS3kyd0R5eXhBUTByTGJBUUxMRUNEU3N0c0JFc3NRTU5LeTJ3RWl5eEJBMHJMYkFUTExFRkRTc3RzQlFzc1FZTkt5MndGU3l4QncwckxiQVdMTEVJRFNzdHNCY3NzUWtOS3kyd0dDeXdCeXV4QUFWRlZGZ0FzQTBqUWlCZ3NBRmh0UTRPQVFBTUFFSkNpbUN4REFRcnNHc3JHeUpaTGJBWkxMRUFHQ3N0c0Jvc3NRRVlLeTJ3R3l5eEFoZ3JMYkFjTExFREdDc3RzQjBzc1FRWUt5MndIaXl4QlJnckxiQWZMTEVHR0NzdHNDQXNzUWNZS3kyd0lTeXhDQmdyTGJBaUxMRUpHQ3N0c0NNc0lHQ3dEbUFnUXlPd0FXQkRzQUlsc0FJbFVWZ2pJRHl3QVdBanNCSmxIQnNoSVZrdHNDUXNzQ01yc0NNcUxiQWxMQ0FnUnlBZ3NBSkZZN0FCUldKZ0kyRTRJeUNLVlZnZ1J5QWdzQUpGWTdBQlJXSmdJMkU0R3lGWkxiQW1MTEVBQlVWVVdBQ3dBUmF3SlNxd0FSVXdHeUpaTGJBbkxMQUhLN0VBQlVWVVdBQ3dBUmF3SlNxd0FSVXdHeUpaTGJBb0xDQTFzQUZnTGJBcExBQ3dBMFZqc0FGRllyQUFLN0FDUldPd0FVVmlzQUFyc0FBV3RBQUFBQUFBUkQ0ak9MRW9BUlVxTGJBcUxDQThJRWNnc0FKRlk3QUJSV0pnc0FCRFlUZ3RzQ3NzTGhjOExiQXNMQ0E4SUVjZ3NBSkZZN0FCUldKZ3NBQkRZYkFCUTJNNExiQXRMTEVDQUJZbElDNGdSN0FBSTBLd0FpVkppb3BISTBjallTQllZaHNoV2JBQkkwS3lMQUVCRlJRcUxiQXVMTEFBRnJBRUpiQUVKVWNqUnlOaHNBWkZLMldLTGlNZ0lEeUtPQzJ3THl5d0FCYXdCQ1d3QkNVZ0xrY2pSeU5oSUxBRUkwS3dCa1VySUxCZ1VGZ2dzRUJSV0xNQ0lBTWdHN01DSmdNYVdVSkNJeUN3Q1VNZ2lpTkhJMGNqWVNOR1lMQUVRN0NBWW1BZ3NBQXJJSXFLWVNDd0FrTmdaQ093QTBOaFpGQllzQUpEWVJ1d0EwTmdXYkFESmJDQVltRWpJQ0N3QkNZalJtRTRHeU93Q1VOR3NBSWxzQWxEUnlOSEkyRmdJTEFFUTdDQVltQWpJTEFBS3lPd0JFTmdzQUFyc0FVbFliQUZKYkNBWXJBRUptRWdzQVFsWUdRanNBTWxZR1JRV0NFYkl5RlpJeUFnc0FRbUkwWmhPRmt0c0RBc3NBQVdJQ0Fnc0FVbUlDNUhJMGNqWVNNOE9DMndNU3l3QUJZZ3NBa2pRaUFnSUVZalI3QUFLeU5oT0Myd01peXdBQmF3QXlXd0FpVkhJMGNqWWJBQVZGZ3VJRHdqSVJ1d0FpV3dBaVZISTBjallTQ3dCU1d3QkNWSEkwY2pZYkFHSmJBRkpVbXdBaVZoc0FGRll5TWdXR0liSVZsanNBRkZZbUFqTGlNZ0lEeUtPQ01oV1Myd015eXdBQllnc0FsRElDNUhJMGNqWVNCZ3NDQmdackNBWWlNZ0lEeUtPQzJ3TkN3aklDNUdzQUlsUmxKWUlEeFpMckVrQVJRckxiQTFMQ01nTGthd0FpVkdVRmdnUEZrdXNTUUJGQ3N0c0RZc0l5QXVSckFDSlVaU1dDQThXU01nTGthd0FpVkdVRmdnUEZrdXNTUUJGQ3N0c0Rjc3NDNHJJeUF1UnJBQ0pVWlNXQ0E4V1M2eEpBRVVLeTJ3T0N5d0x5dUtJQ0E4c0FRalFvbzRJeUF1UnJBQ0pVWlNXQ0E4V1M2eEpBRVVLN0FFUXk2d0pDc3RzRGtzc0FBV3NBUWxzQVFtSUM1SEkwY2pZYkFHUlNzaklEd2dMaU00c1NRQkZDc3RzRG9zc1FrRUpVS3dBQmF3QkNXd0JDVWdMa2NqUnlOaElMQUVJMEt3QmtVcklMQmdVRmdnc0VCUldMTUNJQU1nRzdNQ0pnTWFXVUpDSXlCSHNBUkRzSUJpWUNDd0FDc2dpb3BoSUxBQ1EyQmtJN0FEUTJGa1VGaXdBa05oRzdBRFEyQlpzQU1sc0lCaVliQUNKVVpoT0NNZ1BDTTRHeUVnSUVZalI3QUFLeU5oT0NGWnNTUUJGQ3N0c0Rzc3NDNHJMckVrQVJRckxiQThMTEF2S3lFaklDQThzQVFqUWlNNHNTUUJGQ3V3QkVNdXNDUXJMYkE5TExBQUZTQkhzQUFqUXJJQUFRRVZGQk11c0NvcUxiQStMTEFBRlNCSHNBQWpRcklBQVFFVkZCTXVzQ29xTGJBL0xMRUFBUlFUc0NzcUxiQkFMTEF0S2kyd1FTeXdBQlpGSXlBdUlFYUtJMkU0c1NRQkZDc3RzRUlzc0FralFyQkJLeTJ3UXl5eUFBQTZLeTJ3UkN5eUFBRTZLeTJ3UlN5eUFRQTZLeTJ3Uml5eUFRRTZLeTJ3Unl5eUFBQTdLeTJ3U0N5eUFBRTdLeTJ3U1N5eUFRQTdLeTJ3U2l5eUFRRTdLeTJ3U3l5eUFBQTNLeTJ3VEN5eUFBRTNLeTJ3VFN5eUFRQTNLeTJ3VGl5eUFRRTNLeTJ3VHl5eUFBQTVLeTJ3VUN5eUFBRTVLeTJ3VVN5eUFRQTVLeTJ3VWl5eUFRRTVLeTJ3VXl5eUFBQThLeTJ3VkN5eUFBRThLeTJ3VlN5eUFRQThLeTJ3Vml5eUFRRThLeTJ3Vnl5eUFBQTRLeTJ3V0N5eUFBRTRLeTJ3V1N5eUFRQTRLeTJ3V2l5eUFRRTRLeTJ3V3l5d01Dc3VzU1FCRkNzdHNGd3NzREFyc0RRckxiQmRMTEF3SzdBMUt5MndYaXl3QUJhd01DdXdOaXN0c0Y4c3NERXJMckVrQVJRckxiQmdMTEF4SzdBMEt5MndZU3l3TVN1d05Tc3RzR0lzc0RFcnNEWXJMYkJqTExBeUt5NnhKQUVVS3kyd1pDeXdNaXV3TkNzdHNHVXNzRElyc0RVckxiQm1MTEF5SzdBMkt5MndaeXl3TXlzdXNTUUJGQ3N0c0dnc3NETXJzRFFyTGJCcExMQXpLN0ExS3kyd2FpeXdNeXV3TmlzdHNHc3NLN0FJWmJBREpGQjRzQUVWTUMwQUFFdTRBTWhTV0xFQkFZNVp1UWdBQ0FCaklMQUJJMFFnc0FNamNMQU9SU0FnUzdnQURsRkxzQVpUV2xpd05CdXdLRmxnWmlDS1ZWaXdBaVZoc0FGRll5TmlzQUlqUkxNS0NRVUVLN01LQ3dVRUs3TU9Ed1VFSzFteUJDZ0pSVkpFc3dvTkJnUXJzUVlCUkxFa0FZaFJXTEJBaUZpeEJnTkVzU1lCaUZGWXVBUUFpRml4QmdGRVdWbFpXYmdCLzRXd0JJMnhCUUJFQUFBQVwifSxmdW5jdGlvbihBLHMsZSl7dmFyIHQ9ZSg1KTtcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9W1tBLmksdCxcIlwiXV0pO3ZhciByPXt9O3IudHJhbnNmb3JtPXZvaWQgMDtlKDgpKHQscik7dC5sb2NhbHMmJihBLmV4cG9ydHM9dC5sb2NhbHMpfSxmdW5jdGlvbihBLHMsZSl7dmFyIHQ9ZSgxMikoZSgzKSxlKDEzKSxudWxsLG51bGwsbnVsbCk7dC5vcHRpb25zLl9fZmlsZT1cIi9Vc2Vycy9ndXNhaWZlaS9Xb3Jrc3BhY2Uvd29ya3NwYWNlLXBlcnNvbmFsL3Byb2dyZXNzL3NyYy9jb21wb25lbnRzL3Byb2dyZXNzLnZ1ZVwiLHQuZXNNb2R1bGUmJk9iamVjdC5rZXlzKHQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24oQSl7cmV0dXJuXCJkZWZhdWx0XCIhPT1BJiZcIl9fXCIhPT1BLnN1YnN0cigwLDIpfSkmJmNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKSx0Lm9wdGlvbnMuZnVuY3Rpb25hbCYmY29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwcm9ncmVzcy52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpLEEuZXhwb3J0cz10LmV4cG9ydHN9LGZ1bmN0aW9uKEEscyxlKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxzLmRlZmF1bHQ9e25hbWU6XCJWbVByb2dyZXNzXCIsY29tcG9uZW50TmFtZTpcIlZtUHJvZ3Jlc3NcIixwcm9wczp7dHlwZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImxpbmVcIix2YWxpZGF0b3I6ZnVuY3Rpb24oQSl7cmV0dXJuW1wibGluZVwiLFwiY2lyY2xlXCJdLmluZGV4T2YoQSk+LTF9fSxwZXJjZW50YWdlOnt0eXBlOltOdW1iZXIsU3RyaW5nXSxkZWZhdWx0OjAscmVxdWlyZWQ6ITAsdmFsaWRhdG9yOmZ1bmN0aW9uKEEpe3JldHVybiBBPj0wJiZBPD0xMDB9fSxzdHJva2VXaWR0aDp7dHlwZTpbTnVtYmVyLFN0cmluZ10sZGVmYXVsdDo2fSxzdHJva2VMaW5lY2FwOnt0eXBlOlN0cmluZyxkZWZhdWx0Olwicm91bmRcIix2YWxpZGF0b3I6ZnVuY3Rpb24oQSl7cmV0dXJuW1wiYnV0dFwiLFwic3F1YXJlXCIsXCJyb3VuZFwiXS5pbmRleE9mKEEpPi0xfX0sc3Ryb2tlQ29sb3I6e3R5cGU6U3RyaW5nfSx0cmFja0NvbG9yOnt0eXBlOlN0cmluZyxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuXCJsaW5lXCI9PT10aGlzLnR5cGU/XCIjZTRlOGYxXCI6XCIjZTVlOWYyXCJ9fSx0ZXh0SW5zaWRlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sc2hvd1RleHQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSxzdGF0dXM6e3R5cGU6U3RyaW5nLHZhbGlkYXRvcjpmdW5jdGlvbihBKXtyZXR1cm5bXCJzdWNjZXNzXCIsXCJleGNlcHRpb25cIixcIndhcm5pbmdcIixcImluZm9cIl0uaW5kZXhPZihBKT4tMX19LHdpZHRoOnt0eXBlOk51bWJlcixkZWZhdWx0OjEyNn0scmV2ZXJzZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHN0cmlwZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxsaW5lYXJDbGFzc05hbWU6U3RyaW5nfSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3N0OnRoaXMuc3RhdHVzfX0sd2F0Y2g6e3BlcmNlbnRhZ2U6ZnVuY3Rpb24oQSl7dGhpcy4kc2xvdHMuZGVmYXVsdHx8KHRoaXMuc3Q9MTAwPT09QT9cInN1Y2Nlc3NcIjp0aGlzLnN0YXR1cyl9LHN0YXR1czpmdW5jdGlvbihBKXt0aGlzLnN0PUF9fSxjb21wdXRlZDp7YmFyU3R5bGU6ZnVuY3Rpb24oKXt2YXIgQT17fTtyZXR1cm4gQS53aWR0aD10aGlzLnBlcmNlbnRhZ2UrXCIlXCIsdGhpcy5zdHJva2VDb2xvciYmKEEuYmFja2dyb3VuZENvbG9yPXRoaXMuc3Ryb2tlQ29sb3IpLEF9LHJlbGF0aXZlU3Ryb2tlV2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5zdHJva2VXaWR0aC90aGlzLndpZHRoKjEwMCkudG9GaXhlZCgxKX0sdHJhY2tQYXRoOmZ1bmN0aW9uKCl7dmFyIEE9cGFyc2VJbnQoNTAtcGFyc2VGbG9hdCh0aGlzLnJlbGF0aXZlU3Ryb2tlV2lkdGgpLzIsMTApLHM9dGhpcy5yZXZlcnNlPzA6MTtyZXR1cm5cIk0gNTAgNTAgbSAwIC1cIitBK1wiIGEgXCIrQStcIiBcIitBK1wiIDAgMSBcIitzK1wiIDAgXCIrMipBK1wiIGEgXCIrQStcIiBcIitBK1wiIDAgMSBcIitzK1wiIDAgLVwiKzIqQX0scGVyaW1ldGVyOmZ1bmN0aW9uKCl7dmFyIEE9NTAtcGFyc2VGbG9hdCh0aGlzLnJlbGF0aXZlU3Ryb2tlV2lkdGgpLzI7cmV0dXJuIDIqTWF0aC5QSSpBfSxjaXJjbGVQYXRoU3R5bGU6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLnBlcmltZXRlcjtyZXR1cm57c3Ryb2tlRGFzaGFycmF5OkErXCJweCxcIitBK1wicHhcIixzdHJva2VEYXNob2Zmc2V0OigxLXRoaXMucGVyY2VudGFnZS8xMDApKkErXCJweFwiLHRyYW5zaXRpb246XCJzdHJva2UtZGFzaG9mZnNldCAwLjZzIGVhc2UgMHMsIHN0cm9rZSAwLjZzIGVhc2VcIn19LHN0cm9rZTpmdW5jdGlvbigpe3ZhciBBPXZvaWQgMDtzd2l0Y2godGhpcy5zdCl7Y2FzZVwic3VjY2Vzc1wiOkE9XCIjMTNjZTY2XCI7YnJlYWs7Y2FzZVwid2FybmluZ1wiOkE9XCIjZjdiYTJhXCI7YnJlYWs7Y2FzZVwiaW5mb1wiOkE9XCIjNTBiZmZmXCI7YnJlYWs7Y2FzZVwiZXhjZXB0aW9uXCI6QT1cIiNmZjQ5NDlcIjticmVhaztkZWZhdWx0OkE9dGhpcy5zdHJva2VDb2xvcj90aGlzLnN0cm9rZUNvbG9yOlwiIzIwYTBmZlwifXJldHVybiBBfSxpY29uQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm5cInZtLXByb2dyZXNzLWljb25cIisoXCJsaW5lXCI9PT10aGlzLnR5cGU/XCItY2lyY2xlXCI6XCJcIikrXCItLVwiKyhcImV4Y2VwdGlvblwiPT09dGhpcy5zdD9cImVycm9yXCI6dGhpcy5zdCl9LHByb2dyZXNzVGV4dFNpemU6ZnVuY3Rpb24oKXtyZXR1cm5cImxpbmVcIj09PXRoaXMudHlwZT8xMisuNCp0aGlzLnN0cm9rZVdpZHRoOi4xMTExMTEqdGhpcy53aWR0aCsyfX19fSxmdW5jdGlvbihBLHMsZSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHQ9ZSgyKSxyPWUubih0KSxuPWUoMSksaT0oZS5uKG4pLGZ1bmN0aW9uIEEocyl7YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtBLmluc3RhbGxlZHx8cy5jb21wb25lbnQoXCJWbVByb2dyZXNzXCIsci5hKX0pO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5WdWUmJlZ1ZS5jb21wb25lbnQoXCJWbVByb2dyZXNzXCIsci5hKSxyLmEuaW5zdGFsbD1pLHMuZGVmYXVsdD1yLmF9LGZ1bmN0aW9uKEEscyxlKXtzPUEuZXhwb3J0cz1lKDYpKHZvaWQgMCkscy5wdXNoKFtBLmksJ0Bmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFwiaWNvbmZvbnRcIjtcXG4gIHNyYzogdXJsKCcrZSgwKStcIik7XFxuICAvKiBJRTkqL1xcbiAgc3JjOiB1cmwoXCIrZSgwKStcIiNpZWZpeCkgZm9ybWF0KCdlbWJlZGRlZC1vcGVudHlwZScpLCAgdXJsKFwiK2UoMTEpK1wiKSBmb3JtYXQoJ3dvZmYnKSwgIHVybChcIitlKDEwKStcIikgZm9ybWF0KCd0cnVldHlwZScpLCAgdXJsKFwiK2UoNykrJyNpY29uZm9udCkgZm9ybWF0KFxcJ3N2Z1xcJyk7XFxuICAvKiBpT1MgNC4xLSAqL1xcbn1cXG5bY2xhc3NePVwidm0tcHJvZ3Jlc3MtaWNvblwiXSxcXG5bY2xhc3MqPVwiIHZtLXByb2dyZXNzLWljb25cIl0ge1xcbiAgZm9udC1mYW1pbHk6IFwiaWNvbmZvbnRcIiAhaW1wb3J0YW50O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi1jaXJjbGUtLXN1Y2Nlc3Mge1xcbiAgY29sb3I6ICMxM2NlNjY7XFxufVxcbi52bS1wcm9ncmVzcy1pY29uLWNpcmNsZS0tc3VjY2VzczpiZWZvcmUge1xcbiAgY29udGVudDogXCJcXFxcRThFNFwiO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi0tc3VjY2VzcyB7XFxuICBjb2xvcjogIzEzY2U2NjtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tLXN1Y2Nlc3M6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFwiXFxcXEU4RTVcIjtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tY2lyY2xlLS1lcnJvciB7XFxuICBjb2xvcjogI2ZmNDk0OTtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tY2lyY2xlLS1lcnJvcjpiZWZvcmUge1xcbiAgY29udGVudDogXCJcXFxcRThFN1wiO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi0tZXJyb3Ige1xcbiAgY29sb3I6ICNmZjQ5NDk7XFxufVxcbi52bS1wcm9ncmVzcy1pY29uLS1lcnJvcjpiZWZvcmUge1xcbiAgY29udGVudDogXCJcXFxcRThFOFwiO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi1jaXJjbGUtLWluZm8ge1xcbiAgY29sb3I6ICM1MGJmZmY7XFxufVxcbi52bS1wcm9ncmVzcy1pY29uLWNpcmNsZS0taW5mbzpiZWZvcmUge1xcbiAgY29udGVudDogXCJcXFxcRThFQVwiO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi0taW5mbyB7XFxuICBjb2xvcjogIzUwYmZmZjtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tLWluZm86YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFwiXFxcXEU4RTlcIjtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tY2lyY2xlLS13YXJuaW5nIHtcXG4gIGNvbG9yOiAjZjdiYTJhO1xcbn1cXG4udm0tcHJvZ3Jlc3MtaWNvbi1jaXJjbGUtLXdhcm5pbmc6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFwiXFxcXEU4RUNcIjtcXG59XFxuLnZtLXByb2dyZXNzLWljb24tLXdhcm5pbmcge1xcbiAgY29sb3I6ICNmN2JhMmE7XFxufVxcbi52bS1wcm9ncmVzcy1pY29uLS13YXJuaW5nOmJlZm9yZSB7XFxuICBjb250ZW50OiBcIlxcXFxFOEVFXCI7XFxufVxcbi52bS1wcm9ncmVzcy1pY29uLS1jbG9zZTpiZWZvcmUge1xcbiAgY29udGVudDogXCJcXFxcRThFOFwiO1xcbn1cXG4udm0tcHJvZ3Jlc3Mge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxufVxcbi52bS1wcm9ncmVzc19fdGV4dCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBjb2xvcjogIzQ4NTc2YTtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG4udm0tcHJvZ3Jlc3MtLWNpcmNsZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi52bS1wcm9ncmVzcy0tY2lyY2xlIC52bS1wcm9ncmVzc19fdGV4dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbjogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xcbn1cXG4udm0tcHJvZ3Jlc3MtLWNpcmNsZSAudm0tcHJvZ3Jlc3NfX3RleHQgaSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAyMnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi52bS1wcm9ncmVzcy5pcy1zdWNjZXNzIC52bS1wcm9ncmVzcy1iYXJfX2lubmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxM2NlNjY7XFxufVxcbi52bS1wcm9ncmVzcy5pcy1zdWNjZXNzIC52bS1wcm9ncmVzc19fdGV4dCB7XFxuICBjb2xvcjogIzEzY2U2NjtcXG59XFxuLnZtLXByb2dyZXNzLmlzLWV4Y2VwdGlvbiAudm0tcHJvZ3Jlc3MtYmFyX19pbm5lciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY0OTQ5O1xcbn1cXG4udm0tcHJvZ3Jlc3MuaXMtZXhjZXB0aW9uIC52bS1wcm9ncmVzc19fdGV4dCB7XFxuICBjb2xvcjogI2ZmNDk0OTtcXG59XFxuLnZtLXByb2dyZXNzLmlzLXdhcm5pbmcgLnZtLXByb2dyZXNzLWJhcl9faW5uZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3YmEyYTtcXG59XFxuLnZtLXByb2dyZXNzLmlzLXdhcm5pbmcgLnZtLXByb2dyZXNzX190ZXh0IHtcXG4gIGNvbG9yOiAjZjdiYTJhO1xcbn1cXG4udm0tcHJvZ3Jlc3MuaXMtaW5mbyAudm0tcHJvZ3Jlc3MtYmFyX19pbm5lciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTBiZmZmO1xcbn1cXG4udm0tcHJvZ3Jlc3MuaXMtaW5mbyAudm0tcHJvZ3Jlc3NfX3RleHQge1xcbiAgY29sb3I6ICM1MGJmZmY7XFxufVxcbi52bS1wcm9ncmVzcy0td2l0aG91dC10ZXh0IC52bS1wcm9ncmVzc19fdGV4dCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4udm0tcHJvZ3Jlc3MtLXdpdGhvdXQtdGV4dCAudm0tcHJvZ3Jlc3MtYmFyIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnZtLXByb2dyZXNzLS10ZXh0LWluc2lkZSAudm0tcHJvZ3Jlc3MtYmFyIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbi52bS1wcm9ncmVzcy1iYXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1yaWdodDogNTBweDtcXG4gIG1hcmdpbi1yaWdodDogLTU1cHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4udm0tcHJvZ3Jlc3MtYmFyX19vdXRlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDZweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNGU4ZjE7XFxuICBib3JkZXItcmFkaXVzOiAxMDBweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4udm0tcHJvZ3Jlc3MtYmFyX19pbm5lciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMGEwZmY7XFxuICBib3JkZXItcmFkaXVzOiAxMDBweDtcXG59XFxuLnZtLXByb2dyZXNzLWJhcl9faW5uZXJUZXh0IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMCA1cHg7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4udm0tcHJvZ3Jlc3MtYmFyX19zdHJpcGVkIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCg0NWRlZywgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KSAyNSUsIHRyYW5zcGFyZW50IDI1JSwgdHJhbnNwYXJlbnQgNTAlLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpIDUwJSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KSA3NSUsIHRyYW5zcGFyZW50IDc1JSwgdHJhbnNwYXJlbnQpO1xcbiAgYmFja2dyb3VuZC1zaXplOiA0MHB4IDQwcHg7XFxuICBhbmltYXRpb246IHByb2dyZXNzLWJhci1zdHJpcGVzIDJzIGxpbmVhciBpbmZpbml0ZTtcXG59XFxuQGtleWZyYW1lcyBwcm9ncmVzcy1iYXItc3RyaXBlcyB7XFxuICBmcm9tIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogNDBweCAwO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIDA7XFxuICB9XFxufVxcbicsXCJcIl0pfSxmdW5jdGlvbihBLHMpe2Z1bmN0aW9uIGUoQSxzKXt2YXIgZT1BWzFdfHxcIlwiLHI9QVszXTtpZighcilyZXR1cm4gZTtpZihzJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBidG9hKXt2YXIgbj10KHIpO3JldHVybltlXS5jb25jYXQoci5zb3VyY2VzLm1hcChmdW5jdGlvbihBKXtyZXR1cm5cIi8qIyBzb3VyY2VVUkw9XCIrci5zb3VyY2VSb290K0ErXCIgKi9cIn0pKS5jb25jYXQoW25dKS5qb2luKFwiXFxuXCIpfXJldHVybltlXS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHQoQSl7cmV0dXJuXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoQSkpKSkrXCIgKi9cIn1BLmV4cG9ydHM9ZnVuY3Rpb24oQSl7dmFyIHM9W107cmV0dXJuIHMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocyl7dmFyIHQ9ZShzLEEpO3JldHVybiBzWzJdP1wiQG1lZGlhIFwiK3NbMl0rXCJ7XCIrdCtcIn1cIjp0fSkuam9pbihcIlwiKX0scy5pPWZ1bmN0aW9uKEEsZSl7XCJzdHJpbmdcIj09dHlwZW9mIEEmJihBPVtbbnVsbCxBLFwiXCJdXSk7Zm9yKHZhciB0PXt9LHI9MDtyPHRoaXMubGVuZ3RoO3IrKyl7dmFyIG49dGhpc1tyXVswXTtcIm51bWJlclwiPT10eXBlb2YgbiYmKHRbbl09ITApfWZvcihyPTA7cjxBLmxlbmd0aDtyKyspe3ZhciBpPUFbcl07XCJudW1iZXJcIj09dHlwZW9mIGlbMF0mJnRbaVswXV18fChlJiYhaVsyXT9pWzJdPWU6ZSYmKGlbMl09XCIoXCIraVsyXStcIikgYW5kIChcIitlK1wiKVwiKSxzLnB1c2goaSkpfX0sc319LGZ1bmN0aW9uKEEscyxlKXtBLmV4cG9ydHM9ZS5wK1wiaWNvbmZvbnQuc3ZnPzI0N2EzNDJjYjAyMDU3YTE2OTQwZmNkMzE4ZTJiOTFjXCJ9LGZ1bmN0aW9uKEEscyxlKXtmdW5jdGlvbiB0KEEscyl7Zm9yKHZhciBlPTA7ZTxBLmxlbmd0aDtlKyspe3ZhciB0PUFbZV0scj1hW3QuaWRdO2lmKHIpe3IucmVmcysrO2Zvcih2YXIgbj0wO248ci5wYXJ0cy5sZW5ndGg7bisrKXIucGFydHNbbl0odC5wYXJ0c1tuXSk7Zm9yKDtuPHQucGFydHMubGVuZ3RoO24rKylyLnBhcnRzLnB1c2goQyh0LnBhcnRzW25dLHMpKX1lbHNle2Zvcih2YXIgaT1bXSxuPTA7bjx0LnBhcnRzLmxlbmd0aDtuKyspaS5wdXNoKEModC5wYXJ0c1tuXSxzKSk7YVt0LmlkXT17aWQ6dC5pZCxyZWZzOjEscGFydHM6aX19fX1mdW5jdGlvbiByKEEscyl7Zm9yKHZhciBlPVtdLHQ9e30scj0wO3I8QS5sZW5ndGg7cisrKXt2YXIgbj1BW3JdLGk9cy5iYXNlP25bMF0rcy5iYXNlOm5bMF0sbz1uWzFdLEI9blsyXSxnPW5bM10sQz17Y3NzOm8sbWVkaWE6Qixzb3VyY2VNYXA6Z307dFtpXT90W2ldLnBhcnRzLnB1c2goQyk6ZS5wdXNoKHRbaV09e2lkOmkscGFydHM6W0NdfSl9cmV0dXJuIGV9ZnVuY3Rpb24gbihBLHMpe3ZhciBlPXkoQS5pbnNlcnRJbnRvKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTt2YXIgdD11W3UubGVuZ3RoLTFdO2lmKFwidG9wXCI9PT1BLmluc2VydEF0KXQ/dC5uZXh0U2libGluZz9lLmluc2VydEJlZm9yZShzLHQubmV4dFNpYmxpbmcpOmUuYXBwZW5kQ2hpbGQocyk6ZS5pbnNlcnRCZWZvcmUocyxlLmZpcnN0Q2hpbGQpLHUucHVzaChzKTtlbHNle2lmKFwiYm90dG9tXCIhPT1BLmluc2VydEF0KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtlLmFwcGVuZENoaWxkKHMpfX1mdW5jdGlvbiBpKEEpe2lmKG51bGw9PT1BLnBhcmVudE5vZGUpcmV0dXJuITE7QS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEEpO3ZhciBzPXUuaW5kZXhPZihBKTtzPj0wJiZ1LnNwbGljZShzLDEpfWZ1bmN0aW9uIG8oQSl7dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO3JldHVybiBBLmF0dHJzLnR5cGU9XCJ0ZXh0L2Nzc1wiLGcocyxBLmF0dHJzKSxuKEEscyksc31mdW5jdGlvbiBCKEEpe3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO3JldHVybiBBLmF0dHJzLnR5cGU9XCJ0ZXh0L2Nzc1wiLEEuYXR0cnMucmVsPVwic3R5bGVzaGVldFwiLGcocyxBLmF0dHJzKSxuKEEscyksc31mdW5jdGlvbiBnKEEscyl7T2JqZWN0LmtleXMocykuZm9yRWFjaChmdW5jdGlvbihlKXtBLnNldEF0dHJpYnV0ZShlLHNbZV0pfSl9ZnVuY3Rpb24gQyhBLHMpe3ZhciBlLHQscixuO2lmKHMudHJhbnNmb3JtJiZBLmNzcyl7aWYoIShuPXMudHJhbnNmb3JtKEEuY3NzKSkpcmV0dXJuIGZ1bmN0aW9uKCl7fTtBLmNzcz1ufWlmKHMuc2luZ2xldG9uKXt2YXIgZz1sKys7ZT1JfHwoST1vKHMpKSx0PVEuYmluZChudWxsLGUsZywhMSkscj1RLmJpbmQobnVsbCxlLGcsITApfWVsc2UgQS5zb3VyY2VNYXAmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgQmxvYiYmXCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYT8oZT1CKHMpLHQ9Yy5iaW5kKG51bGwsZSxzKSxyPWZ1bmN0aW9uKCl7aShlKSxlLmhyZWYmJlVSTC5yZXZva2VPYmplY3RVUkwoZS5ocmVmKX0pOihlPW8ocyksdD13LmJpbmQobnVsbCxlKSxyPWZ1bmN0aW9uKCl7aShlKX0pO3JldHVybiB0KEEpLGZ1bmN0aW9uKHMpe2lmKHMpe2lmKHMuY3NzPT09QS5jc3MmJnMubWVkaWE9PT1BLm1lZGlhJiZzLnNvdXJjZU1hcD09PUEuc291cmNlTWFwKXJldHVybjt0KEE9cyl9ZWxzZSByKCl9fWZ1bmN0aW9uIFEoQSxzLGUsdCl7dmFyIHI9ZT9cIlwiOnQuY3NzO2lmKEEuc3R5bGVTaGVldClBLnN0eWxlU2hlZXQuY3NzVGV4dD1MKHMscik7ZWxzZXt2YXIgbj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyKSxpPUEuY2hpbGROb2RlcztpW3NdJiZBLnJlbW92ZUNoaWxkKGlbc10pLGkubGVuZ3RoP0EuaW5zZXJ0QmVmb3JlKG4saVtzXSk6QS5hcHBlbmRDaGlsZChuKX19ZnVuY3Rpb24gdyhBLHMpe3ZhciBlPXMuY3NzLHQ9cy5tZWRpYTtpZih0JiZBLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsdCksQS5zdHlsZVNoZWV0KUEuc3R5bGVTaGVldC5jc3NUZXh0PWU7ZWxzZXtmb3IoO0EuZmlyc3RDaGlsZDspQS5yZW1vdmVDaGlsZChBLmZpcnN0Q2hpbGQpO0EuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZSkpfX1mdW5jdGlvbiBjKEEscyxlKXt2YXIgdD1lLmNzcyxyPWUuc291cmNlTWFwLG49dm9pZCAwPT09cy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMmJnI7KHMuY29udmVydFRvQWJzb2x1dGVVcmxzfHxuKSYmKHQ9cCh0KSksciYmKHQrPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShyKSkpKStcIiAqL1wiKTt2YXIgaT1uZXcgQmxvYihbdF0se3R5cGU6XCJ0ZXh0L2Nzc1wifSksbz1BLmhyZWY7QS5ocmVmPVVSTC5jcmVhdGVPYmplY3RVUkwoaSksbyYmVVJMLnJldm9rZU9iamVjdFVSTChvKX12YXIgYT17fSxFPWZ1bmN0aW9uKEEpe3ZhciBzO3JldHVybiBmdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT1zJiYocz1BLmFwcGx5KHRoaXMsYXJndW1lbnRzKSksc319KGZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdyYmZG9jdW1lbnQmJmRvY3VtZW50LmFsbCYmIXdpbmRvdy5hdG9ifSkseT1mdW5jdGlvbihBKXt2YXIgcz17fTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PXNbZV0mJihzW2VdPUEuY2FsbCh0aGlzLGUpKSxzW2VdfX0oZnVuY3Rpb24oQSl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoQSl9KSxJPW51bGwsbD0wLHU9W10scD1lKDkpO0EuZXhwb3J0cz1mdW5jdGlvbihBLHMpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBERUJVRyYmREVCVUcmJlwib2JqZWN0XCIhPXR5cGVvZiBkb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7cz1zfHx7fSxzLmF0dHJzPVwib2JqZWN0XCI9PXR5cGVvZiBzLmF0dHJzP3MuYXR0cnM6e30scy5zaW5nbGV0b258fChzLnNpbmdsZXRvbj1FKCkpLHMuaW5zZXJ0SW50b3x8KHMuaW5zZXJ0SW50bz1cImhlYWRcIikscy5pbnNlcnRBdHx8KHMuaW5zZXJ0QXQ9XCJib3R0b21cIik7dmFyIGU9cihBLHMpO3JldHVybiB0KGUscyksZnVuY3Rpb24oQSl7Zm9yKHZhciBuPVtdLGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG89ZVtpXSxCPWFbby5pZF07Qi5yZWZzLS0sbi5wdXNoKEIpfWlmKEEpe3QocihBLHMpLHMpfWZvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgQj1uW2ldO2lmKDA9PT1CLnJlZnMpe2Zvcih2YXIgZz0wO2c8Qi5wYXJ0cy5sZW5ndGg7ZysrKUIucGFydHNbZ10oKTtkZWxldGUgYVtCLmlkXX19fX07dmFyIEw9ZnVuY3Rpb24oKXt2YXIgQT1bXTtyZXR1cm4gZnVuY3Rpb24ocyxlKXtyZXR1cm4gQVtzXT1lLEEuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIil9fSgpfSxmdW5jdGlvbihBLHMpe0EuZXhwb3J0cz1mdW5jdGlvbihBKXt2YXIgcz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb247aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7aWYoIUF8fFwic3RyaW5nXCIhPXR5cGVvZiBBKXJldHVybiBBO3ZhciBlPXMucHJvdG9jb2wrXCIvL1wiK3MuaG9zdCx0PWUrcy5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sXCIvXCIpO3JldHVybiBBLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLGZ1bmN0aW9uKEEscyl7dmFyIHI9cy50cmltKCkucmVwbGFjZSgvXlwiKC4qKVwiJC8sZnVuY3Rpb24oQSxzKXtyZXR1cm4gc30pLnJlcGxhY2UoL14nKC4qKSckLyxmdW5jdGlvbihBLHMpe3JldHVybiBzfSk7aWYoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdChyKSlyZXR1cm4gQTt2YXIgbjtyZXR1cm4gbj0wPT09ci5pbmRleE9mKFwiLy9cIik/cjowPT09ci5pbmRleE9mKFwiL1wiKT9lK3I6dCtyLnJlcGxhY2UoL15cXC5cXC8vLFwiXCIpLFwidXJsKFwiK0pTT04uc3RyaW5naWZ5KG4pK1wiKVwifSl9fSxmdW5jdGlvbihBLHMpe0EuZXhwb3J0cz1cImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtiYXNlNjQsQUFFQUFBQVFBUUFBQkFBQVJrWlVUWGQreC9ZQUFBRU1BQUFBSEVkRVJVWUFPUUFHQUFBQktBQUFBQ0JQVXk4eVZ4UmJ2Z0FBQVVnQUFBQldZMjFoY05MNDJHd0FBQUdnQUFBQmFtTjJkQ0FNNWY5MEFBQU0xQUFBQUNSbWNHZHRNUGVlbFFBQURQZ0FBQW1XWjJGemNBQUFBQkFBQUF6TUFBQUFDR2RzZVdheEx1VkdBQUFEREFBQUJoQm9aV0ZrRGt4cEl3QUFDUndBQUFBMmFHaGxZUWRlQThZQUFBbFVBQUFBSkdodGRIZ1E1UUpzQUFBSmVBQUFBQ0pzYjJOaENqWUlIZ0FBQ1p3QUFBQWFiV0Y0Y0FFdUNpc0FBQW00QUFBQUlHNWhiV1VVTGM0VkFBQUoyQUFBQWl0d2IzTjB2aVEvMVFBQURBUUFBQURJY0hKbGNLVzV2bVlBQUJhUUFBQUFsUUFBQUFFQUFBQUF6RDJpendBQUFBRFZvSktUQUFBQUFOV2drcE1BQVFBQUFBNEFBQUFZQUFBQUFBQUNBQUVBQXdBTEFBRUFCQUFBQUFJQUFBQUJBLzBCOUFBRkFBZ0NtUUxNQUFBQWp3S1pBc3dBQUFIckFETUJDUUFBQWdBR0F3QUFBQUFBQUFBQUFBRVFBQUFBQUFBQUFBQUFBQUJRWmtWa0FFQUFlT2p1QTREL2dBQmNBMEFBUUFBQUFBRUFBQUFBQUFBQUFBQURBQUFBQXdBQUFCd0FBUUFBQUFBQVpBQURBQUVBQUFBY0FBUUFTQUFBQUE0QUNBQUNBQVlBQUFCNDZPWG82dWpzNk83Ly93QUFBQUFBZU9qazZPZm83T2p1Ly84QUFQK0xGeUFYSHhjZUZ4MEFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFCQWdBQUFBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBTFAvaEE3d0RHQUFXQURBQU9nQlNBRjRCZDB1d0UxQllRRW9DQVFBTkRnMEFEbVlBQXc0QkRnTmVBQUVJQ0FGY0VBRUpDQW9HQ1Y0UkFRd0dCQVlNWGdBTEJBdHBEd0VJQUFZTUNBWllBQW9IQlFJRUN3b0VXUklCRGc0TlVRQU5EUW9PUWh0THNCZFFXRUJMQWdFQURRNE5BQTVtQUFNT0FRNERYZ0FCQ0FnQlhCQUJDUWdLQ0FrS1poRUJEQVlFQmd4ZUFBc0VDMmtQQVFnQUJnd0lCbGdBQ2djRkFnUUxDZ1JaRWdFT0RnMVJBQTBOQ2c1Q0cwdXdHRkJZUUV3Q0FRQU5EZzBBRG1ZQUF3NEJEZ05lQUFFSUNBRmNFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNHMEJPQWdFQURRNE5BQTVtQUFNT0FRNERBV1lBQVFnT0FRaGtFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNXVmxaUUNoVFV6czdNakVYRjFOZVUxNWJXRHRTTzFKTFF6YzFNVG95T2hjd0Z6QlJFVEVZRVNnVlFCTVdLd0VHS3dFaURnSWRBU0UxTkNZMU5DNENLd0VWSVFVVkZCWVVEZ0lqQmlZckFTY2hCeXNCSWljaUxnSTlBUmNpQmhRV016STJOQ1lYQmdjT0F4NEJPd1l5TmljdUFTY21Kd0UxTkQ0Q093RXlGaDBCQVJrYkdsTVNKUndTQTVBQkNoZ25Ib1grU2dLaUFSVWZJdzRPSHc0Z0xmNUpMQjBpRkJrWklCTUlkd3dTRWd3TkVoS01DQVlGQ3dRQ0JBOE9KVU5SVUVBa0Z4WUpCUWtGQlFiK3BBVVBHaFc4SHlrQ0h3RU1HU2NhVENrUUhBUU5JQnNTWVlnMEZ6bzZKUmNKQVFHQWdBRVRHeUFPcHo4UkdoRVJHaEY4R2hZVEpBNFFEUWdZR2cwakVSTVVBWGZrQ3hnVERCMG00d0FBQWdCQS84QUR3QU5BQUFjQUR3QWlRQjhQRGcwTUN3a0dBUUFCUUFBQUFRRUFUUUFBQUFGUkFBRUFBVVVURUFJUUt3QWdBQkFBSUFBUUFRY3ZBVGNYQVJjQ3VmNk8vdmtCQndGeUFRZjk3QzR0ZEMxMUFXOHVBMEQrK2Y2Ty92a0JCd0Z5L25rdUxuVXVkUUZ2TFFBQUFBSUFyZ0IvQTAwQ2VnQURBQWNBQ0xVR0JBSUFBaVlyRXhjSEp3RVhBU2ZjMGkzU0FuRXQvak10QVgvU0xkSUJLQzcrTkMwQUFBQUFBZ0JBLzhBRHdBTkFBQWNBRXdBb1FDVVRFaEVRRHc0TkRBc0tDUWdNQVFBQlFBQUFBUUVBVFFBQUFBRlJBQUVBQVVVVEVBSVFLd0FnQUJBQUlBQVFBd2NuQnljM0p6Y1hOeGNIQXJuK2p2NzVBUWNCY2dFSDBpM0J3aTNDd1MzQndpM0JBMEQrK2Y2Ty92a0JCd0Z5L29VdHdjQXR3Y0l0d3NFdHdRQUFBQUFCQU5rQVdRTW5BcWNBQ3dBR3N3Y0JBU1lyQVNjSEp3Y1hCeGMzRnpjbkF5WXQrZmt0K2ZrdCtma3QrQUo1TGZuNUxmbjVMZmo0TGZrQUFBQUNBWUFBQUFLQUF3QUFBd0FPQUR0QU9Ba0lCd01EQWdGQUFBQUJBR2dBQVFJQmFBQUNBd0pvQmdVQ0F3UUVBMHNHQlFJREF3UlFBQVFEQkVRRUJBUU9CQTRSRkJJUkVBY1RLd0V6RlNNVEVTTUhGemNSSXhVaE5RSGdRRUJBSVg4UlQyQUJBQU1BUVAyQUFrQWlQaGIrQ2tCQUFBTUFRUC9BQThBRFFBQUhBQXNBRmdBK1FEc1NFUkFEQlFZQlFBY0JCUVlFQmdVRVpnQUFBQUlEQUFKWEFBTUFCZ1VEQmxjQUJBRUJCRXNBQkFRQlVRQUJCQUZGRVJRUkVSRVRFeEFJRmlzQUlBQVFBQ0FBRUNVekZTTVRJVFV6TlFjbk56TVJNd0s1L283KytRRUhBWElCQi80Z1FFQ2cvd0JnVHhGL0lXQURRUDc1L283KytRRUhBWEpIUVA1QVFQWVdQaUwrd0FBQUF3QkEvOEFEd0FOQUFBY0FDd0FQQURGQUxnQUFBQVFGQUFSWEJnRUZBQU1DQlFOWEFBSUJBUUpMQUFJQ0FWRUFBUUlCUlF3TURBOE1EeElSRXhNUUJ4TXJBQ0FBRUFBZ0FCQUJJelV6SnhFekVRSzUvbzcrK1FFSEFYSUJCLzVnUUVCQVFBTkEvdm4ranY3NUFRY0JjdjVIUUVBQmdQNkFBQUFBQUFJQjRBQUFBaUFEQUFBREFBY0FpVXV3QzFCWVFCc0FBUUlBQWdGZUFBQUFad0FEQWdJRFN3QURBd0pQQUFJREFrTWJTN0FVVUZoQUZnQUJBZ0FDQVY0QUFBQm5BQUlDQTA4QUF3TUtBa0liUzdBV1VGaEFGd0FCQWdBQ0FRQm1BQUFBWndBQ0FnTlBBQU1EQ2dKQ0cwQWNBQUVDQUFJQkFHWUFBQUJuQUFNQ0FnTkxBQU1EQWs4QUFnTUNRMWxaV2JVUkVSRVFCQklySVNNMU15Y3pFU01DSUVCQVFFQkFRRUFDZ0FBQkFBQUFBUUFBQUtvamNWOFBQUFVBQ3dRQUFBQUFBTldna3BNQUFBQUExYUNTa3dBcy84QUR3QU5BQUFBQUNBQUNBQUFBQUFBQUFBRUFBQU5BLzhBQVhBUUFBQUFBQUFQQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBRkJBQUFBQUFBQUFBQlZRQUFBK2tBTEFRQUFFQUFyZ0JBQU5rQmdBQkFBRUFCNEFBQUFBQUFBQUFBQUFBQlBBRjBBWkFCMEFIdUFpZ0NkQUt5QXdnQUFBQUJBQUFBREFCZkFBVUFBQUFBQUFJQUpnQTBBR3dBQUFDS0NaWUFBQUFBQUFBQURBQ1dBQUVBQUFBQUFBRUFDQUFBQUFFQUFBQUFBQUlBQmdBSUFBRUFBQUFBQUFNQUpBQU9BQUVBQUFBQUFBUUFDQUF5QUFFQUFBQUFBQVVBUlFBNkFBRUFBQUFBQUFZQUNBQi9BQU1BQVFRSkFBRUFFQUNIQUFNQUFRUUpBQUlBREFDWEFBTUFBUVFKQUFNQVNBQ2pBQU1BQVFRSkFBUUFFQURyQUFNQUFRUUpBQVVBaWdEN0FBTUFBUVFKQUFZQUVBR0ZhV052Ym1admJuUk5aV1JwZFcxR2IyNTBSbTl5WjJVZ01pNHdJRG9nYVdOdmJtWnZiblFnT2lBeU9DMDNMVEl3TVRkcFkyOXVabTl1ZEZabGNuTnBiMjRnTVM0d095QjBkR1poZFhSdmFHbHVkQ0FvZGpBdU9UUXBJQzFzSURnZ0xYSWdOVEFnTFVjZ01qQXdJQzE0SURFMElDMTNJQ0pISWlBdFppQXRjMmxqYjI1bWIyNTBBR2tBWXdCdkFHNEFaZ0J2QUc0QWRBQk5BR1VBWkFCcEFIVUFiUUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FHa0FZd0J2QUc0QVpnQnZBRzRBZEFBZ0FEb0FJQUF5QURnQUxRQTNBQzBBTWdBd0FERUFOd0JwQUdNQWJ3QnVBR1lBYndCdUFIUUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QURzQUlBQjBBSFFBWmdCaEFIVUFkQUJ2QUdnQWFRQnVBSFFBSUFBb0FIWUFNQUF1QURrQU5BQXBBQ0FBTFFCc0FDQUFPQUFnQUMwQWNnQWdBRFVBTUFBZ0FDMEFSd0FnQURJQU1BQXdBQ0FBTFFCNEFDQUFNUUEwQUNBQUxRQjNBQ0FBSWdCSEFDSUFJQUF0QUdZQUlBQXRBSE1BYVFCakFHOEFiZ0JtQUc4QWJnQjBBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FBQUFCQUFJQVd3RUNBUU1CQkFFRkFRWUJCd0VJQVFrYWVtaGxibWR4ZFdWM1lXNWphR1Z1WnkxNWRXRnVhM1ZoYm1jUWVtaGxibWR4ZFdWM1lXNWphR1Z1Wnh0amRXOTNkV2QxWVc1aWFYRjFlR2xoYnkxNWRXRnVhM1ZoYm1jUlkzVnZkM1ZuZFdGdVltbHhkWGhwWVc4RmVHbHVlR2tQZUdsdWVHa3RlWFZoYm10MVlXNW5FMmRoYm5SaGJtaGhieTE1ZFdGdWEzVmhibWNKWjJGdWRHRnVhR0Z2QUFFQUFmLy9BQThBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRElBTWdNWS8rRURRUC9BQXhqLzRRTkEvOEN3QUN5d0lHQm1MYkFCTENCa0lMREFVTEFFSmxxd0JFVmJXQ0VqSVJ1S1dDQ3dVRkJZSWJCQVdSc2dzRGhRV0NHd09GbFpJTEFLUldGa3NDaFFXQ0d3Q2tVZ3NEQlFXQ0d3TUZrYklMREFVRmdnWmlDS2ltRWdzQXBRV0dBYklMQWdVRmdoc0FwZ0d5Q3dObEJZSWJBMllCdGdXVmxaRzdBQUsxbFpJN0FBVUZobFdWa3RzQUlzSUVVZ3NBUWxZV1Fnc0FWRFVGaXdCU05Dc0FZalFoc2hJVm13QVdBdHNBTXNJeUVqSVNCa3NRVmlRaUN3QmlOQ3Nnb0FBaW9oSUxBR1F5Q0tJSXF3QUN1eE1BVWxpbEZZWUZBYllWSlpXQ05aSVNDd1FGTllzQUFyR3lHd1FGa2pzQUJRV0dWWkxiQUVMTEFJSTBLd0J5TkNzQUFqUXJBQVE3QUhRMUZZc0FoREs3SUFBUUJEWUVLd0ZtVWNXUzJ3QlN5d0FFTWdSU0N3QWtWanNBRkZZbUJFTGJBR0xMQUFReUJGSUxBQUt5T3hCQVFsWUNCRmlpTmhJR1Fnc0NCUVdDR3dBQnV3TUZCWXNDQWJzRUJaV1NPd0FGQllaVm13QXlVallVUkVMYkFITExFRkJVV3dBV0ZFTGJBSUxMQUJZQ0Fnc0FwRFNyQUFVRmdnc0FvalFsbXdDME5Lc0FCU1dDQ3dDeU5DV1Myd0NTd2d1QVFBWWlDNEJBQmppaU5oc0F4RFlDQ0tZQ0N3RENOQ0l5MndDaXhMVkZpeEJ3RkVXU1N3RFdVamVDMndDeXhMVVZoTFUxaXhCd0ZFV1JzaFdTU3dFMlVqZUMyd0RDeXhBQTFEVlZpeERRMURzQUZoUXJBSksxbXdBRU93QWlWQ3NnQUJBRU5nUXJFS0FpVkNzUXNDSlVLd0FSWWpJTEFESlZCWXNBQkRzQVFsUW9xS0lJb2pZYkFJS2lFanNBRmhJSW9qWWJBSUtpRWJzQUJEc0FJbFFyQUNKV0d3Q0NvaFdiQUtRMGV3QzBOSFlMQ0FZaUN3QWtWanNBRkZZbUN4QUFBVEkwU3dBVU93QUQ2eUFRRUJRMkJDTGJBTkxMRUFCVVZVV0FDd0RTTkNJR0N3QVdHMURnNEJBQXdBUWtLS1lMRU1CQ3V3YXlzYklsa3RzQTRzc1FBTkt5MndEeXl4QVEwckxiQVFMTEVDRFNzdHNCRXNzUU1OS3kyd0VpeXhCQTByTGJBVExMRUZEU3N0c0JRc3NRWU5LeTJ3RlN5eEJ3MHJMYkFXTExFSURTc3RzQmNzc1FrTkt5MndHQ3l3Qnl1eEFBVkZWRmdBc0EwalFpQmdzQUZodFE0T0FRQU1BRUpDaW1DeERBUXJzR3NyR3lKWkxiQVpMTEVBR0NzdHNCb3NzUUVZS3kyd0d5eXhBaGdyTGJBY0xMRURHQ3N0c0Iwc3NRUVlLeTJ3SGl5eEJSZ3JMYkFmTExFR0dDc3RzQ0Fzc1FjWUt5MndJU3l4Q0JnckxiQWlMTEVKR0NzdHNDTXNJR0N3RG1BZ1F5T3dBV0JEc0FJbHNBSWxVVmdqSUR5d0FXQWpzQkpsSEJzaElWa3RzQ1Fzc0NNcnNDTXFMYkFsTENBZ1J5QWdzQUpGWTdBQlJXSmdJMkU0SXlDS1ZWZ2dSeUFnc0FKRlk3QUJSV0pnSTJFNEd5RlpMYkFtTExFQUJVVlVXQUN3QVJhd0pTcXdBUlV3R3lKWkxiQW5MTEFISzdFQUJVVlVXQUN3QVJhd0pTcXdBUlV3R3lKWkxiQW9MQ0Exc0FGZ0xiQXBMQUN3QTBWanNBRkZZckFBSzdBQ1JXT3dBVVZpc0FBcnNBQVd0QUFBQUFBQVJENGpPTEVvQVJVcUxiQXFMQ0E4SUVjZ3NBSkZZN0FCUldKZ3NBQkRZVGd0c0Nzc0xoYzhMYkFzTENBOElFY2dzQUpGWTdBQlJXSmdzQUJEWWJBQlEyTTRMYkF0TExFQ0FCWWxJQzRnUjdBQUkwS3dBaVZKaW9wSEkwY2pZU0JZWWhzaFdiQUJJMEt5TEFFQkZSUXFMYkF1TExBQUZyQUVKYkFFSlVjalJ5TmhzQVpGSzJXS0xpTWdJRHlLT0Myd0x5eXdBQmF3QkNXd0JDVWdMa2NqUnlOaElMQUVJMEt3QmtVcklMQmdVRmdnc0VCUldMTUNJQU1nRzdNQ0pnTWFXVUpDSXlDd0NVTWdpaU5ISTBjallTTkdZTEFFUTdDQVltQWdzQUFySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQ0FZbUVqSUNDd0JDWWpSbUU0R3lPd0NVTkdzQUlsc0FsRFJ5TkhJMkZnSUxBRVE3Q0FZbUFqSUxBQUt5T3dCRU5nc0FBcnNBVWxZYkFGSmJDQVlyQUVKbUVnc0FRbFlHUWpzQU1sWUdSUVdDRWJJeUZaSXlBZ3NBUW1JMFpoT0ZrdHNEQXNzQUFXSUNBZ3NBVW1JQzVISTBjallTTThPQzJ3TVN5d0FCWWdzQWtqUWlBZ0lFWWpSN0FBS3lOaE9DMndNaXl3QUJhd0F5V3dBaVZISTBjalliQUFWRmd1SUR3aklSdXdBaVd3QWlWSEkwY2pZU0N3QlNXd0JDVkhJMGNqWWJBR0piQUZKVW13QWlWaHNBRkZZeU1nV0dJYklWbGpzQUZGWW1BakxpTWdJRHlLT0NNaFdTMndNeXl3QUJZZ3NBbERJQzVISTBjallTQmdzQ0JnWnJDQVlpTWdJRHlLT0Myd05Dd2pJQzVHc0FJbFJsSllJRHhaTHJFa0FSUXJMYkExTENNZ0xrYXdBaVZHVUZnZ1BGa3VzU1FCRkNzdHNEWXNJeUF1UnJBQ0pVWlNXQ0E4V1NNZ0xrYXdBaVZHVUZnZ1BGa3VzU1FCRkNzdHNEY3NzQzRySXlBdVJyQUNKVVpTV0NBOFdTNnhKQUVVS3kyd09DeXdMeXVLSUNBOHNBUWpRb280SXlBdVJyQUNKVVpTV0NBOFdTNnhKQUVVSzdBRVF5NndKQ3N0c0Rrc3NBQVdzQVFsc0FRbUlDNUhJMGNqWWJBR1JTc2pJRHdnTGlNNHNTUUJGQ3N0c0Rvc3NRa0VKVUt3QUJhd0JDV3dCQ1VnTGtjalJ5TmhJTEFFSTBLd0JrVXJJTEJnVUZnZ3NFQlJXTE1DSUFNZ0c3TUNKZ01hV1VKQ0l5QkhzQVJEc0lCaVlDQ3dBQ3NnaW9waElMQUNRMkJrSTdBRFEyRmtVRml3QWtOaEc3QURRMkJac0FNbHNJQmlZYkFDSlVaaE9DTWdQQ000R3lFZ0lFWWpSN0FBS3lOaE9DRlpzU1FCRkNzdHNEc3NzQzRyTHJFa0FSUXJMYkE4TExBdkt5RWpJQ0E4c0FRalFpTTRzU1FCRkN1d0JFTXVzQ1FyTGJBOUxMQUFGU0JIc0FBalFySUFBUUVWRkJNdXNDb3FMYkErTExBQUZTQkhzQUFqUXJJQUFRRVZGQk11c0NvcUxiQS9MTEVBQVJRVHNDc3FMYkJBTExBdEtpMndRU3l3QUJaRkl5QXVJRWFLSTJFNHNTUUJGQ3N0c0VJc3NBa2pRckJCS3kyd1F5eXlBQUE2S3kyd1JDeXlBQUU2S3kyd1JTeXlBUUE2S3kyd1JpeXlBUUU2S3kyd1J5eXlBQUE3S3kyd1NDeXlBQUU3S3kyd1NTeXlBUUE3S3kyd1NpeXlBUUU3S3kyd1N5eXlBQUEzS3kyd1RDeXlBQUUzS3kyd1RTeXlBUUEzS3kyd1RpeXlBUUUzS3kyd1R5eXlBQUE1S3kyd1VDeXlBQUU1S3kyd1VTeXlBUUE1S3kyd1VpeXlBUUU1S3kyd1V5eXlBQUE4S3kyd1ZDeXlBQUU4S3kyd1ZTeXlBUUE4S3kyd1ZpeXlBUUU4S3kyd1Z5eXlBQUE0S3kyd1dDeXlBQUU0S3kyd1dTeXlBUUE0S3kyd1dpeXlBUUU0S3kyd1d5eXdNQ3N1c1NRQkZDc3RzRndzc0RBcnNEUXJMYkJkTExBd0s3QTFLeTJ3WGl5d0FCYXdNQ3V3TmlzdHNGOHNzREVyTHJFa0FSUXJMYkJnTExBeEs3QTBLeTJ3WVN5d01TdXdOU3N0c0dJc3NERXJzRFlyTGJCakxMQXlLeTZ4SkFFVUt5MndaQ3l3TWl1d05Dc3RzR1Vzc0RJcnNEVXJMYkJtTExBeUs3QTJLeTJ3Wnl5d015c3VzU1FCRkNzdHNHZ3NzRE1yc0RRckxiQnBMTEF6SzdBMUt5MndhaXl3TXl1d05pc3RzR3NzSzdBSVpiQURKRkI0c0FFVk1DMEFBRXU0QU1oU1dMRUJBWTVadVFnQUNBQmpJTEFCSTBRZ3NBTWpjTEFPUlNBZ1M3Z0FEbEZMc0FaVFdsaXdOQnV3S0ZsZ1ppQ0tWVml3QWlWaHNBRkZZeU5pc0FJalJMTUtDUVVFSzdNS0N3VUVLN01PRHdVRUsxbXlCQ2dKUlZKRXN3b05CZ1Fyc1FZQlJMRWtBWWhSV0xCQWlGaXhCZ05Fc1NZQmlGRll1QVFBaUZpeEJnRkVXVmxaV2JnQi80V3dCSTJ4QlFCRUFBQUFcIn0sZnVuY3Rpb24oQSxzKXtBLmV4cG9ydHM9XCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUE0c0FCQUFBQUFBRnp3QUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJiQUFBQUJvQUFBQWNkMzdIOWtkRVJVWUFBQUdJQUFBQUhRQUFBQ0FBT1FBRVQxTXZNZ0FBQWFnQUFBQkhBQUFBVmxjVVc3NWpiV0Z3QUFBQjhBQUFBRjhBQUFGcTB2alliR04yZENBQUFBSlFBQUFBR0FBQUFDUU01ZjkwWm5CbmJRQUFBbWdBQUFUOEFBQUpsakQzbnBWbllYTndBQUFIWkFBQUFBZ0FBQUFJQUFBQUVHZHNlV1lBQUFkc0FBQUR5QUFBQmhDeEwrVkhhR1ZoWkFBQUN6UUFBQUF3QUFBQU5nNWdhU05vYUdWaEFBQUxaQUFBQUIwQUFBQWtCMTREeG1odGRIZ0FBQXVFQUFBQUlnQUFBQ0lRNXdKc2JHOWpZUUFBQzZnQUFBQWFBQUFBR2dvMkNCNXRZWGh3QUFBTHhBQUFBQ0FBQUFBZ0FTNENERzVoYldVQUFBdmtBQUFCUXdBQUFqMGxTc0JVY0c5emRBQUFEU2dBQUFCc0FBQUF5TDRrUDlWd2NtVndBQUFObEFBQUFKVUFBQUNWcGJtK1puaWNZMkJnWUdRQWdqTzJpODZENktzTEprMkcwUUJRZFFld0FBQjRuR05nWkdCZzRBTmlDUVlRWUdKZ0JFSnVJR1lCOHhnQUJNTUFQZ0FBQUhpY1kyQmsvc3Y0aFlHVmdZTnBKdE1aQmdhR2Znak4rSnJCbUpHVGdZR0pnWTJaQVFZWUJSZ1FJQ0ROTllYQmdhSGl4VHZtaHY4TkRESE1Ea0FlVUExSURnQmRvZzE1QUhpY1kyQmdZR2FBWUJrR1JnWVFTQUh5R01GOEZnWVBJTTNId01IQXhNQUdaRlc4ZVByaTFZczNMOTc5L3c5V1dmSGl5WXZuTVA3L2JuRUZjWGx4T1hGWnFEbElnQkdvR3liSXlBUWttTkFWb091Z0htQ21uZEVrQVFBOWZSYitBSGljWTJCQUEwWU1Sc3dTL3g4eU8vdy9BS01CUkdZSVgzaWNuVlZwZDlOR0ZKVzhaRS9ha3NSUVJOc3hFNmMwR3Btd0JRTXVCQ215QytuaVFHZ2w2Q0luTVYzNEEzenNaLzJhcDlDZTA0Lzh0TjQ3WGhKYWVrN2JIRXZ2dnBrN2I5TjdFM0dNcU94NUlLNVJSMHBlOTZTeS9sUXE4Yk9rcnV0ZW5panA5Wks2YktlZWtoWlJLMDJWek1YOUk3bEVkUzVXc2ttd1NjYnJYcUtlcXp6dmc5SkxNcXdvU3lMYUl0ckt2Q3hOVTA4Y1AwMjFPTDFra0thQmxJeUNuVXFqanhDcVVTK1JxZzVsU29kZXZaNkttd1ZTTmhyeHFLT2llaEFxN2h6UE9hV05PbUNrY3BYRFhMRlpiZVI3U2RieitvL1NSS2ZZMjM2Y1lNTmo5Q05YZ1ZTTXpNRDJOQjZIVHlUVDBWNGlNNUYvN0xoT2xJVlNHMXdBcjJxd3g2Qks4YUc0OFVHMkU4alVlTTN4ZFZHcE5ESVY1N3JQc3Rrc0hZK1ZFT1hCMzlpaGxCdTZ2NE96MDZhb1ZtTngrOEF6QmprcGxDaDZTQmFBRGxPWnAvWUkyankwUUdhTitxUGlIUEIxQ0MreUVHVXF6NVFzNkZBSE1tZDI5NU5pMnQxSjEyUnhvRjhHTW05Mjk1TGR4OE5GcjQ3MVpidStZQXBuTVhxU0ZJdUxFZHlITXV1blRMdlVDRWNaRjNQQXhUeGU0dGEwUXNqSUFveEtJOHhSVy9pZTJhaHJuQjFqYjNRZWo5VlRaTkpGL04xTWZqMDRxVmpoT010NlI5eEluTHZIcnV2Q1ZTQ0xDS2NhN3llT0xPcFFaYkQ2KzlLUzZ5dzRZWmhueFVMRmx4ZStkeEg1THpGdVA1QjNUT0ZTdm11S0V1VjdwaWhUbmpGRmhYSVpoYVZjTWNVVTVhb3BwaWxycHBpaFBHdUtXY3B6UnFiOWYrbjdmZmcraHpQbjRadlNnMi9LQy9CTitRRjhVMzRJMzVRZndUZWxnbS9LT254VFhvUnZTbTNnYlNsVEVhcVlzWFQ0N1NWYXRhRnFPVE80d0Q0UFpNMkk5a1Z2Qk5Jd1NuWFZTU2wxdjZWVi9pVDU2NkxIWSt1VGtybzFhV3lJdTdwcHMvajRkTVp2YmwweTZvYWRxMCtNSStXaFBYVDEyRFNoVS92TjRkL09YZDBxTHJtcmlHckRxRFlpbUFTQU51aTNBdkZOODJ3N0VQT1dYWHo4UXpBQzFNK3BOVlJUZGUzVWxSb1A4cnlydXhpZTVNRGppR09namV1dXJzQkxFMU5XUS9QaFp5a3lGZnVEdkttVmF1ZXdkZmxrV3pXSE5xVEMyeUwybFdTY3B1Mjk1RlZKbFpYM3FyUmVQcCtHSVhwNkZ0ZUV0bXpkeWFRU29WRXp6dkh3cmlwRjJaR1djdFEvUXVlWG9yNEhuSEYyUWV2RE1lNUUzVUcxTmV4MCtQbG1JMnNMSm9hbXRMMFRvR1FzWFJWalVlVlpuR04wRFdzZGI5d1NucTZuSnhieEtUYVpqOEpLZFgyVWoyNGp6U3QyV1diUnFFcDFkSmYyV2V5ck52MHlPMmhZSFdjL2FhbzI3dXBoVzQwcVVqMVZ2Z2EwQjNaVzNmaFFEeXMrNnFCUlZUWGI2TnJJWXpRdWE4Wi9ETWhpWFBuclJxc20wKy9nbG1xbnpXTE5YVUZ6MzVnczkwNHZiNzNKZml2bnBwR20vMWFqTFNPWC9SeU8rVzBSNE44NUtIWlQxa0M5TldtSWNRSFpDeGd1MVVUbkRzM2R4aURpT3ZzZm5kUDliODNDSURtcmJZM1pQUFhoNnVrb2tqdE1lWnhsbTFuVzlTak5VYlNUeEQ1RllxdkRpY0ZOamVGWWJzb0dCdVR1UDZ6Znd6M2dyaXlMRDd4dEpJQzR6OXJFcUo3cTRPNGVWeU0wN0N1NUR4aVpZOGU1RGJBRDRCTEU1dGkxS3gwQXU5SWw1dzdBWitRUVBDQ0g0Q0U1Qkx2azNBVDRuQnlDTDhnaCtKSWNncS9JdVFYUUk0ZGdqeHlDUitRUVBDYW5EYkJQRHNFVGNnaStKb2ZnRzNKYUFBazVCQ2s1QkUvSklYaG1aSE5TNW0rcHlIV2c3eXk2QWZTOTdSb29XMUIrTUhKbHdzNm9XSGJmSXJJUExDTDEwTWpWQ2ZXSWlxVU9MQ0wxdVVXay9tamsyb1Q2RXhWTC9ka2lVbit4aU5RWHhwZVpnWlRYZWk5NVJ3ZC9BaXUrckg0QUFRQUIvLzhBRDNpY25WVE5ieHRGRkg5dlp2YkQ5bnJzM2JWM0hTZHAvTkY0VTdscmt0aXVVU3pDaUJCVjFDMzVPaVFCWkFVSmhYQkNJS3FvQ0NtK1ZBSUpJZjRFaEJBY2lZUjZRT29oNlorUUkrTFFDbzZjVVgzb2hyY3BpWkljb0xDYW5abWQ5L2IzZnZON013ODB1SDc4aEQva0JmQmdHdVpnRmZxNDI5dDNsemZVTFlhUWxtbVEyOEFsU3Q0SE5FMThKNHNKTTZrbitqWmF1dEN0UHFSRTZvTU1tcUJicHI0QlNVTmpJcFVVbXc1S21WNkJkRG9wWHh2dDdmdUUyUHNIUkRPUjNQNlBrQVdDdlAxaWtHTDdoVERWbTVmZ2NKdndKSnJ2L1QvQXpjMU5OYlcyMXUzT3p2aitXbit0Ly9aR2Q3VzcybHZvdEdmbVp1ZjhhWDk2eFo0cDJGTjU1WHAxMU90WWtXd2N5KzFXcmQxcXNEcm15MW8rNStVa3ErcTFPZ1psZ3p5Q1NvTzlnbjVGejNuTjJSdXRtcThia2wvQnJqNTdJMmhnVUF1dzNacG5YWnoxeGhGSFJvdHJ6dVNZdzcvR1pDRzRjais2eGI3Ri9FUlZ5Z2xaQ3FNM3JvOVhjaU1qSmRmY3RSekhTanZPbDZhdXBRUVRHVG01c0xLc3J2cGVRa3RvbWg1OXAyV0srWWNUMTlnRVdpTkI4ZmExN0poSWwwYWRkejl2K1hOemszNENjVEJBZDdRa2YzalZMdHJVUGl0NjdsV1pUWnVGWXJwcXV6bmMvVDFWY0szeDJtOEFETlR4QVQvZ0NneklRRVZOWkdUYVNpVjBCRlFBaUhBSGFGZ0IrbDUwc3l4Ymh4Sms0eGVObDdEam84OStqcjZLaG1qZ3gyZzgrNk1SZmhMZXhROGJYRVhEMC9Yb1hxTnh0MEdySWNUeGZvUUJ2OE0rQlU0UnpRZTZZTUJxZGRjM0F2UXgrUFVvUEdJZmhWRXp4RDJhNGxRamFzVy9YZURwd3BTYWRCMDdlOEkxbVRDdGYyWExqY0FJT2tISDcvakdlY1pINGVHajhORmgzQjllNEh3L1BEdzR0Y1h4RVg2QnQzaU5mUThwMEg4eUVPTmpRS0MrUVpDZGdOZkM0ZkR2OXBUZE81MDlEWWN4ZHh4UU4rQkFlNWJRVlM4blRJTnpka0laZGdBWjdnRGpiRWZYR0JlQzkrS1JpMlVRWEx3dWhKQkMyam5hcmVIV3NabXZ1bmFWWXRyVmZMbU5qNVZTNVQxN2FRc0pXajBiTUZXWjk2S2tVdkhubVY0cHFpbnpxa3NRWE5OUkdhalJ6ZEhvNWhBckRteWRuSFdONitzZ0VFVVBoSWdWRkxobzUyemJkdDJzNlozcE9Ca1RLTGViYlZLemFUZlBTeG1WbFBybUdMYVc3TDN5MW5rdGI2cElxVCs5K1VwMEFKZDRaV0JHTllpRzBFQ3M2NmdCWnhwZko4R1E5WUN4bUFmRFJjdXlNbGJHaWFtUUJtY0hzTnB1Qm5iVHZzQmhpd1JSRnhKNVV5a2NSSU9UTTRTUHFTdWQ1TUdBTDNyN0tTcGNveFNDTEgyeXYwL2hHZThCNVdZcFRzZ0MxYlljdVhqblhjaGppVHlTTEs1OEhsbjk1MWJZdm14V1l4Y3NsN0NwSkQwZ2ViUENxWmZqblRUdEtpdXA1dzhiL0FXdmxBTmRlSnhqWUdSZ1lBRGllMDdxaGZIOE5sOFo1RmtZUU9EcWdrbVQ0YlRPL3dQTUI1Z2RnRndPQmlhUUtBQS9EUXVzZUp4allHUmdZSGI0ZjRBaGhvVUJCSmdQTURBeW9BSldBRlMzQXkwQUFBQUVBQUFBQUFBQUFBRlZBQUFENlFBc0JBQUFRQUN2QUVBQTJnR0FBRUFBUUFIZ0FBQUFBQUFBQUFBQUFBRThBWFFCa0FIUUFlNENLQUowQXJJRENBQUFBQUVBQUFBTUFGOEFCUUFBQUFBQUFnQW1BRFFBYkFBQUFJb0Jkd0FBQUFCNG5IMlF2VzdDUUJDRXgveUpTQ2xRMmpRckt3VVVaNTB0SXd6VU1XblNwa2RnZ3lWaVM3YjVVUjRoU3AweWVZYTBlVHJHeDZWSmdhM2IvZlp1dkR0bkFMZjRoSVBtY2RESG5lVVdlaGhaYnVNQmI1WTcxUHhZN3VMUmlTMzMwSGUrcUhRNk45d1ptSzhhYnJIL3ZlVTJucUF0ZDZqNXR0ekZPMzR0OXpCd1BwQmhoUUk1VWhOcklGc1ZlVnJrcEdja1dGT3d4eXVMWkozdG1XT3JhM0tKRFNXQ0FCNm5DV1pjLy90ZGRnTkVVSmh3QlZUNkpNU2NFUmZsSnBIQTB6S1R2N25FSUZJVEZXaWZxaXYyWGppN1JFVkpjeVRzMnJpWWsycStLWlkwWHZOc1M4WEZ5UkFIS2p4TUVmS1BDOTNzR0NOREplUFkzRUpoWVJ4clc1MU03OUR3a2RIbHVXdXExTVNLVnBLeXlvcGNmRS9QcGE3VDViNHV0aG52TWp4b2J4cU9STzBrRWxYS1dJdGFTS0NaVHVLSG9vN2lMbHhScWFqcTJtWFBNUVZaT1FCNG5HTmdZc0FQZUlDWWtZR0pJWnFSaVpHWmtZV1JsWkdOa1oyUmc1RlRxaW9qTlMrOXNEUzFQREV2R2NUVXJTeE56TXNHNG5RQmRDbnA1Tkw4OHRKMG9GeFNabUZwUldaaVBrS3hJSVljYTBWbVhrVW1QNWhFcUJOT1Q4d3JTY3pMUU5iTENSY0RBQ2V3T00xTHVBRElVbGl4QVFHT1dia0lBQWdBWXlDd0FTTkVJTEFESTNDd0RrVWdJRXU0QUE1UlM3QUdVMXBZc0RRYnNDaFpZR1lnaWxWWXNBSWxZYkFCUldNallyQUNJMFN6Q2drRkJDdXpDZ3NGQkN1ekRnOEZCQ3Rac2dRb0NVVlNSTE1LRFFZRUs3RUdBVVN4SkFHSVVWaXdRSWhZc1FZRFJMRW1BWWhSV0xnRUFJaFlzUVlCUkZsWldWbTRBZitGc0FTTnNRVUFSQUFBQUE9PVwifSxmdW5jdGlvbihBLHMpe0EuZXhwb3J0cz1mdW5jdGlvbihBLHMsZSx0LHIpe3ZhciBuLGk9QT1BfHx7fSxvPXR5cGVvZiBBLmRlZmF1bHQ7XCJvYmplY3RcIiE9PW8mJlwiZnVuY3Rpb25cIiE9PW98fChuPUEsaT1BLmRlZmF1bHQpO3ZhciBCPVwiZnVuY3Rpb25cIj09dHlwZW9mIGk/aS5vcHRpb25zOmk7cyYmKEIucmVuZGVyPXMucmVuZGVyLEIuc3RhdGljUmVuZGVyRm5zPXMuc3RhdGljUmVuZGVyRm5zKSx0JiYoQi5fc2NvcGVJZD10KTt2YXIgZztpZihyPyhnPWZ1bmN0aW9uKEEpe0E9QXx8dGhpcy4kdm5vZGUmJnRoaXMuJHZub2RlLnNzckNvbnRleHR8fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC4kdm5vZGUmJnRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0LEF8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9ffHwoQT1fX1ZVRV9TU1JfQ09OVEVYVF9fKSxlJiZlLmNhbGwodGhpcyxBKSxBJiZBLl9yZWdpc3RlcmVkQ29tcG9uZW50cyYmQS5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKHIpfSxCLl9zc3JSZWdpc3Rlcj1nKTplJiYoZz1lKSxnKXt2YXIgQz1CLmZ1bmN0aW9uYWwsUT1DP0IucmVuZGVyOkIuYmVmb3JlQ3JlYXRlO0M/Qi5yZW5kZXI9ZnVuY3Rpb24oQSxzKXtyZXR1cm4gZy5jYWxsKHMpLFEoQSxzKX06Qi5iZWZvcmVDcmVhdGU9UT9bXS5jb25jYXQoUSxnKTpbZ119cmV0dXJue2VzTW9kdWxlOm4sZXhwb3J0czppLG9wdGlvbnM6Qn19fSxmdW5jdGlvbihBLHMsZSl7QS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLHM9QS4kY3JlYXRlRWxlbWVudCxlPUEuX3NlbGYuX2N8fHM7cmV0dXJuIGUoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2bS1wcm9ncmVzc1wiLGNsYXNzOltcInZtLXByb2dyZXNzLS1cIitBLnR5cGUsQS5zdGF0dXM/XCJpcy1cIitBLnN0YXR1czpcIlwiLHtcInZtLXByb2dyZXNzLS13aXRob3V0LXRleHRcIjohQS5zaG93VGV4dCxcInZtLXByb2dyZXNzLS10ZXh0LWluc2lkZVwiOkEudGV4dEluc2lkZX1dfSxbXCJsaW5lXCI9PT1BLnR5cGU/ZShcImRpdlwiLHtzdGF0aWNDbGFzczpcInZtLXByb2dyZXNzLWJhclwifSxbZShcImRpdlwiLHtzdGF0aWNDbGFzczpcInZtLXByb2dyZXNzLWJhcl9fb3V0ZXJcIixzdHlsZTp7aGVpZ2h0OkEuc3Ryb2tlV2lkdGgrXCJweFwiLGJhY2tncm91bmRDb2xvcjpBLnRyYWNrQ29sb3J9fSxbZShcImRpdlwiLHtzdGF0aWNDbGFzczpcInZtLXByb2dyZXNzLWJhcl9faW5uZXJcIixjbGFzczpbe1widm0tcHJvZ3Jlc3MtYmFyX19zdHJpcGVkXCI6QS5zdHJpcGVkfSxBLmxpbmVhckNsYXNzTmFtZV0sc3R5bGU6QS5iYXJTdHlsZX0sW0Euc2hvd1RleHQmJkEudGV4dEluc2lkZT9lKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidm0tcHJvZ3Jlc3MtYmFyX19pbm5lclRleHRcIn0sW0EuX3QoXCJkZWZhdWx0XCIsW0EuX3YoQS5fcyhBLnBlcmNlbnRhZ2UpK1wiJVwiKV0pXSwyKTpBLl9lKCldKV0pXSk6ZShcImRpdlwiLHtzdGF0aWNDbGFzczpcInZtLXByb2dyZXNzLWNpcmNsZVwiLHN0eWxlOntoZWlnaHQ6QS53aWR0aCtcInB4XCIsd2lkdGg6QS53aWR0aCtcInB4XCJ9fSxbZShcInN2Z1wiLHthdHRyczp7dmlld0JveDpcIjAgMCAxMDAgMTAwXCJ9fSxbZShcInBhdGhcIix7c3RhdGljQ2xhc3M6XCJ2bS1wcm9ncmVzcy1jaXJjbGVfX3RyYWNrXCIsYXR0cnM6e2Q6QS50cmFja1BhdGgsc3Ryb2tlOkEudHJhY2tDb2xvcixcInN0cm9rZS13aWR0aFwiOkEucmVsYXRpdmVTdHJva2VXaWR0aCxmaWxsOlwibm9uZVwifX0pLEEuX3YoXCIgXCIpLGUoXCJwYXRoXCIse3N0YXRpY0NsYXNzOlwidm0tcHJvZ3Jlc3MtY2lyY2xlX19wYXRoXCIsc3R5bGU6QS5jaXJjbGVQYXRoU3R5bGUsYXR0cnM6e2Q6QS50cmFja1BhdGgsXCJzdHJva2UtbGluZWNhcFwiOkEuc3Ryb2tlTGluZWNhcCxzdHJva2U6QS5zdHJva2UsXCJzdHJva2Utd2lkdGhcIjpBLnJlbGF0aXZlU3Ryb2tlV2lkdGgsZmlsbDpcIm5vbmVcIn19KV0pXSksQS5fdihcIiBcIiksQS5zaG93VGV4dCYmIUEudGV4dEluc2lkZT9lKFwiZGl2XCIse3JlZjpcInByb2dyZXNzVGV4dFwiLHN0YXRpY0NsYXNzOlwidm0tcHJvZ3Jlc3NfX3RleHRcIixzdHlsZTp7Zm9udFNpemU6QS5wcm9ncmVzc1RleHRTaXplK1wicHhcIn19LFshQS5zdHx8QS5zdHJva2VDb2xvcnx8QS4kc2xvdHMuZGVmYXVsdD9bQS5fdChcImRlZmF1bHRcIixbQS5fdihBLl9zKEEucGVyY2VudGFnZSkrXCIlXCIpXSldOmUoXCJpXCIse2NsYXNzOkEuaWNvbkNsYXNzfSldLDIpOkEuX2UoKV0pfSxzdGF0aWNSZW5kZXJGbnM6W119LEEuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZD0hMH1dKX0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/vue-multiple-progress/lib/progress.js\n')},"../node_modules/vue/dist/vue.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.11\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive.\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    typeof value === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array.\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether an object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function (a, b, c) {\n    return false;\n  };\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n\n\n  var identity = function (_) {\n    return _;\n  };\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = ('__proto__' in {}); // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function (str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function (text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (customSetter) {\n          customSetter();\n        } // #7981: for accessor properties without setter\n\n\n        if (getter && !setter) {\n          return;\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i]; // in case the object is already observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n\n        if (typeof def$$1 === 'function') {\n          dirs[key] = {\n            bind: def$$1,\n            update: def$$1\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child); // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop.default; // warn against non-factory defaults for Object & Array\n\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n\n    message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  function isExplicable(value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n\n    try {\n      if (vm) {\n        var cur = vm;\n\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        }); // issue #9511\n        // avoid catch triggering multiple times when nested calls\n\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n\n  var isUsingMicroTask = false;\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n\n\n  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n\n  /* istanbul ignore next, $flow-disable-line */\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    timerFunc = function () {\n      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function (tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag); // perf.clearMeasures(name)\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = (key in target);\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // #6574 in case the inject object is observed...\n\n        if (key === '__ob__') {\n          continue;\n        }\n\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n\n    var slots = {};\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n  /*  */\n\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    } // expose normal slots on scopedSlots\n\n\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    } // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n\n\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n      ) ? undefined : res;\n    }; // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n\n\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n\n    if (!isDef(ret)) {\n      ret = [];\n    }\n\n    ret._isVList = true;\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function (key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop(key);\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res, // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || {\n      $stable: !hasDynamicKeys\n    };\n\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n\n        res[slot.key] = slot.fn;\n      }\n    }\n\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a special value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n\n    return baseObj;\n  } // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n\n\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    }); // support for compiled functional template\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n\n    merged._merged = true;\n    return merged;\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        default: children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        if (isDef(data) && isDef(data.nativeOn)) {\n          warn(\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\", context);\n        }\n\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      } // if the returned array contains only a single node, allow it\n\n\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;\n      owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      } // specific handler\n\n\n      var cb;\n      var i = cbs.length;\n\n      while (i--) {\n        cb = cbs[i];\n\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        );\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      restoreActiveInstance(); // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  } // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n\n\n  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\n  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function () {\n        return performance.now();\n      };\n    }\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n\n      if (watcher.before) {\n        watcher.before();\n      }\n\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$2 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function (key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop(key);\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + typeof methods[key] + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n        }\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = latest[key];\n      }\n    }\n\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var cachedNode = cache[key];\n\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.6.11';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function (tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function (tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          );\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n\n\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({\n      name: name,\n      value: value\n    }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({\n      value: value.trim(),\n      dynamic: dynamic\n    }, range);\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n\n    return item;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n\n\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n\n      handler = original._wrapper = function (e) {\n        if ( // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget || // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n\n    target$1.addEventListener(name, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if ( // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (typeof def$$1 === 'object') {\n      var res = {};\n\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n\n\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function (c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function (d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots.default;\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function () {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n      var update = this._update;\n\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n  /*  */\n  // install platform specific utils\n\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n  /*  */\n\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function (tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('--\x3e');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n            start: index + html.length\n          });\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs,\n          start: match.start,\n          end: match.end\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n              start: stack[i].start,\n              end: stack[i].end\n            });\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:|^#/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  var slotRE = /^v-slot(:|$)|^#/;\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  var decodeHTMLCached = cached(he.decode);\n  var emptySlotScopeToken = \"_empty_\"; // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n\n    maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      } // tree management\n\n\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n            start: element.start\n          });\n        }\n      }\n\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      } // final children cleanup\n      // filter out scoped slots\n\n\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      }); // remove trailing whitespace node again\n\n      trimEndingWhitespace(element); // check pre state\n\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n          start: el.start\n        });\n      }\n\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n            start: element.start\n          });\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1]; // pop stack\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n\n        closeElement(element);\n      },\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', {\n                start: start\n              });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n                start: start\n              });\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n\n          var res;\n          var child;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n            /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  } // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\n  function processSlotContent(el) {\n    var slotScope;\n\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n\n      el.slotScope = slotScope;\n    } // slot=\"xxx\"\n\n\n    var slotTarget = getBindingAttr(el, 'slot');\n\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    } // 2.6 v-slot syntax\n\n\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          } // add the component's children to its default slot\n\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n          el.children = []; // mark el non-plain so data gets generated\n\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n\n    return dynamicArgRE.test(name) // dynamic [name]\n    ? {\n      name: name.slice(1, -1),\n      dynamic: true\n    } // static name\n    : {\n      name: \"\\\"\" + name + \"\\\"\",\n      dynamic: false\n    };\n  } // handle <slot/> outlets\n\n\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$1];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node.for) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function (condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (// make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n\n    var originalPreState = state.pre;\n\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    } // v-bind data wrap\n\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', {\n        start: el.start\n      });\n    }\n\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    }); // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n\n    var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n          needsForceUpdate = true;\n          break;\n        }\n\n        if (parent.if) {\n          needsKey = true;\n        }\n\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n\n      return el.children.some(containsSlotChild);\n    }\n\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            var range = node.rawAttrsMap[name];\n\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (name === 'v-slot' || name[0] === '#') {\n              checkFunctionParameterExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stripped = exp.replace(stripStringRE, '');\n    var keywordMatch = stripped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n\n  function checkFunctionParameterExpression(exp, text, warn, range) {\n    try {\n      new Function(exp, '');\n    } catch (e) {\n      warn(\"invalid function parameter expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n  /*  */\n\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n\n            count += lineLength + 1;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n\n        n >>>= 1;\n\n        if (n <= 0) {\n          break;\n        }\n\n        str += str;\n      }\n    }\n\n    return result;\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = {\n                msg: msg\n              };\n\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n\n              (tip ? tips : errors).push(data);\n            };\n          } // merge custom modules\n\n\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"../node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5qcz8yNmRkIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZW1wdHlPYmplY3QiLCJPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwidG9SYXdUeXBlIiwiY2FsbCIsInNsaWNlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJuIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm1hcCIsImNyZWF0ZSIsImxpc3QiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJhcnIiLCJpdGVtIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJrZXkiLCJjYWNoZWQiLCJmbiIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwiRnVuY3Rpb24iLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJleHRlbmQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJyZXMiLCJub29wIiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsImtleXMiLCJtIiwiY29uY2F0Iiwic3RhdGljS2V5cyIsImpvaW4iLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZSIsIkRhdGUiLCJnZXRUaW1lIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJhc3luYyIsIl9saWZlY3ljbGVIb29rcyIsInVuaWNvZGVSZWdFeHAiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwiUmVnRXhwIiwic291cmNlIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibWF0Y2giLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImVudiIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ3YXJuIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwidHJhY2UiLCJlcnJvciIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJvcHRpb25zIiwiY2lkIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJzb3J0IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImRlZHVwZUhvb2tzIiwiaG9va3MiLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwidHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsImRlZiQkMSIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJtZXNzYWdlIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiTnVtYmVyIiwiZXhwbGljaXRUeXBlcyIsInNvbWUiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsIl9oYW5kbGVkIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwic2V0SW1tZWRpYXRlIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsImV2ZW50IiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsIm5hbWUkMSIsImlzV2hpdGVzcGFjZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3RzIiwibm9ybWFsU2xvdHMiLCJwcmV2U2xvdHMiLCJoYXNOb3JtYWxTbG90cyIsImlzU3RhYmxlIiwiJHN0YWJsZSIsIiRrZXkiLCJfbm9ybWFsaXplZCIsIiRoYXNOb3JtYWwiLCJub3JtYWxpemVTY29wZWRTbG90Iiwia2V5JDIiLCJwcm94eU5vcm1hbFNsb3QiLCJwcm94eSIsInJlbmRlckxpc3QiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsIm5vZGVzIiwiJHNsb3RzIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImxvb3AiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsImh5cGhlbmF0ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsInRoaXMkMSIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImxpc3RlbmVycyIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImFic3RyYWN0IiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiX3BhcmVudFZub2RlIiwiaW5saW5lVGVtcGxhdGUiLCJ0b01lcmdlIiwiX21lcmdlZCIsIm1lcmdlSG9vayQxIiwiZjEiLCJmMiIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCIkdm5vZGUiLCJwcmUiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiVnVlIiwiJG5leHRUaWNrIiwiX3JlbmRlciIsInJlZiIsInJlbmRlckVycm9yIiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJvd25lciIsIm93bmVycyIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsInN5bmMiLCJ0aW1lckxvYWRpbmciLCJ0aW1lclRpbWVvdXQiLCIkb24iLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsImNsZWFyVGltZW91dCIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCJyZW1vdmUkMSIsIiRvZmYiLCJfdGFyZ2V0Iiwib25jZUhhbmRsZXIiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsIiRvbmNlIiwiaSQxIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInNldEFjdGl2ZUluc3RhbmNlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsInJlc3RvcmVBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9fdnVlX18iLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsIm5ld1Njb3BlZFNsb3RzIiwib2xkU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93Iiwibm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJmaWx0ZXIiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJyZWYkMSIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsIm9sZEFyZyIsImFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJleGVjIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJkeW5hbWljQXJnQXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsImVtcHR5U2xvdFNjb3BlVG9rZW4iLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsIm1heWJlQ29tcG9uZW50IiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwid2hpdGVzcGFjZU9wdGlvbiIsIndoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwidHJpbUVuZGluZ1doaXRlc3BhY2UiLCJwcm9jZXNzZWQiLCJwcm9jZXNzRWxlbWVudCIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsImZvcmJpZGRlbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJjb21tZW50cyIsInN0YXJ0JDEiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiZW5kJDEiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImZvciIsIml0ZXJhdG9yMiIsIml0ZXJhdG9yMSIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90VGFyZ2V0RHluYW1pYyIsInNsb3RCaW5kaW5nIiwiZ2V0U2xvdE5hbWUiLCJzbG90QmluZGluZyQxIiwiZHluYW1pYyQxIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwibCQxIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwiZm5JbnZva2VSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwibmVlZHNLZXkiLCJnZW5lcmF0ZWRTbG90cyIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsIm5vcm1hbGl6YXRpb25UeXBlJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0cmlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwiY291bnQiLCJyZXBlYXQkMSIsImxpbmVMZW5ndGgiLCJwYWQiLCJsZW5ndGgkMSIsIm1pbiIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQyxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUMxQixVQUErREMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCRixPQUFPLEVBQXZGLEdB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VCxDQUF1QnAzQyxFQUF2QixFQUEyQjtBQUN6QixRQUFJQSxFQUFFLENBQUNxM0MsU0FBUCxFQUFrQjtBQUNoQixhQUFPcjNDLEVBQUUsQ0FBQ3EzQyxTQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSUMsU0FBUyxHQUFHendDLFFBQVEsQ0FBQzhLLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQTJsQyxlQUFTLENBQUMzd0IsV0FBVixDQUFzQjNtQixFQUFFLENBQUNnaUMsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxhQUFPc1YsU0FBUyxDQUFDdnJCLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRDdWLEtBQUcsQ0FBQ2lnQyxPQUFKLEdBQWNDLGtCQUFkO0FBRUEsU0FBT2xnQyxHQUFQO0FBRUQsQ0F2clhBLENBQUQsQyIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNi4xMVxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlZ1ZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qICAqL1xuXG4gIHZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4gIC8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuICAvLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuICBmdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBpc0RlZiAodikge1xuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAgICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICAgKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAgICovXG4gIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAgICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNEZWYodmFsKSAmJlxuICAgICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbFxuICAgICAgPyAnJ1xuICAgICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICAgIDogU3RyaW5nKHZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAgICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICAgKiBpcyBpbiB0aGF0IG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VNYXAgKFxuICAgIHN0cixcbiAgICBleHBlY3RzTG93ZXJDYXNlXG4gICkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gICAqL1xuICB2YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICAgKi9cbiAgdmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAgICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICAgKi9cbiAgdmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4gIHZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICAgKi9cbiAgdmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gICAqL1xuICB2YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuICB2YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gICAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAgICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICAgKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gICAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxcbiAgICAgICAgPyBsID4gMVxuICAgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgICAgOiBmbi5jYWxsKGN0eClcbiAgICB9XG5cbiAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgcmV0dXJuIGJvdW5kRm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgICByZXR1cm4gZm4uYmluZChjdHgpXG4gIH1cblxuICB2YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICAgPyBuYXRpdmVCaW5kXG4gICAgOiBwb2x5ZmlsbEJpbmQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKipcbiAgICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdG9cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAgICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gICAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbiAgLyoqXG4gICAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAqL1xuICB2YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqL1xuICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gICAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICAgIH0sIFtdKS5qb2luKCcsJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAgICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICAgKi9cbiAgZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gICAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAgICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbiAgdmFyIEFTU0VUX1RZUEVTID0gW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF07XG5cbiAgdmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnLFxuICAgICdlcnJvckNhcHR1cmVkJyxcbiAgICAnc2VydmVyUHJlZmV0Y2gnXG4gIF07XG5cbiAgLyogICovXG5cblxuXG4gIHZhciBjb25maWcgPSAoe1xuICAgIC8qKlxuICAgICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgICAqL1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAgICovXG4gICAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgICAqL1xuICAgIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICAgKi9cbiAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgICAqL1xuICAgIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgICAqL1xuICAgIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAgICovXG4gICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIG11c3RVc2VQcm9wOiBubyxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgICAqL1xuICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gICAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gICAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAgICovXG4gIHZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAgICovXG4gIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICAgIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gICAqL1xuICB2YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbiAgZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG4gIHZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4gIC8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbiAgdmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbiAgdmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuICB2YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbiAgdmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuICB2YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG4gIHZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG4gIHZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuICB2YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbiAgdmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4gIC8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbiAgdmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxuICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbiAgLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbiAgdmFyIF9pc1NlcnZlcjtcbiAgdmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzU2VydmVyXG4gIH07XG5cbiAgLy8gZGV0ZWN0IGRldnRvb2xzXG4gIHZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxuICB9XG5cbiAgdmFyIGhhc1N5bWJvbCA9XG4gICAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4gIHZhciBfU2V0O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gICAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gICAgX1NldCA9IFNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gICAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgICAgfTtcbiAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgICB9O1xuICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFNldDtcbiAgICB9KCkpO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4gPSBub29wO1xuICB2YXIgdGlwID0gbm9vcDtcbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbiAgdmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbiAge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICAgIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgICA/IHZtLm9wdGlvbnNcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgICA6IHZtO1xuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgICAgKVxuICAgIH07XG5cbiAgICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgICAgbiA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgIHZhciB0cmVlID0gW107XG4gICAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHVpZCA9IDA7XG5cbiAgLyoqXG4gICAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICAgKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICAgKi9cbiAgdmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gICAgdGhpcy5pZCA9IHVpZCsrO1xuICAgIHRoaXMuc3VicyA9IFtdO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xuICB9O1xuXG4gIERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICAgIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgIC8vIG9yZGVyXG4gICAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuICAvLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbiAgLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gICAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIHRleHQsXG4gICAgZWxtLFxuICAgIGNvbnRleHQsXG4gICAgY29tcG9uZW50T3B0aW9ucyxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKSB7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbiAgfVxuXG4gIC8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4gIC8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3NcbiAgLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4gIC8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG4gIGZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICAgIHZub2RlLnRhZyxcbiAgICAgIHZub2RlLmRhdGEsXG4gICAgICAvLyAjNzk3NVxuICAgICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgICAvLyBhIGNoaWxkLlxuICAgICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICAgIHZub2RlLnRleHQsXG4gICAgICB2bm9kZS5lbG0sXG4gICAgICB2bm9kZS5jb250ZXh0LFxuICAgICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICAgICk7XG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gICAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICAgIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICAgIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICAvKlxuICAgKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gICAqL1xuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxuICB2YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICAgJ3B1c2gnLFxuICAgICdwb3AnLFxuICAgICdzaGlmdCcsXG4gICAgJ3Vuc2hpZnQnLFxuICAgICdzcGxpY2UnLFxuICAgICdzb3J0JyxcbiAgICAncmV2ZXJzZSdcbiAgXTtcblxuICAvKipcbiAgICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gICAqL1xuICBtZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICAgIHZhciBpbnNlcnRlZDtcbiAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4gIC8qKlxuICAgKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAgICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgdmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gICAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAgICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAgICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpcy52bUNvdW50ID0gMDtcbiAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmIChoYXNQcm90bykge1xuICAgICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhbGsodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBoZWxwZXJzXG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICAgKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICAgKi9cbiAgZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gIH1cblxuICAvKipcbiAgICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAgICogaGlkZGVuIHByb3BlcnRpZXMuXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAgICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAgICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb2I7XG4gICAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgICAhdmFsdWUuX2lzVnVlXG4gICAgKSB7XG4gICAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgICBvYi52bUNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBvYlxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgICBvYmosXG4gICAga2V5LFxuICAgIHZhbCxcbiAgICBjdXN0b21TZXR0ZXIsXG4gICAgc2hhbGxvd1xuICApIHtcbiAgICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICAgIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAgICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICAgKiBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gICAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICAgKSB7XG4gICAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgaWYgKCFvYikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICAgIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICAgICkge1xuICAgICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgaWYgKCFvYikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICAgKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICAgIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAgICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAgICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gICAqL1xuICB2YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuICAvKipcbiAgICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICAgKi9cbiAge1xuICAgIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgICAgaWYgKCF2bSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gICAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gICAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgdG9WYWwgPSB0b1trZXldO1xuICAgICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICAgICkge1xuICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm1cbiAgKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgICAgfVxuICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgICB9XG4gICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm1cbiAgKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbiAgfTtcblxuICAvKipcbiAgICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWxcbiAgKSB7XG4gICAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgICA/IHBhcmVudFZhbFxuICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgICA6IHBhcmVudFZhbDtcbiAgICByZXR1cm4gcmVzXG4gICAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICAgIDogcmVzXG4gIH1cblxuICBmdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBMSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFzc2V0c1xuICAgKlxuICAgKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gICAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAgICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtLFxuICAgIGtleVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gICAgaWYgKGNoaWxkVmFsKSB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFdhdGNoZXJzLlxuICAgKlxuICAgKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gICAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICAgKi9cbiAgc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICAgIHtcbiAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICAgIHZhciByZXQgPSB7fTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICAgIH1cbiAgICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG5cbiAgLyoqXG4gICAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gICAqL1xuICBzdHJhdHMucHJvcHMgPVxuICBzdHJhdHMubWV0aG9kcyA9XG4gIHN0cmF0cy5pbmplY3QgPVxuICBzdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtLFxuICAgIGtleVxuICApIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gICAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICAgIHJldHVybiByZXRcbiAgfTtcbiAgc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICAgKi9cbiAgdmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICAgID8gcGFyZW50VmFsXG4gICAgICA6IGNoaWxkVmFsXG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gICAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAgICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSwgdmFsLCBuYW1lO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgICAgPyB2YWxcbiAgICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICAgIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICAgIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICAgIGlmIChkaXJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICAgKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgICBwYXJlbnQsXG4gICAgY2hpbGQsXG4gICAgdm1cbiAgKSB7XG4gICAge1xuICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAgIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhc3NldC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gICAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gICAgb3B0aW9ucyxcbiAgICB0eXBlLFxuICAgIGlkLFxuICAgIHdhcm5NaXNzaW5nXG4gICkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gICAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gICAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gICAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cblxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gICAga2V5LFxuICAgIHByb3BPcHRpb25zLFxuICAgIHByb3BzRGF0YSxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gICAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICAgIH1cbiAgICB7XG4gICAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAgIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICAgIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgICB9XG4gICAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgICA/IGRlZi5jYWxsKHZtKVxuICAgICAgOiBkZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgICBwcm9wLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgdm0sXG4gICAgYWJzZW50XG4gICkge1xuICAgIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbiAgZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgICB2YXIgdmFsaWQ7XG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IHZhbGlkLFxuICAgICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICAgKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAgICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICB2YXIgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgZXhwZWN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh2bSkge1xuICAgICAgICB2YXIgY3VyID0gdm07XG4gICAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgICBoYW5kbGVyLFxuICAgIGNvbnRleHQsXG4gICAgYXJncyxcbiAgICB2bSxcbiAgICBpbmZvXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgICAvLyBpc3N1ZSAjOTUxMVxuICAgICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuICAvLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuICAvLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuICAvLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbiAgLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4gIC8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuICAvLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4gIC8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuICAvLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbiAgLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuICAvLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbiAgdmFyIHRpbWVyRnVuYztcblxuICAvLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gICAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG4gIH0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gICAgLy8gVGVjaG5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbWFyaztcbiAgdmFyIG1lYXN1cmU7XG5cbiAge1xuICAgIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBwZXJmICYmXG4gICAgICBwZXJmLm1hcmsgJiZcbiAgICAgIHBlcmYubWVhc3VyZSAmJlxuICAgICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgICApIHtcbiAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbiAgdmFyIGluaXRQcm94eTtcblxuICB7XG4gICAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICAgKTtcblxuICAgIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgaGFzUHJveHkgPVxuICAgICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gICAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICAgIHZhciBpLCBrZXlzO1xuICAgIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb25jZTogb25jZSQkMSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlclxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgICBvbixcbiAgICBvbGRPbixcbiAgICBhZGQsXG4gICAgcmVtb3ZlJCQxLFxuICAgIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgICBkYXRhLFxuICAgIEN0b3IsXG4gICAgdGFnXG4gICkge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AgKFxuICAgIHJlcyxcbiAgICBoYXNoLFxuICAgIGtleSxcbiAgICBhbHRLZXksXG4gICAgcHJlc2VydmVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuICAvLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuICAvL1xuICAvLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuICAvLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4gIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAvLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIC8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gIC8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuICAvLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4gIC8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgLy8gIG5lc3RlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlKSB7XG4gICAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgICAgOiBwcm92aWRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICAgIGlmIChpbmplY3QpIHtcbiAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0XG4gICkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHZhciBzbG90cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICB9XG4gICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90c1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gICAgc2xvdHMsXG4gICAgbm9ybWFsU2xvdHMsXG4gICAgcHJldlNsb3RzXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gICAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gICAgaWYgKCFzbG90cykge1xuICAgICAgcmVzID0ge307XG4gICAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTdGFibGUgJiZcbiAgICAgIHByZXZTbG90cyAmJlxuICAgICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxuICAgICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgICApIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgcmV0dXJuIHByZXZTbG90c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgcmVzWzBdLmlzQ29tbWVudCkgLy8gIzk2NThcbiAgICAgICkgPyB1bmRlZmluZWRcbiAgICAgICAgOiByZXNcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFxuICB9XG5cbiAgZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgICB2YWwsXG4gICAgcmVuZGVyXG4gICkge1xuICAgIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTbG90IChcbiAgICBuYW1lLFxuICAgIGZhbGxiYWNrLFxuICAgIHByb3BzLFxuICAgIGJpbmRPYmplY3RcbiAgKSB7XG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICAgIHZhciBub2RlcztcbiAgICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAgICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gICAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gICAgZXZlbnRLZXlDb2RlLFxuICAgIGtleSxcbiAgICBidWlsdEluS2V5Q29kZSxcbiAgICBldmVudEtleU5hbWUsXG4gICAgYnVpbHRJbktleU5hbWVcbiAgKSB7XG4gICAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gICAgZGF0YSxcbiAgICB0YWcsXG4gICAgdmFsdWUsXG4gICAgYXNQcm9wLFxuICAgIGlzU3luY1xuICApIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaDtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gICAgaW5kZXgsXG4gICAgaXNJbkZvclxuICApIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICAgIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgICAgcmV0dXJuIHRyZWVcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICAgIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAgICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiBtYXJrT25jZSAoXG4gICAgdHJlZSxcbiAgICBpbmRleCxcbiAgICBrZXlcbiAgKSB7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICAgIHRyZWUsXG4gICAga2V5LFxuICAgIGlzT25jZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgICBub2RlLmtleSA9IGtleTtcbiAgICBub2RlLmlzT25jZSA9IGlzT25jZTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICAgIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgICByZXMsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gICAgaGFzRHluYW1pY0tleXMsXG4gICAgY29udGVudEhhc2hLZXlcbiAgKSB7XG4gICAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBpcyBhIHNwZWNpYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmpcbiAgfVxuXG4gIC8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuICAvLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuICAvLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG4gIGZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICAgIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICAgIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gICAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gICAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICAgIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gICAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gICAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFyZW50LFxuICAgIEN0b3JcbiAgKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICAgIHZhciBjb250ZXh0Vm07XG4gICAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgICB9XG4gICAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS4kc2xvdHMpIHtcbiAgICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB0aGlzJDEuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcyQxLiRzbG90c1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICAgIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICAgIEN0b3IsXG4gICAgcHJvcHNEYXRhLFxuICAgIGRhdGEsXG4gICAgY29udGV4dFZtLFxuICAgIGNoaWxkcmVuXG4gICkge1xuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICAgIGRhdGEsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY29udGV4dFZtLFxuICAgICAgQ3RvclxuICAgICk7XG5cbiAgICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAgIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gICAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gICAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gICAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAge1xuICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG4gIHZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gICAgQ3RvcixcbiAgICBkYXRhLFxuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgdGFnXG4gICkge1xuICAgIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gICAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICAgIH1cblxuICAgIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgICAvLyByZWplY3QuXG4gICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYXN5bmMgY29tcG9uZW50XG4gICAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdGFnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICAgIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAgIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gICAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gICAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICAgIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICAgIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICAgIGFzeW5jRmFjdG9yeVxuICAgICk7XG5cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAgIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gICkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICAgIHBhcmVudDogcGFyZW50XG4gICAgfTtcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gICAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICAgIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgICBmMShhLCBiKTtcbiAgICAgIGYyKGEsIGIpO1xuICAgIH07XG4gICAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbiAgLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICAgIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICAgICkge1xuICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbiAgdmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4gIC8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgICBjb250ZXh0LFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIG5vcm1hbGl6YXRpb25UeXBlLFxuICAgIGFsd2F5c05vcm1hbGl6ZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gICAgY29udGV4dCxcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICBub3JtYWxpemF0aW9uVHlwZVxuICApIHtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgICAgdGFnID0gZGF0YS5pcztcbiAgICB9XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICB2YXIgdm5vZGUsIG5zO1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIEN0b3I7XG4gICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgICB2bm9kZS5ucyA9IG5zO1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVmICM1MzE4XG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4gIC8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gICAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgIHZhciB2bm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgcGFyZW50XG4gICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICAgIGlmIChcbiAgICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICAgICkge1xuICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgICA6IGNvbXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICAgIGZhY3RvcnksXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgICBmYWN0b3J5LFxuICAgIGJhc2VDdG9yXG4gICkge1xuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgICB9XG5cbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICAgIH1cblxuICAgIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICB9XG5cbiAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3RvcnlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFyZ2V0O1xuXG4gIGZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICAgIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICAgIHZtLFxuICAgIGxpc3RlbmVycyxcbiAgICBvbGRMaXN0ZW5lcnNcbiAgKSB7XG4gICAgdGFyZ2V0ID0gdm07XG4gICAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gICAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBvbi5mbiA9IGZuO1xuICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGFsbFxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB7XG4gICAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICAgIH1cblxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICAgIHZtLiRjaGlsZHJlbiA9IFtdO1xuICAgIHZtLiRyZWZzID0ge307XG5cbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gICAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlc1xuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICB9XG4gICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICAgIH1cbiAgICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgICB9XG4gICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgICB2bS4kb2ZmKCk7XG4gICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICAgIHZtLFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICB2bS4kZWwgPSBlbDtcbiAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gICAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gICAgdm0sXG4gICAgcHJvcHNEYXRhLFxuICAgIGxpc3RlbmVycyxcbiAgICBwYXJlbnRWbm9kZSxcbiAgICByZW5kZXJDaGlsZHJlblxuICApIHtcbiAgICB7XG4gICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAgIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gICAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICAgIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gICAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICAgIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSlcbiAgICApO1xuXG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICAgICk7XG5cbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gICAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgIH1cbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAgIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAgIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAgIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gICAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gdXBkYXRlIHByb3BzXG4gICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICB9XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gICAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG4gIHZhciBoYXMgPSB7fTtcbiAgdmFyIGNpcmN1bGFyID0ge307XG4gIHZhciB3YWl0aW5nID0gZmFsc2U7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAge1xuICAgICAgY2lyY3VsYXIgPSB7fTtcbiAgICB9XG4gICAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuICAvLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuICAvLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG4gIHZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4gIC8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG4gIHZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbiAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuICAvLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbiAgLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbiAgaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICAgIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICBpZiAoXG4gICAgICBwZXJmb3JtYW5jZSAmJlxuICAgICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgICApIHtcbiAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVyIHRpbWVzdGFtcHMgYXNcbiAgICAgIC8vIHdlbGwuXG4gICAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAgIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gICAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICAgIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAgIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAgIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgICAgfVxuICAgICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICB3YXRjaGVyLnJ1bigpO1xuICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gICAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICAgIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAgIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICAgIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gICAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gICAgLy8gZGV2dG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICAgKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gICAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAgICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gICAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgICAgfVxuICAgICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIHZhciB1aWQkMiA9IDA7XG5cbiAgLyoqXG4gICAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICAgKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAgICovXG4gIHZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLmdldCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICAgIHB1c2hUYXJnZXQodGhpcyk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gICAgdmFyIGlkID0gZGVwLmlkO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgIHRoaXMuZGVlcFxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogbm9vcCxcbiAgICBzZXQ6IG5vb3BcbiAgfTtcblxuICBmdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgICB9O1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgaW5pdERhdGEodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gICAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgfVxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gICAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICAgIDogZGF0YSB8fCB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHtcbiAgICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICAgIHJldHVybiB7fVxuICAgIH0gZmluYWxseSB7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG4gIGZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gICAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NTUikge1xuICAgICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgICAgdm0sXG4gICAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgICAgbm9vcCxcbiAgICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgICB0YXJnZXQsXG4gICAga2V5LFxuICAgIHVzZXJEZWZcbiAgKSB7XG4gICAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgICAgOiBub29wO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gICAgfVxuICAgIGlmIChzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICAgIHZtLFxuICAgIGV4cE9yRm4sXG4gICAgaGFuZGxlcixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgIHZhciBkYXRhRGVmID0ge307XG4gICAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gICAgdmFyIHByb3BzRGVmID0ge307XG4gICAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgICB7XG4gICAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gICAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gICAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgICBleHBPckZuLFxuICAgICAgY2IsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycm9yLCB2bSwgKFwiY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHVpZCQzID0gMDtcblxuICBmdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGEgdWlkXG4gICAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgIHZtLl9zZWxmID0gdm07XG4gICAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgaW5pdFJlbmRlcih2bSk7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICAgIHZhciBtb2RpZmllZDtcbiAgICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICAgIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gICAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICAgKSB7XG4gICAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gIH1cblxuICBpbml0TWl4aW4oVnVlKTtcbiAgc3RhdGVNaXhpbihWdWUpO1xuICBldmVudHNNaXhpbihWdWUpO1xuICBsaWZlY3ljbGVNaXhpbihWdWUpO1xuICByZW5kZXJNaXhpbihWdWUpO1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gICAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAgICovXG4gICAgVnVlLmNpZCA9IDA7XG4gICAgdmFyIGNpZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgICAqL1xuICAgIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgICBleHRlbmRPcHRpb25zXG4gICAgICApO1xuICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgICB9XG4gICAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgICAgfSk7XG4gICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgICAgfVxuXG4gICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgICAgcmV0dXJuIFN1YlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICAgIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgICBpZCxcbiAgICAgICAgZGVmaW5pdGlvblxuICAgICAgKSB7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICAgIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gICAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gICAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICAgIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gICAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgICBjYWNoZSxcbiAgICBrZXksXG4gICAga2V5cyxcbiAgICBjdXJyZW50XG4gICkge1xuICAgIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgfVxuICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG4gIHZhciBLZWVwQWxpdmUgPSB7XG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICAgIH0sXG5cbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgfSxcblxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gICAgfVxuICB9O1xuXG4gIHZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAgIC8vIGNvbmZpZ1xuICAgIHZhciBjb25maWdEZWYgPSB7fTtcbiAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgIHtcbiAgICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICAgIFZ1ZS51dGlsID0ge1xuICAgICAgd2Fybjogd2FybixcbiAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgICB9O1xuXG4gICAgVnVlLnNldCA9IHNldDtcbiAgICBWdWUuZGVsZXRlID0gZGVsO1xuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gICAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gICAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBvYnNlcnZlKG9iaik7XG4gICAgICByZXR1cm4gb2JqXG4gICAgfTtcblxuICAgIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gICAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gICAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gICAgaW5pdFVzZShWdWUpO1xuICAgIGluaXRNaXhpbiQxKFZ1ZSk7XG4gICAgaW5pdEV4dGVuZChWdWUpO1xuICAgIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xuICB9XG5cbiAgaW5pdEdsb2JhbEFQSShWdWUpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICAgIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gICAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG4gIH0pO1xuXG4gIFZ1ZS52ZXJzaW9uID0gJzIuNi4xMSc7XG5cbiAgLyogICovXG5cbiAgLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4gIC8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuICB2YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4gIC8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbiAgdmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xuICB2YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbiAgdmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuICB2YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgICA/ICdmYWxzZSdcbiAgICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6ICd0cnVlJ1xuICB9O1xuXG4gIHZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAgICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAgICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAgICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuICApO1xuXG4gIHZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG4gIHZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG4gIH07XG5cbiAgdmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG4gIH07XG5cbiAgdmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2VcbiAgfTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgICA6IHBhcmVudC5jbGFzc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgICBzdGF0aWNDbGFzcyxcbiAgICBkeW5hbWljQ2xhc3NcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICAgIH1cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgIHJlcyArPSBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBuYW1lc3BhY2VNYXAgPSB7XG4gICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xuICB9O1xuXG4gIHZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAgICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAgICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAgICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4gICk7XG5cbiAgLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4gIC8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG4gIHZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICAgIHRydWVcbiAgKTtcblxuICB2YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG4gIHZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgICBpZiAoaXNTVkcodGFnKSkge1xuICAgICAgcmV0dXJuICdzdmcnXG4gICAgfVxuICAgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICAgIHJldHVybiAnbWF0aCdcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICAgKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbFxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybiBlbG1cbiAgICB9XG4gICAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsbVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbiAgfVxuXG4gIHZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gICAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICAgIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgdmFyIHJlZiA9IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICAgIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICAgIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICAgIGlmIChpc1JlbW92YWwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAgICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqXG4gICAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICAgKlxuICAgKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gICAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICAgKi9cblxuICB2YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG4gIHZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG4gIGZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICAgIHJldHVybiAoXG4gICAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgICAoXG4gICAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICAgKSB8fCAoXG4gICAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gICAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICAgIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gICAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBrZXk7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBjYnMgPSB7fTtcblxuICAgIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICAgIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICByZXR1cm4gcmVtb3ZlJCQxXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICFpblZQcmUgJiZcbiAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgICB9KVxuICAgICAgICApICYmXG4gICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICAgIHZub2RlLFxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgcGFyZW50RWxtLFxuICAgICAgcmVmRWxtLFxuICAgICAgbmVzdGVkLFxuICAgICAgb3duZXJBcnJheSxcbiAgICAgIGluZGV4XG4gICAgKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgIHZhciBpO1xuICAgICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAgIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICAgIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgICApIHtcbiAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICAgIHZhciBpLCBqO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICAgIG9sZFZub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICBvd25lckFycmF5LFxuICAgICAgaW5kZXgsXG4gICAgICByZW1vdmVPbmx5XG4gICAgKSB7XG4gICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICAgKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gICAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gICAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gICAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICB7XG4gICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgICAgdmFyIHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICAgIHJldHVybiB2bm9kZS5lbG1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gICAgZGlycyxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIWRpcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICB2YXIgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICB9XG4gICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZU1vZHVsZXMgPSBbXG4gICAgcmVmLFxuICAgIGRpcmVjdGl2ZXNcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICA6IGtleTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChcbiAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gICAgdmFyIGN1cmx5ID0gMDtcbiAgICB2YXIgc3F1YXJlID0gMDtcbiAgICB2YXIgcGFyZW4gPSAwO1xuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICAgKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gICAgbW9kdWxlcyxcbiAgICBrZXlcbiAgKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgOiBbXVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAgIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG4gIGZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnMsXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pY1xuICAgICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzLFxuICAgIGltcG9ydGFudCxcbiAgICB3YXJuLFxuICAgIHJhbmdlLFxuICAgIGR5bmFtaWNcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHdhcm4gJiZcbiAgICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICBnZXRTdGF0aWNcbiAgKSB7XG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbiAgLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4gIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByZW1vdmVGcm9tTWFwXG4gICkge1xuICAgIHZhciB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICAgIGl0ZW0sXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICAgIGVsLm1vZGVsID0ge1xuICAgICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gICAgdmFsdWUsXG4gICAgYXNzaWdubWVudFxuICApIHtcbiAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAgICpcbiAgICogUG9zc2libGUgY2FzZXM6XG4gICAqXG4gICAqIC0gdGVzdFxuICAgKiAtIHRlc3Rba2V5XVxuICAgKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAgICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAgICpcbiAgICovXG5cbiAgdmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgbGVuID0gdmFsLmxlbmd0aDtcblxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgIGtleTogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gdmFsO1xuICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG4gIH1cblxuICBmdW5jdGlvbiBlb2YgKCkge1xuICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgdmFyIGluQnJhY2tldCA9IDE7XG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4kMTtcblxuICAvLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4gIC8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG4gIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICB2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuICBmdW5jdGlvbiBtb2RlbCAoXG4gICAgZWwsXG4gICAgZGlyLFxuICAgIF93YXJuXG4gICkge1xuICAgIHdhcm4kMSA9IF93YXJuO1xuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICB2YXIgdGFnID0gZWwudGFnO1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICAgKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgICAgbnVsbCwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gICAge1xuICAgICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICAgIDogJ2lucHV0JztcblxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gICAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICAgIH1cblxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbiAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAvLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gIC8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldCQxO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuICAvLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4gIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgdmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbiAgZnVuY3Rpb24gYWRkJDEgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgKSB7XG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlcixcbiAgICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICAgIDogY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMiAoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIGNhcHR1cmUsXG4gICAgX3RhcmdldFxuICApIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIG5hbWUsXG4gICAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgICBjYXB0dXJlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgICBub3JtYWxpemVFdmVudHMob24pO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHN2Z0NvbnRhaW5lcjtcblxuICBmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1cjtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgZWxtW2tleV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICAgKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gICAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICAgIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgICB9XG4gICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuICB9XG5cbiAgdmFyIGRvbVByb3BzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNcbiAgfSk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gICAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgICAgOiBzdHlsZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZVxuICB9XG5cbiAgLyoqXG4gICAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAgICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgc3R5bGVEYXRhO1xuXG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgICApIHtcbiAgICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGNzc1ZhclJFID0gL14tLS87XG4gIHZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuICB2YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG4gIHZhciBlbXB0eVN0eWxlO1xuICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgICAgcmV0dXJuIHByb3BcbiAgICB9XG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyLCBuYW1lO1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICAgIDogc3R5bGU7XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuICAvKipcbiAgICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICBpZiAoY3VyKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgICBpZiAoIWRlZiQkMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgICB9XG4gICAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuICB2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbiAgdmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4gIC8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbiAgdmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuICB2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuICB2YXIgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgICA6IHNldFRpbWVvdXRcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuICBmdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJhZihmbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICAgIGVsLFxuICAgIGV4cGVjdGVkVHlwZSxcbiAgICBjYlxuICApIHtcbiAgICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICAgIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICAgIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHZhciBlbmRlZCA9IDA7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICAgIGNiKCk7XG4gICAgfTtcbiAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgdGltZW91dCA9IDA7XG4gICAgdmFyIHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICA6IG51bGw7XG4gICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgIH1cbiAgICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gICAgfSkpXG4gIH1cblxuICAvLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4gIC8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbiAgLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcbiAgLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuICBmdW5jdGlvbiB0b01zIChzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBlbC5fbGVhdmVDYigpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICAgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICAgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICAgIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICAgIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gICAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICAgIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICAgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgICA/IGFwcGVhckNsYXNzXG4gICAgICA6IGVudGVyQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICAgID8gYXBwZWFyVG9DbGFzc1xuICAgICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICAgIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgICA6IGVudGVyO1xuICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgICAgOiBhZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICAgIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgICApIHtcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm4gcm0oKVxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gICAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICAgIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICB9XG4gICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG4gIGZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gICAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICAgKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAgICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAgIC8vIGludm9rZXJcbiAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgY3JlYXRlOiBfZW50ZXIsXG4gICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiB7fTtcblxuICB2YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICAgIGF0dHJzLFxuICAgIGtsYXNzLFxuICAgIGV2ZW50cyxcbiAgICBkb21Qcm9wcyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uXG4gIF07XG5cbiAgLyogICovXG5cbiAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gIC8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gIHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbiAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgLyoqXG4gICAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICAgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlID0ge1xuICAgIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgLy8gIzY5MDNcbiAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgICA6IG9wdGlvbi52YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLyogICovXG5cbiAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuICBmdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICA6IHZub2RlXG4gIH1cblxuICB2YXIgc2hvdyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgICAgZWwsXG4gICAgICBiaW5kaW5nLFxuICAgICAgdm5vZGUsXG4gICAgICBvbGRWbm9kZSxcbiAgICAgIGlzRGVzdHJveVxuICAgICkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3c6IHNob3dcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxuICB9O1xuXG4gIC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuICAvLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuICBmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgICAvLyBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICAgIH1cbiAgICAvLyBldmVudHMuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gICAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gICAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG4gIH1cblxuICB2YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbiAgdmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICAgKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG4gIGRlbGV0ZSBwcm9wcy5tb2RlO1xuXG4gIHZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgICB9LFxuXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgICB9XG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuICB9O1xuXG4gIC8qICAqL1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcbiAgVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG4gIFZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuICBleHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuICBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuICAvLyBwdWJsaWMgbW91bnQgbWV0aG9kXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbiAgfTtcblxuICAvLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuICB2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbiAgdmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxuICB9KTtcblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgICB0ZXh0LFxuICAgIGRlbGltaXRlcnNcbiAgKSB7XG4gICAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICAgIHRva2VuczogcmF3VG9rZW5zXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gICAgfVxuICAgIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgICB2YXIgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgdmFyIGtsYXNzJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHZhciBzdHlsZSQxID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGRlY29kZXI7XG5cbiAgdmFyIGhlID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuICApO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbiAgKTtcblxuICAvLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4gIC8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB2YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAgICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICd0aXRsZSx0cix0cmFjaydcbiAgKTtcblxuICAvKipcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gICAqL1xuXG4gIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gIHZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuICB2YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qXCI7XG4gIHZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG4gIHZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbiAgdmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbiAgdmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xuICB2YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuICAvLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgdmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4gIC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG4gIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgdmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuICAvLyAjNTk5MlxuICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gICAgcGFyc2VFbmRUYWcoKTtcblxuICAgIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgICBwb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBvblJFID0gL15AfF52LW9uOi87XG4gIHZhciBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xuICB2YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgdmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gIHZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICB2YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG4gIHZhciBhcmdSRSA9IC86KC4qKSQvO1xuICB2YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xuICB2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG4gIHZhciBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxuICB2YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuICB2YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG4gIHZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG4gIHZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbiAgdmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuICAvLyBjb25maWd1cmFibGUgc3RhdGVcbiAgdmFyIHdhcm4kMjtcbiAgdmFyIGRlbGltaXRlcnM7XG4gIHZhciB0cmFuc2Zvcm1zO1xuICB2YXIgcHJlVHJhbnNmb3JtcztcbiAgdmFyIHBvc3RUcmFuc2Zvcm1zO1xuICB2YXIgcGxhdGZvcm1Jc1ByZVRhZztcbiAgdmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG4gIHZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbiAgdmFyIG1heWJlQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICAgIHRhZyxcbiAgICBhdHRycyxcbiAgICBwYXJlbnRcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEsXG4gICAgICB0YWc6IHRhZyxcbiAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gICAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gICAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gICAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgICB2YXIgcm9vdDtcbiAgICB2YXIgY3VycmVudFBhcmVudDtcbiAgICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gICAgdmFyIGluUHJlID0gZmFsc2U7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgICB3YXJuOiB3YXJuJDIsXG4gICAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xuICAgICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcm9vdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgICAgZWwucHJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgICBlbGVtZW50LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAgICFlbGVtZW50LmtleSAmJlxuICAgICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgICApO1xuXG4gICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gICAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICAgIHZhciBleHA7XG4gICAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICAgIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICAgIGlmIChleHApIHtcbiAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGJsb2NrOiBlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgICBpZiAoZWxzZWlmKSB7XG4gICAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gICAgfVxuICAgIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbiAgLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG4gIGZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cblxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICAgICAgdmFyIGR5bmFtaWMgPSByZWYuZHluYW1pYztcbiAgICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgIGlmIChzbG90QmluZGluZyQxKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgICAgXCI8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5cIixcbiAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICAgIHZhciBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgICB2YXIgZHluYW1pYyQxID0gcmVmJDEuZHluYW1pYztcbiAgICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljJDE7XG4gICAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZyQxLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gICAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuXCIsXG4gICAgICAgICAgYmluZGluZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAgIC8vIGR5bmFtaWMgW25hbWVdXG4gICAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgICAgLy8gc3RhdGljIG5hbWVcbiAgICAgIDogeyBuYW1lOiAoXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpLCBkeW5hbWljOiBmYWxzZSB9XG4gIH1cblxuICAvLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG4gIGZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0IChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICAgIGlmIChlbC5rZXkpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgICB2YXIgYmluZGluZztcbiAgICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICAgIH1cbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgICAvLyBtb2RpZmllcnNcbiAgICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIChcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXCJ2LWJpbmQ6XCIgKyBuYW1lICsgXCJcXFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgICAge1xuICAgICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gZWw7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgcmV0ID0ge307XG4gICAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICAgICkge1xuICAgICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgICB9XG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG4gIGZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICAgIHJldHVybiAoXG4gICAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICkpXG4gICAgKVxuICB9XG5cbiAgdmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG4gIHZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICAgIHZhciBfZWwgPSBlbDtcbiAgICB3aGlsZSAoX2VsKSB7XG4gICAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBfZWwgPSBfZWwucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVCaW5kaW5nO1xuICAgICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDMuIG90aGVyXG4gICAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnJhbmNoMFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG4gIH1cblxuICB2YXIgbW9kZWwkMSA9IHtcbiAgICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG4gIH07XG5cbiAgdmFyIG1vZHVsZXMkMSA9IFtcbiAgICBrbGFzcyQxLFxuICAgIHN0eWxlJDEsXG4gICAgbW9kZWwkMVxuICBdO1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyQxID0ge1xuICAgIG1vZGVsOiBtb2RlbCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGh0bWw6IGh0bWxcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICAgIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICAgIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICAgIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gICAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGlzU3RhdGljS2V5O1xuICB2YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG4gIHZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbiAgLyoqXG4gICAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gICAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAgICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAgICpcbiAgICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gICAqXG4gICAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAgICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICAgKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICovXG4gIGZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gICAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gICAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gICAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAgIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gICAgcmV0dXJuIG1ha2VNYXAoXG4gICAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgICBpZiAoXG4gICAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICAgKSkge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICAgKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xuICB2YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xuICB2YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuICAvLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuICB2YXIga2V5Q29kZXMgPSB7XG4gICAgZXNjOiAyNyxcbiAgICB0YWI6IDksXG4gICAgZW50ZXI6IDEzLFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgICdkZWxldGUnOiBbOCwgNDZdXG4gIH07XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gICAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgICB0YWI6ICdUYWInLFxuICAgIGVudGVyOiAnRW50ZXInLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gICAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAgIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gICAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICAgIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gICAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG4gIH07XG5cbiAgLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbiAgLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuICAvLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG4gIHZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG4gIHZhciBtb2RpZmllckNvZGUgPSB7XG4gICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICAgIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICAgIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gICAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gICAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gICAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gICAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gICAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbiAgfTtcblxuICBmdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gICAgZXZlbnRzLFxuICAgIGlzTmF0aXZlXG4gICkge1xuICAgIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gICAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgICB9XG5cbiAgICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gICAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gICAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmIChrZXlWYWwpIHtcbiAgICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICAgIH1cbiAgICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gICAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgICBcIiRldmVudC5rZXksXCIgK1xuICAgICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgICAgXCIpXCJcbiAgICApXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICAgIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgICB9XG4gICAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gICAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gICAgb246IG9uLFxuICAgIGJpbmQ6IGJpbmQkMSxcbiAgICBjbG9hazogbm9vcFxuICB9O1xuXG4gIC8qICAqL1xuXG5cblxuXG5cbiAgdmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICAgIHRoaXMub25jZUlkID0gMDtcbiAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgIHRoaXMucHJlID0gZmFsc2U7XG4gIH07XG5cblxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgICBhc3QsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAgIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgICB9XG5cbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICAgIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICAgIHZhciBjb2RlO1xuICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgICB9XG4gICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbiAgZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAgIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAgIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgc3RhdGUucHJlID0gZWwucHJlO1xuICAgIH1cbiAgICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICAgIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH1cblxuICAvLyB2LW9uY2VcbiAgZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gICAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgICB2YXIga2V5ID0gJyc7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgc3RhdGUud2FybihcbiAgICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICAgIGNvbmRpdGlvbnMsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgICB9XG5cbiAgICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gICAgfVxuXG4gICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgICByZXR1cm4gYWx0R2VuXG4gICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBlbC5vbmNlXG4gICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZvciAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEhlbHBlclxuICApIHtcbiAgICB2YXIgZXhwID0gZWwuZm9yO1xuICAgIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgICBpZiAoc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAhZWwua2V5XG4gICAgKSB7XG4gICAgICBzdGF0ZS53YXJuKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICApO1xuICAgIH1cblxuICAgIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICAgJ30pJ1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgZGF0YSA9ICd7JztcblxuICAgIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAgIC8vIGtleVxuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyByZWZcbiAgICBpZiAoZWwucmVmKSB7XG4gICAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgICB9XG4gICAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcHJlXG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICAgIH1cbiAgICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgIH1cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBET00gcHJvcHNcbiAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNsb3QgdGFyZ2V0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gICAgfVxuICAgIC8vIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAgIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAgIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gICAgfVxuICAgIC8vIHYtb24gZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICAgIGlmICghZGlycykgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICAgIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICAgIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZGlyID0gZGlyc1tpXTtcbiAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNSdW50aW1lKSB7XG4gICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMSkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gICAgZWwsXG4gICAgc2xvdHMsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gZWwuZm9yIHx8IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcbiAgICAgICAgc2xvdC5pZiB8fFxuICAgICAgICBzbG90LmZvciB8fFxuICAgICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgICAgKVxuICAgIH0pO1xuXG4gICAgLy8gIzk1MzQ6IGlmIGEgY29tcG9uZW50IHdpdGggc2NvcGVkIHNsb3RzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJyYW5jaCxcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAgIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gICAgLy8gdGhlIGdlbmVyYXRlZCBjb2RlIG9mIGFsbCB0aGUgc2xvdCBjb250ZW50cy5cbiAgICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xuXG4gICAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gICAgLy8gZGlzY29ubmVjdGVkIGR1ZSB0byB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIHZhcmlhYmxlKVxuICAgIC8vICM5NDM4LCAjOTUwNlxuICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAgIC8vIGFuZCBza2lwIGZvcmNlIHVwZGF0aW5nIG9uZXMgdGhhdCBkbyBub3QgYWN0dWFsbHkgdXNlIHNjb3BlIHZhcmlhYmxlcy5cbiAgICBpZiAoIW5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICAgIHBhcmVudC5mb3JcbiAgICAgICAgKSB7XG4gICAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgICAgbmVlZHNLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpOyB9KVxuICAgICAgLmpvaW4oJywnKTtcblxuICAgIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG4gIH1cblxuICBmdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBoYXNoID0gNTM4MTtcbiAgICB2YXIgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUoaSkge1xuICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2ggPj4+IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkIChlbCkge1xuICAgIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICAgIGVsLFxuICAgIHN0YXRlXG4gICkge1xuICAgIHZhciBpc0xlZ2FjeVN5bnRheCA9IGVsLmF0dHJzTWFwWydzbG90LXNjb3BlJ107XG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIFwibnVsbFwiKVxuICAgIH1cbiAgICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxuICAgIH1cbiAgICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgICA/IFwiXCJcbiAgICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gICAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XG4gICAgcmV0dXJuIChcIntrZXk6XCIgKyAoZWwuc2xvdFRhcmdldCB8fCBcIlxcXCJkZWZhdWx0XFxcIlwiKSArIFwiLGZuOlwiICsgZm4gKyByZXZlcnNlUHJveHkgKyBcIn1cIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgICBlbCxcbiAgICBzdGF0ZSxcbiAgICBjaGVja1NraXAsXG4gICAgYWx0R2VuRWxlbWVudCxcbiAgICBhbHRHZW5Ob2RlXG4gICkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICAgKSB7XG4gICAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIHJldHVybiAoXCJcIiArICgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSkpICsgbm9ybWFsaXphdGlvblR5cGUpXG4gICAgICB9XG4gICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUkMSA9IGNoZWNrU2tpcFxuICAgICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgICAgOiAwO1xuICAgICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUkMSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlJDEpIDogJycpKVxuICAgIH1cbiAgfVxuXG4gIC8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbiAgLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbiAgLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuICAvLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgICBjaGlsZHJlbixcbiAgICBtYXliZUNvbXBvbmVudFxuICApIHtcbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICAgIHJlcyA9IDI7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gICAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gICAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICAgIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gICAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XG4gICAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgICAgfSk7IH0pKVxuICAgICAgOiBudWxsO1xuICAgIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICAgIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgICByZXMgKz0gXCIsbnVsbFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICAgIH1cbiAgICBpZiAoYmluZCQkMSkge1xuICAgICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gICAgfVxuICAgIHJldHVybiByZXMgKyAnKSdcbiAgfVxuXG4gIC8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgICBjb21wb25lbnROYW1lLFxuICAgIGVsLFxuICAgIHN0YXRlXG4gICkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gICAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgICB2YXIgZHluYW1pY1Byb3BzID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gICAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgICAgcmV0dXJuIChcIl9kKFwiICsgc3RhdGljUHJvcHMgKyBcIixbXCIgKyAoZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICAgIH1cbiAgfVxuXG4gIC8vICMzODk1LCAjNDI2OFxuICBmdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5JylcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICAvLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuICAvLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG4gIHZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAgICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4gICkuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbiAgLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbiAgdmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbiAgKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbiAgLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuICB2YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4gIC8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG4gIGZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gICAgaWYgKGFzdCkge1xuICAgICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIHZhciBzdHJpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICAgIGlkZW50LFxuICAgIHR5cGUsXG4gICAgdGV4dCxcbiAgICB3YXJuLFxuICAgIHJhbmdlXG4gICkge1xuICAgIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgICByYW5nZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgcmFuZ2UgPSAyO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgICBzb3VyY2UsXG4gICAgc3RhcnQsXG4gICAgZW5kXG4gICkge1xuICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgeyBjb250aW51ZSB9XG4gICAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGVhdCQxIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICAgIG4gPj4+PSAxO1xuICAgICAgICBpZiAobiA8PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICAgIHJldHVybiBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHZtXG4gICAgKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBjYWNoZVxuICAgICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgICAgOiB0ZW1wbGF0ZTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBpbGVcbiAgICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAge1xuICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgICB9KTtcblxuICAgICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB0aXBzID0gW107XG5cbiAgICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICAgIHtcbiAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICByZXR1cm4gY29tcGlsZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuICAvLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4gIC8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxuICB2YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogYXN0LFxuICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbiAgdmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xuICB2YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gIC8qICAqL1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG4gIHZhciBkaXY7XG4gIGZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbiAgfVxuXG4gIC8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG4gIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbiAgLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxuICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbiAgLyogICovXG5cbiAgdmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxuICB9KTtcblxuICB2YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICAgIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICAgKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgICB9XG4gIH1cblxuICBWdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuICByZXR1cm4gVnVlO1xuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/vue/dist/vue.js\n")},"../node_modules/webpack/buildin/global.js":function(module,exports){eval('var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanM/YTQyYiJdLCJuYW1lcyI6WyJnIiwiRnVuY3Rpb24iLCJlIiwid2luZG93IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsQ0FBSixDLENBRUE7O0FBQ0FBLENBQUMsR0FBSSxZQUFXO0FBQ2YsU0FBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxHQUFDLEdBQUdBLENBQUMsSUFBSSxJQUFJQyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNYO0FBQ0EsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDSCxDQUFDLEdBQUdHLE1BQUo7QUFDaEMsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsQ0FBakIiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/webpack/buildin/global.js\n')},"./js/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n/* harmony import */ var _babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\nvar _vue = __webpack_require__(/*! vue */ "../node_modules/vue/dist/vue.js");\n\nvar _vue2 = _babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0___default()(_vue);\n\n__webpack_require__(/*! ../scss/style.scss */ "./scss/style.scss");\n\nvar _vueMultipleProgress = __webpack_require__(/*! vue-multiple-progress */ "../node_modules/vue-multiple-progress/lib/progress.js");\n\nvar _vueMultipleProgress2 = _babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0___default()(_vueMultipleProgress);\n\nvar _gsap = __webpack_require__(/*! gsap */ "../node_modules/gsap/index.js");\n\nvar _gsap2 = _babel_runtime_helpers_interopRequireDefault__WEBPACK_IMPORTED_MODULE_0___default()(_gsap);\n\n_vue2.default.component(\'vm-progress\', _vueMultipleProgress2.default);\n\n_vue2.default.use(_vueMultipleProgress2.default);\n\nvar app = new _vue2.default({\n  el: \'#app\',\n  data: function data() {\n    return {\n      tl: _gsap2.default.timeline({}),\n      tlImages: _gsap2.default.timeline({\n        paused: false,\n        delay: 0.3,\n        repeat: -1\n      }),\n      tlStripe: _gsap2.default.timeline({\n        paused: false,\n        delay: 0,\n        repeat: -1\n      }),\n      countDown: 5,\n      duration: 5,\n      sequence: 2,\n      elements: _gsap2.default.utils.toArray(".content"),\n      firstTime: true\n    };\n  },\n  methods: {\n    resetTimer: function resetTimer() {\n      this.countDown = this.duration;\n    },\n    timer: function timer() {\n      var _this = this;\n\n      if (this.countDown > 0) {\n        setTimeout(function () {\n          _this.countDown -= 1;\n\n          _this.timer();\n        }, 1000);\n      } else {\n        this.countDown = this.duration;\n        this.timer();\n      }\n    },\n    animationA: function animationA(i) {\n      var _this2 = this;\n\n      var content = \'.content-\' + this.sequence;\n      var image = \'.backImage-\' + this.sequence;\n\n      _gsap2.default.fromTo(content, {\n        x: -100,\n        opacity: 0\n      }, {\n        x: 0,\n        opacity: 1,\n        duration: 1\n      });\n\n      _gsap2.default.fromTo(image, {\n        scale: 1.2,\n        opacity: 0\n      }, {\n        scale: 1.1,\n        opacity: 1,\n        duration: 1\n      });\n\n      _gsap2.default.to(content, {\n        x: -100,\n        opacity: 0,\n        duration: 0.5,\n        delay: this.duration\n      });\n\n      _gsap2.default.to(image, {\n        scale: 1,\n        opacity: 0,\n        duration: 0.5,\n        delay: this.duration\n      }).then(function () {\n        if (_this2.sequence > 0) {\n          _this2.sequence--;\n        } else {\n          _this2.sequence = 2;\n        }\n\n        _this2.animationA();\n      });\n    }\n  },\n  computed: {\n    timeFraction: function timeFraction() {\n      var rawTimeFraction = this.countDown / this.duration;\n      return rawTimeFraction * 100;\n    }\n  },\n  mounted: function mounted() {\n    // console.log(Object.keys(this.elements).length)\n    this.animationA();\n    this.timer();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9pbmRleC5qcz9lZTFjIl0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCIsIlByb2dyZXNzIiwidXNlIiwiYXBwIiwiZWwiLCJkYXRhIiwidGwiLCJnc2FwIiwidGltZWxpbmUiLCJ0bEltYWdlcyIsInBhdXNlZCIsImRlbGF5IiwicmVwZWF0IiwidGxTdHJpcGUiLCJjb3VudERvd24iLCJkdXJhdGlvbiIsInNlcXVlbmNlIiwiZWxlbWVudHMiLCJ1dGlscyIsInRvQXJyYXkiLCJmaXJzdFRpbWUiLCJtZXRob2RzIiwicmVzZXRUaW1lciIsInRpbWVyIiwic2V0VGltZW91dCIsImFuaW1hdGlvbkEiLCJpIiwiY29udGVudCIsImltYWdlIiwiZnJvbVRvIiwieCIsIm9wYWNpdHkiLCJzY2FsZSIsInRvIiwidGhlbiIsImNvbXB1dGVkIiwidGltZUZyYWN0aW9uIiwicmF3VGltZUZyYWN0aW9uIiwibW91bnRlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBQSxjQUFJQyxTQUFKLENBQWMsYUFBZCxFQUE2QkMsNkJBQTdCOztBQUNBRixjQUFJRyxHQUFKLENBQVFELDZCQUFSOztBQUVBLElBQUlFLEdBQUcsR0FBRyxJQUFJSixhQUFKLENBQVE7QUFDaEJLLElBQUUsRUFBRSxNQURZO0FBRWhCQyxNQUZnQixrQkFFVDtBQUNMLFdBQU87QUFDTEMsUUFBRSxFQUFFQyxlQUFLQyxRQUFMLENBQWMsRUFBZCxDQURDO0FBRUxDLGNBQVEsRUFBRUYsZUFBS0MsUUFBTCxDQUFjO0FBQUVFLGNBQU0sRUFBRSxLQUFWO0FBQWlCQyxhQUFLLEVBQUUsR0FBeEI7QUFBNkJDLGNBQU0sRUFBRSxDQUFDO0FBQXRDLE9BQWQsQ0FGTDtBQUdMQyxjQUFRLEVBQUVOLGVBQUtDLFFBQUwsQ0FBYztBQUFFRSxjQUFNLEVBQUUsS0FBVjtBQUFpQkMsYUFBSyxFQUFFLENBQXhCO0FBQTJCQyxjQUFNLEVBQUUsQ0FBQztBQUFwQyxPQUFkLENBSEw7QUFJTEUsZUFBUyxFQUFFLENBSk47QUFLTEMsY0FBUSxFQUFFLENBTEw7QUFNTEMsY0FBUSxFQUFFLENBTkw7QUFPTEMsY0FBUSxFQUFFVixlQUFLVyxLQUFMLENBQVdDLE9BQVgsQ0FBbUIsVUFBbkIsQ0FQTDtBQVFMQyxlQUFTLEVBQUU7QUFSTixLQUFQO0FBVUQsR0FiZTtBQWNoQkMsU0FBTyxFQUFFO0FBQ1BDLGNBRE8sd0JBQ007QUFDWCxXQUFLUixTQUFMLEdBQWlCLEtBQUtDLFFBQXRCO0FBQ0QsS0FITTtBQUlQUSxTQUpPLG1CQUlDO0FBQUE7O0FBQ04sVUFBSSxLQUFLVCxTQUFMLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCVSxrQkFBVSxDQUFDLFlBQU07QUFDZixlQUFJLENBQUNWLFNBQUwsSUFBa0IsQ0FBbEI7O0FBQ0EsZUFBSSxDQUFDUyxLQUFMO0FBQ0QsU0FIUyxFQUdQLElBSE8sQ0FBVjtBQUlELE9BTEQsTUFLTztBQUNMLGFBQUtULFNBQUwsR0FBaUIsS0FBS0MsUUFBdEI7QUFDQSxhQUFLUSxLQUFMO0FBQ0Q7QUFDRixLQWRNO0FBZVBFLGNBZk8sc0JBZUlDLENBZkosRUFlTztBQUFBOztBQUNaLFVBQUlDLE9BQU8sR0FBRyxjQUFjLEtBQUtYLFFBQWpDO0FBQ0EsVUFBSVksS0FBSyxHQUFHLGdCQUFnQixLQUFLWixRQUFqQzs7QUFDQVQscUJBQUtzQixNQUFMLENBQVlGLE9BQVosRUFBcUI7QUFBRUcsU0FBQyxFQUFFLENBQUMsR0FBTjtBQUFXQyxlQUFPLEVBQUU7QUFBcEIsT0FBckIsRUFBOEM7QUFBRUQsU0FBQyxFQUFFLENBQUw7QUFBUUMsZUFBTyxFQUFFLENBQWpCO0FBQW9CaEIsZ0JBQVEsRUFBRTtBQUE5QixPQUE5Qzs7QUFDQVIscUJBQUtzQixNQUFMLENBQVlELEtBQVosRUFBbUI7QUFBRUksYUFBSyxFQUFFLEdBQVQ7QUFBY0QsZUFBTyxFQUFFO0FBQXZCLE9BQW5CLEVBQStDO0FBQUVDLGFBQUssRUFBRSxHQUFUO0FBQWNELGVBQU8sRUFBRSxDQUF2QjtBQUEwQmhCLGdCQUFRLEVBQUU7QUFBcEMsT0FBL0M7O0FBQ0FSLHFCQUFLMEIsRUFBTCxDQUFRTixPQUFSLEVBQWlCO0FBQUVHLFNBQUMsRUFBRSxDQUFDLEdBQU47QUFBV0MsZUFBTyxFQUFFLENBQXBCO0FBQXVCaEIsZ0JBQVEsRUFBRSxHQUFqQztBQUFzQ0osYUFBSyxFQUFFLEtBQUtJO0FBQWxELE9BQWpCOztBQUNBUixxQkFBSzBCLEVBQUwsQ0FBUUwsS0FBUixFQUFlO0FBQUVJLGFBQUssRUFBRSxDQUFUO0FBQVlELGVBQU8sRUFBRSxDQUFyQjtBQUF3QmhCLGdCQUFRLEVBQUUsR0FBbEM7QUFBdUNKLGFBQUssRUFBRSxLQUFLSTtBQUFuRCxPQUFmLEVBQThFbUIsSUFBOUUsQ0FBbUYsWUFBTTtBQUN2RixZQUFJLE1BQUksQ0FBQ2xCLFFBQUwsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsZ0JBQUksQ0FBQ0EsUUFBTDtBQUNELFNBRkQsTUFFTztBQUNMLGdCQUFJLENBQUNBLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRDs7QUFDRCxjQUFJLENBQUNTLFVBQUw7QUFDRCxPQVBEO0FBUUQ7QUE3Qk0sR0FkTztBQThDaEJVLFVBQVEsRUFBRTtBQUNSQyxnQkFEUSwwQkFDTztBQUNiLFVBQU1DLGVBQWUsR0FBRyxLQUFLdkIsU0FBTCxHQUFpQixLQUFLQyxRQUE5QztBQUNBLGFBQU9zQixlQUFlLEdBQUcsR0FBekI7QUFDRDtBQUpPLEdBOUNNO0FBcURoQkMsU0FyRGdCLHFCQXFETjtBQUNSO0FBRUEsU0FBS2IsVUFBTDtBQUNBLFNBQUtGLEtBQUw7QUFDRDtBQTFEZSxDQUFSLENBQVYiLCJmaWxlIjoiLi9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0ICcuLi9zY3NzL3N0eWxlLnNjc3MnXG5pbXBvcnQgUHJvZ3Jlc3MgZnJvbSAndnVlLW11bHRpcGxlLXByb2dyZXNzJ1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxuVnVlLmNvbXBvbmVudCgndm0tcHJvZ3Jlc3MnLCBQcm9ncmVzcylcblZ1ZS51c2UoUHJvZ3Jlc3MpXG5cbnZhciBhcHAgPSBuZXcgVnVlKHtcbiAgZWw6ICcjYXBwJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGw6IGdzYXAudGltZWxpbmUoe30pLFxuICAgICAgdGxJbWFnZXM6IGdzYXAudGltZWxpbmUoeyBwYXVzZWQ6IGZhbHNlLCBkZWxheTogMC4zLCByZXBlYXQ6IC0xLCB9KSxcbiAgICAgIHRsU3RyaXBlOiBnc2FwLnRpbWVsaW5lKHsgcGF1c2VkOiBmYWxzZSwgZGVsYXk6IDAsIHJlcGVhdDogLTEsIH0pLFxuICAgICAgY291bnREb3duOiA1LFxuICAgICAgZHVyYXRpb246IDUsXG4gICAgICBzZXF1ZW5jZTogMixcbiAgICAgIGVsZW1lbnRzOiBnc2FwLnV0aWxzLnRvQXJyYXkoXCIuY29udGVudFwiKSxcbiAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJlc2V0VGltZXIoKSB7XG4gICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuZHVyYXRpb25cbiAgICB9LFxuICAgIHRpbWVyKCkge1xuICAgICAgaWYgKHRoaXMuY291bnREb3duID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNvdW50RG93biAtPSAxXG4gICAgICAgICAgdGhpcy50aW1lcigpXG4gICAgICAgIH0sIDEwMDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lcigpXG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRpb25BKGkpIHtcbiAgICAgIHZhciBjb250ZW50ID0gJy5jb250ZW50LScgKyB0aGlzLnNlcXVlbmNlXG4gICAgICB2YXIgaW1hZ2UgPSAnLmJhY2tJbWFnZS0nICsgdGhpcy5zZXF1ZW5jZVxuICAgICAgZ3NhcC5mcm9tVG8oY29udGVudCwgeyB4OiAtMTAwLCBvcGFjaXR5OiAwIH0sIHsgeDogMCwgb3BhY2l0eTogMSwgZHVyYXRpb246IDEgfSlcbiAgICAgIGdzYXAuZnJvbVRvKGltYWdlLCB7IHNjYWxlOiAxLjIsIG9wYWNpdHk6IDAgfSwgeyBzY2FsZTogMS4xLCBvcGFjaXR5OiAxLCBkdXJhdGlvbjogMSB9KVxuICAgICAgZ3NhcC50byhjb250ZW50LCB7IHg6IC0xMDAsIG9wYWNpdHk6IDAsIGR1cmF0aW9uOiAwLjUsIGRlbGF5OiB0aGlzLmR1cmF0aW9uIH0pXG4gICAgICBnc2FwLnRvKGltYWdlLCB7IHNjYWxlOiAxLCBvcGFjaXR5OiAwLCBkdXJhdGlvbjogMC41LCBkZWxheTogdGhpcy5kdXJhdGlvbiB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXF1ZW5jZS0tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXF1ZW5jZSA9IDJcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbkEoKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gXG4gIGNvbXB1dGVkOiB7XG4gICAgdGltZUZyYWN0aW9uKCkge1xuICAgICAgY29uc3QgcmF3VGltZUZyYWN0aW9uID0gdGhpcy5jb3VudERvd24gLyB0aGlzLmR1cmF0aW9uO1xuICAgICAgcmV0dXJuIHJhd1RpbWVGcmFjdGlvbiAqIDEwMFxuICAgIH1cbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKHRoaXMuZWxlbWVudHMpLmxlbmd0aClcbiAgICBcbiAgICB0aGlzLmFuaW1hdGlvbkEoKVxuICAgIHRoaXMudGltZXIoKVxuICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/index.js\n')},"./scss/style.scss":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3NzL3N0eWxlLnNjc3M/MTEwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL3Njc3Mvc3R5bGUuc2Nzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./scss/style.scss\n")}});